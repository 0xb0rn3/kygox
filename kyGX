#!/usr/bin/env bash

set -euo pipefail

readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$USER_HOME/.kyGX"
readonly CONFIG_DIR="$USER_HOME/.config/kyGX"
readonly STATE_FILE="$CONFIG_DIR/kyGX_state.json"
readonly BACKUP_DIR="$CONFIG_DIR/backups"
readonly TOOLS_CACHE="$CONFIG_DIR/.toollist.json"
readonly AUR_CACHE="$CONFIG_DIR/.aur_tools.json"
readonly FAILED_TOOLS_FILE="$CONFIG_DIR/.failed_tools.txt"
readonly TOOLS_URL="https://blackarch.org/tools.html"

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g AUR_FALLBACK_COUNT=0
declare -g BLACKARCH_INSTALL_COUNT=0

# Default BlackArch configuration packages
readonly DEFAULT_CONFIGS=(
    "blackarch-menus"
    "blackarch-config-gtk"
    "blackarch-config-zsh"
)

declare -A SLIM_TOOLS=(
    ["information-gathering"]="nmap masscan nikto recon-ng theharvester dnsenum fierce wafw00f whatweb dmitry"
    ["vulnerability-analysis"]="sqlmap wpscan metasploit openvas lynis nikto skipfish uniscan"
    ["web-applications"]="burpsuite zaproxy wfuzz sqlmap dirb dirbuster gobuster wpscan commix"
    ["password-attacks"]="john hydra hashcat medusa ncrack ophcrack patator crunch"
    ["wireless-attacks"]="aircrack-ng reaver wifite kismet mdk3 pixiewps bully fern-wifi-cracker"
    ["exploitation"]="metasploit armitage beef routersploit"
    ["forensics"]="autopsy volatility sleuthkit binwalk foremost testdisk"
    ["sniffing-spoofing"]="wireshark ettercap arpspoof tcpdump dsniff bettercap mitmproxy responder"
    ["post-exploitation"]="weevely laudanum"
    ["social-engineering"]="set king-phisher"
)

init_dirs() {
    mkdir -p "$LOG_DIR" "$CONFIG_DIR" "$BACKUP_DIR"
    touch "$FAILED_TOOLS_FILE"
}

log_message() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_DIR/kyGX.log"
}

error_exit() {
    echo -e "${RED}[!] $*${RESET}" >&2
    log_message "ERROR: $*"
    exit 1
}

check_root() {
    [[ $EUID -eq 0 ]] || error_exit "Root privileges required. Run with sudo."
}

show_minimal_loader() {
    local message="$1"
    local duration="${2:-3}"
    
    (
        local chars=("." ".." "...")
        local i=0
        local start=$(date +%s)
        
        while true; do
            local elapsed=$(($(date +%s) - start))
            [[ $elapsed -ge $duration ]] && break
            
            printf "\r[*] %s%s   " "$message" "${chars[$((i % 3))]}"
            ((i++))
            sleep 0.3
        done
        
        printf "\r[+] %s\n" "$message"
    ) &
    
    wait $! 2>/dev/null || true
}

validate_system() {
    echo "[*] Validating system"
    
    if ! command -v pacman &>/dev/null; then
        error_exit "pacman not found. This tool requires Arch Linux."
    fi
    
    if ! ping -c 1 archlinux.org &>/dev/null 2>&1; then
        echo "[!] Network connectivity issue detected"
    fi
    
    echo "[+] System validation complete"
}

install_dependencies() {
    local required_packages=("curl" "wget" "python" "jq" "git" "base-devel")
    local missing_packages=()
    
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        echo "[*] Installing dependencies: ${missing_packages[*]}"
        pacman -Sy --noconfirm --needed "${missing_packages[@]}" >> "$LOG_DIR/kyGX.log" 2>&1 || error_exit "Failed to install dependencies"
        echo "[+] Dependencies installed"
    fi
}

check_and_install_yay() {
    if command -v yay &>/dev/null; then
        echo "[+] yay (AUR helper) already installed"
        return 0
    fi
    
    echo "[*] Installing yay (AUR helper)"
    
    cd /tmp || exit 1
    
    if [[ -d "yay" ]]; then
        rm -rf yay
    fi
    
    if ! sudo -u "$ORIGINAL_USER" git clone https://aur.archlinux.org/yay.git >> "$LOG_DIR/kyGX.log" 2>&1; then
        error_exit "Failed to clone yay repository"
    fi
    
    cd yay || exit 1
    
    if ! sudo -u "$ORIGINAL_USER" makepkg -si --noconfirm >> "$LOG_DIR/kyGX.log" 2>&1; then
        cd ..
        rm -rf yay
        error_exit "Failed to install yay"
    fi
    
    cd ..
    rm -rf yay
    
    echo "[+] yay installed successfully"
    log_message "YAY: Installed yay AUR helper"
}

backup_pacman_conf() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/pacman.conf.$timestamp"
    
    if [[ -f /etc/pacman.conf ]]; then
        cp /etc/pacman.conf "$backup_file"
        log_message "Backed up pacman.conf to $backup_file"
    fi
}

restore_default_pacman_conf() {
    echo -e "${YELLOW}[?] Restore default Arch Linux pacman.conf? (y/n):${RESET} "
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        backup_pacman_conf
        
        cat > /etc/pacman.conf << 'EOF'
[options]
HoldPkg     = pacman glibc
Architecture = auto
CheckSpace
ParallelDownloads = 5
SigLevel    = Required DatabaseOptional
LocalFileSigLevel = Optional

[core]
Include = /etc/pacman.d/mirrorlist

[extra]
Include = /etc/pacman.d/mirrorlist

[multilib]
Include = /etc/pacman.d/mirrorlist
EOF
        
        echo "[+] Restored default pacman.conf"
        log_message "Restored default pacman.conf"
    fi
}

setup_blackarch_repository() {
    if grep -q "^\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo "[+] BlackArch repository already configured"
    else
        echo "[*] Setting up BlackArch repository"
        backup_pacman_conf
        
        cd /tmp || exit 1
        
        if ! curl -O https://blackarch.org/strap.sh 2>/dev/null; then
            error_exit "Failed to download BlackArch setup script"
        fi
        
        chmod +x strap.sh
        
        if ! ./strap.sh 2>&1 | grep -v "^$" >> "$LOG_DIR/kyGX.log"; then
            rm -f strap.sh
            error_exit "Failed to setup BlackArch repository"
        fi
        
        rm -f strap.sh
        
        echo "[+] BlackArch repository configured"
        
        pacman -Sy >> "$LOG_DIR/kyGX.log" 2>&1
    fi
    
    # Install default BlackArch configuration packages
    install_default_configs
}

install_default_configs() {
    echo "[*] Installing default BlackArch configuration packages"
    
    for config in "${DEFAULT_CONFIGS[@]}"; do
        if pacman -Qi "$config" &>/dev/null 2>&1; then
            echo "[+] $config already installed"
        else
            echo "[*] Installing $config"
            if pacman -S --noconfirm --needed "$config" >> "$LOG_DIR/kyGX.log" 2>&1; then
                echo "[+] $config installed"
                log_message "CONFIG: Installed $config"
            else
                echo "[!] Failed to install $config"
                log_message "CONFIG: Failed to install $config"
            fi
        fi
    done
}

fetch_blackarch_tools() {
    echo "[*] Fetching tool list from BlackArch"
    
    local parser_script="/tmp/blackarch_parser_$$.py"
    
    cat > "$parser_script" << 'PYEOF'
#!/usr/bin/env python3
import sys
import json
from urllib.request import urlopen, Request
from html.parser import HTMLParser

class BlackArchToolsParser(HTMLParser):
    """Parse BlackArch tools.html table
    
    Table structure: Name | Version | Description | Category | Website
    Example: 0d1n | 263.2d723ae | Web security tool... | blackarch-webapp | link
    """
    
    def __init__(self):
        super().__init__()
        self.tools = {}
        self.in_table = False
        self.in_row = False
        self.in_cell = False
        self.cell_index = 0
        self.current_row_data = []
        self.header_passed = False
        
    def handle_starttag(self, tag, attrs):
        if tag == 'table':
            self.in_table = True
        elif tag == 'tr' and self.in_table:
            self.in_row = True
            self.cell_index = 0
            self.current_row_data = []
        elif tag in ('td', 'th') and self.in_row:
            self.in_cell = True
    
    def handle_endtag(self, tag):
        if tag == 'table':
            self.in_table = False
        elif tag == 'tr' and self.in_row:
            self.in_row = False
            
            if len(self.current_row_data) >= 4:
                if not self.header_passed:
                    if 'name' in self.current_row_data[0].lower():
                        self.header_passed = True
                        return
                
                tool_name = self.current_row_data[0].strip()
                category = self.current_row_data[3].strip()
                
                if category.startswith('blackarch-'):
                    category = category[10:]
                
                if category and tool_name:
                    if category not in self.tools:
                        self.tools[category] = []
                    if tool_name not in self.tools[category]:
                        self.tools[category].append(tool_name)
            
            self.current_row_data = []
        elif tag in ('td', 'th'):
            self.in_cell = False
            self.cell_index += 1
    
    def handle_data(self, data):
        if self.in_cell and self.in_row:
            text = data.strip()
            if text:
                if len(self.current_row_data) <= self.cell_index:
                    self.current_row_data.append(text)
                else:
                    self.current_row_data[self.cell_index] += text

try:
    req = Request(sys.argv[1], headers={'User-Agent': 'Mozilla/5.0'})
    with urlopen(req, timeout=15) as response:
        html = response.read().decode('utf-8')
    
    parser = BlackArchToolsParser()
    parser.feed(html)
    
    tools = {cat: tools_list for cat, tools_list in parser.tools.items() if tools_list}
    print(json.dumps(tools, indent=2))
    
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
PYEOF
    
    chmod +x "$parser_script"
    
    local tools_json
    if tools_json=$(python3 "$parser_script" "$TOOLS_URL" 2>/dev/null); then
        echo "$tools_json" > "$TOOLS_CACHE"
        
        local category_count=$(echo "$tools_json" | jq 'length' 2>/dev/null || echo "0")
        local tool_count=$(echo "$tools_json" | jq '[.[]] | add | length' 2>/dev/null || echo "0")
        
        echo "[+] Tool list cached ($category_count categories, $tool_count tools)"
        
        rm -f "$parser_script"
        return 0
    else
        echo "[!] Failed to fetch tools list"
        rm -f "$parser_script"
        return 1
    fi
}

get_category_tools() {
    local category="$1"
    
    if [[ ! -f "$TOOLS_CACHE" ]]; then
        fetch_blackarch_tools || return 1
    fi
    
    jq -r ".[\"$category\"][]?" "$TOOLS_CACHE" 2>/dev/null || echo ""
}

install_tool_with_fallback() {
    local tool="$1"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would install: $tool"
        return 0
    fi
    
    # Try BlackArch first
    if pacman -S --noconfirm --needed "$tool" >> "$LOG_DIR/kyGX.log" 2>&1; then
        ((BLACKARCH_INSTALL_COUNT++))
        log_message "BLACKARCH: Successfully installed $tool"
        return 0
    fi
    
    # Fallback to AUR with yay
    echo "[!] $tool failed via BlackArch, trying AUR fallback..."
    log_message "BLACKARCH: Failed to install $tool, attempting AUR fallback"
    
    if command -v yay &>/dev/null; then
        if sudo -u "$ORIGINAL_USER" yay -S --noconfirm --needed "$tool" >> "$LOG_DIR/kyGX.log" 2>&1; then
            ((AUR_FALLBACK_COUNT++))
            echo "[+] $tool installed via AUR"
            log_message "AUR: Successfully installed $tool via fallback"
            return 0
        fi
    fi
    
    # Both failed - record for retry option
    echo "$tool" >> "$FAILED_TOOLS_FILE"
    log_message "FAILED: $tool failed both BlackArch and AUR installation"
    return 1
}

install_tools_direct() {
    local tools=("$@")
    local total=${#tools[@]}
    local is_retry="${1:-false}"
    
    if [[ $total -eq 0 ]]; then
        echo "[!] No tools to install"
        return 0
    fi
    
    # Reset counters
    AUR_FALLBACK_COUNT=0
    BLACKARCH_INSTALL_COUNT=0
    
    echo "[*] Installing $total tools"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would install: ${tools[*]}"
        return 0
    fi
    
    local failed=0
    local installed=0
    
    for tool in "${tools[@]}"; do
        printf "\r[*] Installing: %-30s (%d/%d)" "$tool" "$((installed + failed + 1))" "$total"
        
        if install_tool_with_fallback "$tool"; then
            ((installed++))
        else
            ((failed++))
        fi
    done
    
    printf "\n"
    echo "[+] Results:"
    echo "    - BlackArch: $BLACKARCH_INSTALL_COUNT"
    echo "    - AUR Fallback: $AUR_FALLBACK_COUNT"
    echo "    - Failed: $failed"
    
    # Automated retry logic - only retry once, then skip
    if [[ $failed -gt 0 ]] && [[ "$is_retry" != "retry" ]]; then
        echo ""
        echo -e "${YELLOW}[!] $failed tools failed to install${RESET}"
        echo -e "${CYAN}[*] Auto-retrying failed tools (1 attempt)...${RESET}"
        sleep 1
        retry_failed_tools_auto
    elif [[ $failed -gt 0 ]] && [[ "$is_retry" == "retry" ]]; then
        echo ""
        echo -e "${YELLOW}[!] $failed tools still failed after retry${RESET}"
        echo -e "${DIM}[*] Skipping remaining failures and continuing...${RESET}"
        > "$FAILED_TOOLS_FILE"  # Clear failed tools file
        sleep 1
    fi
}

retry_failed_tools() {
    if [[ ! -f "$FAILED_TOOLS_FILE" ]] || [[ ! -s "$FAILED_TOOLS_FILE" ]]; then
        echo "[!] No failed tools to retry"
        return 0
    fi
    
    local failed_tools
    mapfile -t failed_tools < "$FAILED_TOOLS_FILE"
    
    # Remove duplicates
    local unique_tools=($(printf "%s\n" "${failed_tools[@]}" | sort -u))
    
    echo "[*] Retrying ${#unique_tools[@]} failed tools"
    
    # Clear the failed tools file
    > "$FAILED_TOOLS_FILE"
    
    # Retry installation
    install_tools_direct "${unique_tools[@]}"
}

retry_failed_tools_auto() {
    if [[ ! -f "$FAILED_TOOLS_FILE" ]] || [[ ! -s "$FAILED_TOOLS_FILE" ]]; then
        return 0
    fi
    
    local failed_tools
    mapfile -t failed_tools < "$FAILED_TOOLS_FILE"
    
    # Remove duplicates
    local unique_tools=($(printf "%s\n" "${failed_tools[@]}" | sort -u))
    
    if [[ ${#unique_tools[@]} -eq 0 ]]; then
        return 0
    fi
    
    echo "[*] Retrying ${#unique_tools[@]} failed tools (automatic)"
    
    # Clear the failed tools file
    > "$FAILED_TOOLS_FILE"
    
    # Retry installation with retry flag to prevent infinite loop
    local temp_tools=("${unique_tools[@]}")
    local total=${#temp_tools[@]}
    
    # Reset counters
    AUR_FALLBACK_COUNT=0
    BLACKARCH_INSTALL_COUNT=0
    
    local failed=0
    local installed=0
    
    for tool in "${temp_tools[@]}"; do
        printf "\r[*] Retry: %-30s (%d/%d)" "$tool" "$((installed + failed + 1))" "$total"
        
        if install_tool_with_fallback "$tool"; then
            ((installed++))
        else
            ((failed++))
        fi
    done
    
    printf "\n"
    echo "[+] Retry Results:"
    echo "    - BlackArch: $BLACKARCH_INSTALL_COUNT"
    echo "    - AUR Fallback: $AUR_FALLBACK_COUNT"
    echo "    - Failed: $failed"
    
    if [[ $failed -gt 0 ]]; then
        echo ""
        echo -e "${DIM}[*] $failed tools failed after retry, skipping...${RESET}"
        > "$FAILED_TOOLS_FILE"  # Clear failed tools file
    fi
}

install_from_aur_only() {
    check_and_install_yay
    
    echo ""
    echo -e "${CYAN}[*] Enter tool names to install from AUR (space-separated):${RESET}"
    read -r -a aur_tools
    
    if [[ ${#aur_tools[@]} -eq 0 ]]; then
        echo "[!] No tools specified"
        return 1
    fi
    
    echo "[*] Installing ${#aur_tools[@]} tools from AUR"
    
    local installed=0
    local failed=0
    
    for tool in "${aur_tools[@]}"; do
        echo "[*] Installing $tool from AUR"
        if sudo -u "$ORIGINAL_USER" yay -S --noconfirm --needed "$tool" >> "$LOG_DIR/kyGX.log" 2>&1; then
            echo "[+] $tool installed"
            ((installed++))
            log_message "AUR: Installed $tool"
        else
            echo "[!] Failed to install $tool"
            ((failed++))
            log_message "AUR: Failed to install $tool"
        fi
    done
    
    echo ""
    echo "[+] AUR Installation Results: Installed: $installed | Failed: $failed"
}

search_aur_tools() {
    check_and_install_yay
    
    echo ""
    echo -e "${CYAN}[*] Enter search term (e.g., 'exploit', 'scanner', 'recon'):${RESET}"
    read -r search_term
    
    if [[ -z "$search_term" ]]; then
        echo "[!] No search term provided"
        return 1
    fi
    
    echo "[*] Searching AUR for: $search_term"
    echo ""
    
    sudo -u "$ORIGINAL_USER" yay -Ss "$search_term" | head -50
    
    echo ""
    echo -e "${YELLOW}[?] Install any of these? (y/n):${RESET} "
    read -r install_response
    
    if [[ "$install_response" =~ ^[Yy]$ ]]; then
        install_from_aur_only
    fi
}

install_slim_tools() {
    echo "[*] Installing Slim toolkit (Kali-like/Popular essentials)"
    
    local all_tools=()
    for category in "${!SLIM_TOOLS[@]}"; do
        read -ra tools <<< "${SLIM_TOOLS[$category]}"
        all_tools+=("${tools[@]}")
    done
    
    install_tools_direct "${all_tools[@]}"
}

install_category_tools() {
    local category="$1"
    
    echo "[*] Fetching tools for category: $category"
    
    local tools
    mapfile -t tools < <(get_category_tools "$category")
    
    if [[ ${#tools[@]} -eq 0 ]]; then
        echo "[!] No tools found for category: $category"
        return 1
    fi
    
    echo "[*] Found ${#tools[@]} tools in $category"
    install_tools_direct "${tools[@]}"
}

install_all_blackarch_tools() {
    echo "[*] Installing ALL BlackArch tools by category"
    
    if [[ ! -f "$TOOLS_CACHE" ]]; then
        fetch_blackarch_tools || error_exit "Failed to fetch tool list"
    fi
    
    local categories
    mapfile -t categories < <(jq -r 'keys[]' "$TOOLS_CACHE")
    
    echo "[*] Found ${#categories[@]} categories"
    
    for category in "${categories[@]}"; do
        echo ""
        echo "[*] Category: $category"
        install_category_tools "$category"
    done
    
    echo ""
    echo "[+] All categories processed"
}

update_system() {
    echo "[*] Updating system (pacman + AUR)"
    
    echo "[*] Updating pacman packages"
    pacman -Syu --noconfirm >> "$LOG_DIR/kyGX.log" 2>&1
    
    if command -v yay &>/dev/null; then
        echo "[*] Updating AUR packages"
        sudo -u "$ORIGINAL_USER" yay -Syu --noconfirm >> "$LOG_DIR/kyGX.log" 2>&1
    fi
    
    echo "[+] System updated"
}

cleanup_kyGX() {
    echo "[*] Cleaning up kyGX"
    
    restore_default_pacman_conf
    
    if [[ -f "$TOOLS_CACHE" ]]; then
        rm -f "$TOOLS_CACHE"
        echo "[+] Removed BlackArch tool cache"
    fi
    
    if [[ -f "$AUR_CACHE" ]]; then
        rm -f "$AUR_CACHE"
        echo "[+] Removed AUR tool cache"
    fi
    
    if [[ -f "$FAILED_TOOLS_FILE" ]]; then
        rm -f "$FAILED_TOOLS_FILE"
        echo "[+] Removed failed tools list"
    fi
    
    if [[ -f /etc/pacman.d/blackarch-mirrorlist ]]; then
        rm -f /etc/pacman.d/blackarch-mirrorlist
        echo "[+] Removed BlackArch mirrorlist"
    fi
    
    pacman -Sy >> "$LOG_DIR/kyGX.log" 2>&1
    
    echo "[+] Cleanup complete"
}

print_banner() {
    cat << 'EOF'

░  ░░░░  ░░  ░░░░  ░░░      ░░░  ░░░░  ░
▒  ▒▒▒  ▒▒▒▒  ▒▒  ▒▒▒  ▒▒▒▒▒▒▒▒▒  ▒▒  ▒▒
▓     ▓▓▓▓▓▓▓    ▓▓▓▓  ▓▓▓   ▓▓▓▓    ▓▓▓
█  ███  ██████  █████  ████  ███  ██  ██
█  ████  █████  ██████      ███  ████  █
                                        
Arch Security Arsenal Manager v0.1 Stable
 By 0xb0rn3 | IG: theehiv3 | X: 0xbv1

EOF
}

display_system_info() {
    echo "[*] System Information:"
    echo "  - OS: $(grep '^NAME=' /etc/os-release | cut -d= -f2 | tr -d '"')"
    echo "  - Kernel: $(uname -r)"
    echo "  - Architecture: $(uname -m)"
    echo "  - User: $ORIGINAL_USER"
    
    if command -v yay &>/dev/null; then
        echo "  - AUR Helper: yay (installed)"
    else
        echo "  - AUR Helper: Not installed"
    fi
    
    echo ""
}

show_main_menu() {
    echo ""
    echo "Tool Categories:"
    echo ""
    echo "  1) Information Gathering"
    echo "  2) Vulnerability Analysis"
    echo "  3) Web Application Analysis"
    echo "  4) Password Attacks"
    echo "  5) Wireless Attacks"
    echo "  6) Exploitation Tools"
    echo "  7) Digital Forensics"
    echo "  8) Sniffing & Spoofing"
    echo "  9) Post Exploitation"
    echo " 10) Social Engineering"
    echo ""
    echo "Special Options:"
    echo ""
    echo "  s) Install Slim toolkit (Kali-like/Popular essentials)"
    echo "  a) Install ALL BlackArch tools (by category)"
    echo "  u) Update system (pacman + AUR)"
    echo "  r) Refresh tool list"
    echo ""
    echo "AUR Options:"
    echo ""
    echo "  y) Install tools from AUR only"
    echo "  z) Search AUR for security tools"
    echo ""
    echo "Maintenance:"
    echo ""
    echo "  f) Retry failed tool installations"
    echo "  c) Cleanup (restore pacman.conf, remove cache)"
    echo "  q) Quit"
    echo ""
}

handle_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        1) install_category_tools "recon" ;;
        2) install_category_tools "scanner" ;;
        3) install_category_tools "webapp" ;;
        4) install_category_tools "cracker" ;;
        5) install_category_tools "wireless" ;;
        6) install_category_tools "exploitation" ;;
        7) install_category_tools "forensic" ;;
        8) install_category_tools "sniffer" ;;
        9) install_category_tools "backdoor" ;;
        10) install_category_tools "social" ;;
        s|S) install_slim_tools ;;
        a|A) install_all_blackarch_tools ;;
        u|U) update_system ;;
        r|R) fetch_blackarch_tools ;;
        y|Y) install_from_aur_only ;;
        z|Z) search_aur_tools ;;
        f|F) retry_failed_tools ;;
        c|C) cleanup_kyGX ;;
        q|Q) 
            echo "[*] Exiting kyGX"
            exit 0
            ;;
        *) return 1 ;;
    esac
    
    return 0
}

show_help() {
    cat << 'HELP'
kyGX - Arch Security Arsenal Manager

USAGE:
    sudo ./kyGX [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Preview installations without installing
    -f, --force            Force installation
    --setup                Setup BlackArch repository + yay + default configs
    --update               Update system (pacman + AUR)
    --slim                 Install slim toolkit
    --aur                  AUR-only installation mode
    --cleanup              Cleanup and restore default config

CATEGORIES:
    1. Information Gathering
    2. Vulnerability Analysis
    3. Web Application Analysis
    4. Password Attacks
    5. Wireless Attacks
    6. Exploitation Tools
    7. Digital Forensics
    8. Sniffing & Spoofing
    9. Post Exploitation
    10. Social Engineering

FEATURES:
    - Automatic AUR fallback for failed installations
    - Auto-retry failed tools once, then skip (fully automated)
    - Auto-installs: blackarch-menus, blackarch-config-gtk, blackarch-config-zsh
    - Interactive AUR search and installation
    - Dual-source updates (pacman + AUR)
    - Non-interactive installation flow

EXAMPLES:
    sudo ./kyGX                    # Interactive mode
    sudo ./kyGX --setup            # Complete setup with yay and configs
    sudo ./kyGX --slim             # Install Kali-like toolkit
    sudo ./kyGX --aur              # AUR-only installation
    sudo ./kyGX --cleanup          # Restore default config

SUPPORT:
    Repository: https://github.com/0xb0rn3/kyGX
    Author: 0xb0rn3
    Email: q4n0@proton.me
HELP
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --setup)
                init_dirs
                validate_system
                install_dependencies
                check_and_install_yay
                setup_blackarch_repository
                exit 0
                ;;
            --update)
                update_system
                exit 0
                ;;
            --slim)
                init_dirs
                validate_system
                install_dependencies
                check_and_install_yay
                setup_blackarch_repository
                install_slim_tools
                exit 0
                ;;
            --aur)
                init_dirs
                check_and_install_yay
                install_from_aur_only
                exit 0
                ;;
            --cleanup)
                cleanup_kyGX
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

main() {
    parse_arguments "$@"
    
    init_dirs
    
    print_banner
    display_system_info
    
    validate_system
    install_dependencies
    check_and_install_yay
    setup_blackarch_repository
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[!] DRY RUN MODE - No packages will be installed"
        echo ""
    fi
    
    while true; do
        show_main_menu
        read -p "Select option: " -r choice
        echo
        
        if ! handle_menu_selection "$choice"; then
            echo "[!] Invalid selection"
            sleep 1
        fi
        
        echo
        read -p "Press Enter to continue..." -r
    done
}

trap 'echo ""; echo "[*] Interrupted"; exit 130' INT TERM

check_root
main "$@"
