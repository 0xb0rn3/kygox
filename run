#!/usr/bin/env bash
# KYGOX - Because your pathetic security testing setup needs actual tools
# Version 0.1.8 - When script kiddies graduate to something less embarrassing
# Author: 0xbv1 | 0xb0rn3 
# Contact: IG: theehiv3 | X: 0xbv1 | Threads: theehiv3 | Email: q4n0@proton.me
# License: Do whatever the hell you want, but don't blame me when it breaks

# Get the actual user before they sudo'd like an amateur
ORIGINAL_USER=$SUDO_USER
SUDO_ASKPASS_HELPER="/tmp/.kygox_askpass_$$"

# Terminal colors - because monochrome is for cowards
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
DARK='\033[1;30m'
BRED='\033[1;31m'
BGREEN='\033[1;32m'
BYELLOW='\033[1;33m'
BBLUE='\033[1;34m'
BPURPLE='\033[1;35m'
BCYAN='\033[1;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# Status indicators - because emojis are apparently professional now
OK="[${BGREEN}✓${RESET}]"
FAIL="[${BRED}✗${RESET}]"
INFO="[${BBLUE}*${RESET}]"
WARN="[${BYELLOW}!${RESET}]"
PROC="[${BPURPLE}↻${RESET}]"

# Directories - organized chaos is still chaos
LOG_DIR="kygox_logs"
MAIN_LOG="$LOG_DIR/installation.log"
BACKUP_DIR="$LOG_DIR/backups"
PACKAGE_LOG_DIR="$LOG_DIR/package_logs"

# Version info - semantic versioning is for people who plan ahead
VERSION="0.1.8"
VERSION_NAME="Stop Asking For Passwords Edition"

# Tool mappings - because package names make no damn sense
declare -A tool_packages=(
    ["nmap"]="nmap"
    ["masscan"]="masscan"
    ["zmap"]="zmap"
    ["rustscan"]="rustscan"
    ["wireshark"]="wireshark-qt"
    ["tshark"]="wireshark-cli"
    ["tcpdump"]="tcpdump"
    ["aircrack-ng"]="aircrack-ng"
    ["bettercap"]="bettercap"
    ["kismet"]="kismet"
    ["wifite"]="wifite"
    ["reaver"]="reaver"
    ["sqlmap"]="sqlmap"
    ["nikto"]="nikto"
    ["gobuster"]="gobuster"
    ["dirb"]="dirb"
    ["wfuzz"]="wfuzz"
    ["ffuf"]="ffuf"
    ["whatweb"]="whatweb"
    ["wpscan"]="wpscan"
    ["nuclei"]="nuclei"
    ["httpx"]="httpx"
    ["subfinder"]="subfinder"
    ["john"]="john"
    ["hashcat"]="hashcat"
    ["hydra"]="hydra"
    ["medusa"]="medusa"
    ["msfconsole"]="metasploit"
    ["msfvenom"]="metasploit"
    ["searchsploit"]="exploitdb"
    ["impacket-smbserver"]="impacket"
    ["theharvester"]="theharvester"
    ["recon-ng"]="recon-ng"
    ["amass"]="amass"
    ["sherlock"]="sherlock-project"
    ["phoneinfoga"]="phoneinfoga"
    ["volatility"]="volatility3"
    ["autopsy"]="autopsy"
    ["binwalk"]="binwalk"
    ["exiftool"]="perl-image-exiftool"
    ["ghidra"]="ghidra"
    ["radare2"]="radare2"
    ["rizin"]="rizin"
    ["gdb"]="gdb"
    ["ltrace"]="ltrace"
    ["strace"]="strace"
    ["tor"]="tor"
    ["proxychains"]="proxychains-ng"
    ["lynis"]="lynis"
    ["chkrootkit"]="chkrootkit"
    ["rkhunter"]="rkhunter"
    ["apktool"]="android-apktool"
    ["jadx"]="jadx"
    ["frida"]="frida-tools"
    ["docker"]="docker"
    ["python3"]="python"
    ["ruby"]="ruby"
    ["go"]="go"
    ["rust"]="rust"
    ["gcc"]="gcc"
    ["git"]="git"
    ["curl"]="curl"
    ["wget"]="wget"
)

display_banner() {
    clear
    cat << 'EOF'
██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗
██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝
█████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝ 
██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗ 
██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗
╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    PENETRATION TESTING TOOLKIT INSTALLER
     Because clicking buttons is beneath you
EOF
    echo -e "          ${BOLD}Version $VERSION | $VERSION_NAME${RESET}"
    echo -e "   ${DIM}0xbv1 | IG: theehiv3 | X: 0xbv1 | q4n0@proton.me${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
}

show_usage() {
    echo -e "${BOLD}KygoX v$VERSION - Stop wasting time with manual installs${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${BOLD}Usage:${RESET}"
    echo -e "  sudo $0 [OPTIONS]"
    echo
    echo -e "${BOLD}Options that actually matter:${RESET}"
    echo -e "  -a, --all                Deploy everything (hope you have bandwidth)"
    echo -e "  -g, --group GROUP        Install specific tool category"
    echo -e "  -p, --packages FILE      Use your own damn package list"
    echo -e "  -q, --quiet              Shut up and install"
    echo -e "  --skip-aur               Skip AUR (for the impatient)"
    echo -e "  --no-sudo-cache          Disable sudo caching (for the paranoid)"
    echo
    echo -e "${BOLD}Options for people who read documentation:${RESET}"
    echo -e "  -h, --help               This useless text"
    echo -e "  -v, --version            Version info nobody cares about"
    echo
    echo -e "${BOLD}Examples for the copy-paste warriors:${RESET}"
    echo -e "  sudo $0 -a                          # YOLO mode"
    echo -e "  sudo $0 -g exploitation             # Script kiddie starter pack"
    echo -e "  sudo $0 -g wireless                 # WiFi \"hacker\" essentials"
    echo -e "  sudo $0 -p my_tools.txt             # Your curated bloatware"
    echo
    echo -e "${BOLD}Tool categories (pick your poison):${RESET}"
    echo -e "  exploitation, wireless, webapp, scanner, forensic, crypto"
    echo -e "  Run 'pacman -Sg | grep blackarch' for the full list"
    echo
    echo -e "${DIM}Author: 0xbv1 | Contact: q4n0@proton.me${RESET}"
}

show_version() {
    echo -e "${BOLD}KygoX - Penetration Testing Toolkit Installer${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${BOLD}Version:${RESET}     $VERSION ($VERSION_NAME)"
    echo -e "${BOLD}Author:${RESET}      0xbv1 | 0xb0rn3"
    echo -e "${BOLD}Contact:${RESET}     IG: theehiv3 | X: 0xbv1 | Threads: theehiv3"
    echo -e "${BOLD}Email:${RESET}       q4n0@proton.me"
    echo -e "${BOLD}Repository:${RESET}  github.com/0xb0rn3/kygox"
    echo
    echo -e "${BOLD}What this thing actually does:${RESET}"
    echo -e "  • Installs BlackArch repository (because you're too lazy)"
    echo -e "  • Handles package conflicts (by breaking things properly)"
    echo -e "  • Manages AUR packages (without asking for passwords 50 times)"
    echo -e "  • Cleans up after itself (unlike you)"
    echo -e "  • Supports ${#tool_packages[@]} tool mappings (that nobody asked for)"
    echo
    echo -e "${DIM}If it breaks, you get to keep both pieces.${RESET}"
}

log_message() {
    local level="$1"
    local message="$2"
    local component="${3:-main}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR" "$PACKAGE_LOG_DIR"
    echo "[$timestamp] [$level] [$component] $message" >> "$MAIN_LOG"
    
    if [ "$QUIET_MODE" != "true" ]; then
        case "$level" in
            "OK") echo -e "$OK $message" ;;
            "FAIL") echo -e "$FAIL $message" ;;
            "INFO") echo -e "$INFO $message" ;;
            "WARN") echo -e "$WARN $message" ;;
            "PROC") echo -e "$PROC $message" ;;
            *) echo -e "[?] $message" ;;
        esac
    fi
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${FAIL} Nice try, but this needs root. Ever heard of sudo?"
        echo -e "${INFO} Run: ${BOLD}sudo $0 [options]${RESET}"
        exit 1
    fi
    
    if [ -z "$ORIGINAL_USER" ]; then
        echo -e "${FAIL} Can't figure out who you actually are. This is awkward."
        echo -e "${INFO} Make sure you're using sudo, not running as root directly"
        exit 1
    fi
    
    if ! id "$ORIGINAL_USER" &>/dev/null; then
        log_message "FAIL" "User '$ORIGINAL_USER' doesn't exist. Quantum user detected?" "init"
        exit 1
    fi
    
    log_message "OK" "Running as root with actual user: $ORIGINAL_USER" "init"
}

# The magic sauce - sudo password caching that actually works
setup_sudo_cache() {
    if [ "$NO_SUDO_CACHE" == "true" ]; then
        log_message "INFO" "Sudo caching disabled by paranoid user" "sudo"
        return 0
    fi
    
    log_message "PROC" "Setting up intelligent sudo caching..." "sudo"
    
    # Create askpass helper that returns empty (for sudoloop in yay)
    cat > "$SUDO_ASKPASS_HELPER" << 'EOHELPER'
#!/bin/bash
echo ""
EOHELPER
    chmod +x "$SUDO_ASKPASS_HELPER"
    
    # Prime sudo cache
    echo -e "${INFO} One-time authentication required for the entire installation"
    sudo -v
    
    # Keep sudo alive in background
    (
        while true; do
            sudo -n true 2>/dev/null || break
            sleep 50
        done
    ) &
    SUDO_KEEPER_PID=$!
    
    # Export for yay to use
    export SUDO_ASKPASS="$SUDO_ASKPASS_HELPER"
    
    log_message "OK" "Sudo cache configured - no more password prompts" "sudo"
}

cleanup_sudo_cache() {
    if [ -n "$SUDO_KEEPER_PID" ]; then
        kill "$SUDO_KEEPER_PID" 2>/dev/null
    fi
    rm -f "$SUDO_ASKPASS_HELPER" 2>/dev/null
    unset SUDO_ASKPASS
    log_message "INFO" "Sudo cache cleaned up" "sudo"
}

add_blackarch_repo() {
    log_message "PROC" "Adding BlackArch repository..." "setup"
    
    if grep -q "^\[blackarch\]" /etc/pacman.conf; then
        log_message "OK" "BlackArch already configured - skipping" "setup"
        return 0
    fi
    
    log_message "INFO" "Downloading BlackArch bootstrap script..." "setup"
    
    if ! curl -s -o strap.sh https://blackarch.org/strap.sh; then
        log_message "FAIL" "Failed to download BlackArch script. Check your internet." "setup"
        return 1
    fi
    
    if [ ! -f strap.sh ] || [ ! -s strap.sh ]; then
        log_message "FAIL" "BlackArch script is empty or corrupted" "setup"
        return 1
    fi
    
    chmod +x strap.sh
    
    if ./strap.sh &>/dev/null; then
        rm -f strap.sh
        log_message "OK" "BlackArch repository added successfully" "setup"
        return 0
    else
        rm -f strap.sh
        log_message "FAIL" "BlackArch installation failed" "setup"
        return 1
    fi
}

fix_pacman_keys() {
    log_message "PROC" "Fixing pacman keyring (this takes forever)..." "setup"
    
    # Kill any existing gpg-agent processes that might interfere
    killall gpg-agent 2>/dev/null
    
    # Remove old gnupg dir if corrupted
    rm -rf /etc/pacman.d/gnupg.old 2>/dev/null
    mv /etc/pacman.d/gnupg /etc/pacman.d/gnupg.old 2>/dev/null
    
    log_message "INFO" "Initializing new keyring..." "setup"
    pacman-key --init &>/dev/null
    
    log_message "INFO" "Populating keyring with Arch and BlackArch keys..." "setup"
    pacman-key --populate archlinux &>/dev/null
    pacman-key --populate blackarch &>/dev/null 2>&1
    
    log_message "INFO" "Refreshing keys (go get coffee)..." "setup"
    pacman-key --refresh-keys --keyserver keyserver.ubuntu.com &>/dev/null 2>&1 || true
    
    log_message "OK" "Keyring should be functional now" "setup"
}

update_system() {
    log_message "PROC" "Updating system packages..." "setup"
    
    local attempts=3
    for ((i=1; i<=attempts; i++)); do
        log_message "INFO" "Update attempt $i of $attempts..." "setup"
        
        if pacman -Syu --noconfirm &>/dev/null; then
            log_message "OK" "System updated successfully" "setup"
            return 0
        else
            log_message "WARN" "Update attempt $i failed" "setup"
            [ $i -lt $attempts ] && sleep 2
        fi
    done
    
    log_message "FAIL" "System update failed after $attempts attempts" "setup"
    return 1
}

install_yay() {
    if command -v yay &>/dev/null; then
        log_message "OK" "YAY already installed" "setup"
        return 0
    fi
    
    log_message "PROC" "Installing YAY AUR helper..." "setup"
    
    local deps=("git" "base-devel" "go")
    log_message "INFO" "Installing YAY dependencies: ${deps[*]}" "setup"
    
    if ! pacman -S --noconfirm --needed "${deps[@]}" &>/dev/null; then
        log_message "FAIL" "Failed to install YAY dependencies" "setup"
        return 1
    fi
    
    local build_dir="/tmp/yay-build-$$"
    mkdir -p "$build_dir"
    cd "$build_dir"
    
    log_message "INFO" "Cloning YAY repository..." "setup"
    if ! sudo -u "$ORIGINAL_USER" git clone https://aur.archlinux.org/yay.git &>/dev/null; then
        log_message "FAIL" "Failed to clone YAY repository" "setup"
        rm -rf "$build_dir"
        return 1
    fi
    
    cd yay
    
    log_message "INFO" "Building YAY..." "setup"
    if sudo -u "$ORIGINAL_USER" makepkg -si --noconfirm &>/dev/null; then
        log_message "OK" "YAY installed successfully" "setup"
        cd /
        rm -rf "$build_dir"
        return 0
    else
        log_message "FAIL" "YAY build failed" "setup"
        cd /
        rm -rf "$build_dir"
        return 1
    fi
}

install_base_dependencies() {
    log_message "PROC" "Installing base dependencies..." "setup"
    
    local core_deps=(
        "base-devel" "cmake" "make" "gcc" "pkg-config"
        "git" "curl" "wget" "unzip" "tar" "gzip"
    )
    
    local lib_deps=(
        "openssl" "libpcap" "libnet" "libnetfilter_queue"
        "sqlite" "zlib" "pcre2"
    )
    
    local wireless_deps=(
        "iw" "wireless_tools" "net-tools"
    )
    
    local dev_deps=(
        "python" "python-pip" "python-setuptools"
        "ruby" "perl" "nodejs" "npm"
    )
    
    install_dep_group() {
        local group_name="$1"
        shift
        local deps=("$@")
        
        log_message "INFO" "Installing $group_name dependencies..." "setup"
        
        if pacman -S --noconfirm --needed "${deps[@]}" &>/dev/null; then
            log_message "OK" "$group_name dependencies installed"
            return 0
        else
            log_message "WARN" "Some $group_name dependencies failed"
            return 1
        fi
    }
    
    install_dep_group "core" "${core_deps[@]}"
    install_dep_group "library" "${lib_deps[@]}"
    install_dep_group "wireless" "${wireless_deps[@]}"
    install_dep_group "development" "${dev_deps[@]}"
    
    log_message "OK" "Base dependencies installation completed" "setup"
}

install_aur_packages() {
    if [ "$SKIP_AUR" == "true" ]; then
        log_message "INFO" "Skipping AUR packages as requested" "aur"
        return 0
    fi
    
    log_message "PROC" "Installing AUR packages..." "aur"
    
    # Critical AUR packages
    local aur_packages=(
        "nuclei-bin"
        "httpx-bin"
        "subfinder-bin"
        "katana-bin"
        "gau-bin"
        "anew-bin"
        "notify-bin"
        "interactsh-bin"
        "proxify-bin"
        "dnsx-bin"
        "naabu-bin"
        "mapcidr-bin"
        "massdns-bin"
        "amass-bin"
        "assetfinder-bin"
        "findomain-bin"
        "waybackurls-bin"
        "gf-bin"
        "qsreplace-bin"
        "hakrawler-bin"
        "gospider-bin"
        "dalfox-bin"
        "kxss-bin"
        "paramspider"
        "arjun"
        "corsy"
        "secretfinder"
        "truffelhog"
        "gitleaks-bin"
        "shodan"
        "censys"
    )
    
    local installed=0
    local failed=0
    local total=${#aur_packages[@]}
    
    log_message "INFO" "Processing $total AUR packages..." "aur"
    
    for package in "${aur_packages[@]}"; do
        # Check if already installed
        if pacman -Q "${package%-bin}" &>/dev/null || pacman -Q "$package" &>/dev/null; then
            log_message "INFO" "AUR package $package already installed" "aur"
            installed=$((installed + 1))
            continue
        fi
        
        log_message "PROC" "Installing AUR package: $package" "aur"
        
        # Use yay with sudoloop and askpass to avoid password prompts
        if sudo -u "$ORIGINAL_USER" SUDO_ASKPASS="$SUDO_ASKPASS_HELPER" \
           yay -S --noconfirm --needed --sudoloop --cleanafter "$package" &>/dev/null; then
            log_message "OK" "AUR package $package installed" "aur"
            installed=$((installed + 1))
        else
            log_message "WARN" "AUR package $package failed" "aur"
            failed=$((failed + 1))
            echo "$package" >> "$LOG_DIR/failed_aur.txt"
        fi
    done
    
    log_message "OK" "AUR installation: $installed successful, $failed failed" "aur"
}

get_blackarch_packages() {
    log_message "PROC" "Preparing package list..." "packages"
    
    case "$INSTALL_MODE" in
        "all")
            log_message "INFO" "Fetching all BlackArch packages (this is insane)..." "packages"
            if pacman -Slq blackarch > blackarch_packages.txt 2>/dev/null; then
                local count=$(wc -l < blackarch_packages.txt)
                log_message "OK" "Found $count packages to install" "packages"
            else
                log_message "FAIL" "Failed to get BlackArch package list" "packages"
                return 1
            fi
            ;;
            
        "group")
            log_message "INFO" "Fetching packages for group: $GROUP_NAME" "packages"
            
            if ! pacman -Sg | grep -q "blackarch-$GROUP_NAME"; then
                log_message "FAIL" "Group 'blackarch-$GROUP_NAME' doesn't exist" "packages"
                echo -e "${WARN} Available groups:"
                pacman -Sg | grep blackarch | sort | column
                return 1
            fi
            
            if pacman -Sgq "blackarch-$GROUP_NAME" > blackarch_packages.txt 2>/dev/null; then
                local count=$(wc -l < blackarch_packages.txt)
                log_message "OK" "Found $count packages in group $GROUP_NAME" "packages"
            else
                log_message "FAIL" "Failed to get packages for group $GROUP_NAME" "packages"
                return 1
            fi
            ;;
            
        "custom")
            log_message "INFO" "Loading custom package list: $PACKAGE_LIST" "packages"
            
            if [ ! -f "$PACKAGE_LIST" ]; then
                log_message "FAIL" "Package list file not found: $PACKAGE_LIST" "packages"
                return 1
            fi
            
            grep -v "^#" "$PACKAGE_LIST" | grep -v "^$" > blackarch_packages.txt
            local count=$(wc -l < blackarch_packages.txt)
            log_message "OK" "Loaded $count packages from custom list" "packages"
            ;;
    esac
    
    # Add essential tools if missing
    local essentials=("metasploit" "nmap" "wireshark-qt" "burpsuite")
    for tool in "${essentials[@]}"; do
        if ! grep -q "^$tool$" blackarch_packages.txt 2>/dev/null; then
            echo "$tool" >> blackarch_packages.txt
        fi
    done
    
    return 0
}

handle_conflicts() {
    local package="$1"
    local error="$2"
    
    log_message "PROC" "Resolving conflicts for $package..." "conflict"
    
    # Try force overwrite first
    if pacman -S --noconfirm --overwrite='*' "$package" &>/dev/null; then
        log_message "OK" "Resolved conflicts for $package with overwrite" "conflict"
        return 0
    fi
    
    # Extract conflicting packages
    local conflicts=$(echo "$error" | grep -oE "conflicts with [^ ]+" | cut -d' ' -f3)
    
    for conflict in $conflicts; do
        log_message "INFO" "Removing conflicting package: $conflict" "conflict"
        pacman -R --noconfirm "$conflict" &>/dev/null
    done
    
    # Try again
    if pacman -S --noconfirm --needed "$package" &>/dev/null; then
        log_message "OK" "Resolved conflicts for $package" "conflict"
        return 0
    fi
    
    return 1
}

install_packages() {
    local total=$(wc -l < blackarch_packages.txt)
    local current=0
    local success=0
    local failed=0
    local skipped=0
    
    log_message "PROC" "Installing $total packages..." "install"
    
    > "$LOG_DIR/failed_packages.txt"
    > "$LOG_DIR/successful_packages.txt"
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^# ]] && continue
        
        current=$((current + 1))
        
        if [ "$QUIET_MODE" != "true" ]; then
            echo -ne "\r${PROC} Installing package $current/$total: $package"
        fi
        
        # Check if already installed
        if pacman -Q "$package" &>/dev/null; then
            skipped=$((skipped + 1))
            continue
        fi
        
        # Try to install
        local output=$(pacman -S --noconfirm --needed "$package" 2>&1)
        local result=$?
        
        if [ $result -eq 0 ]; then
            success=$((success + 1))
            echo "$package" >> "$LOG_DIR/successful_packages.txt"
        else
            # Handle conflicts
            if echo "$output" | grep -q "conflict"; then
                if handle_conflicts "$package" "$output"; then
                    success=$((success + 1))
                    echo "$package" >> "$LOG_DIR/successful_packages.txt"
                else
                    failed=$((failed + 1))
                    echo "$package" >> "$LOG_DIR/failed_packages.txt"
                fi
            else
                failed=$((failed + 1))
                echo "$package" >> "$LOG_DIR/failed_packages.txt"
            fi
        fi
        
    done < blackarch_packages.txt
    
    if [ "$QUIET_MODE" != "true" ]; then
        echo # New line after progress
    fi
    
    log_message "OK" "Installation complete: $success installed, $failed failed, $skipped skipped" "install"
}

retry_failed_with_yay() {
    local failed_file="$LOG_DIR/failed_packages.txt"
    
    if [ ! -s "$failed_file" ]; then
        return 0
    fi
    
    local count=$(wc -l < "$failed_file")
    log_message "PROC" "Retrying $count failed packages with YAY..." "retry"
    
    local recovered=0
    
    while IFS= read -r package; do
        [ -z "$package" ] && continue
        
        log_message "INFO" "Retrying $package with YAY..." "retry"
        
        if sudo -u "$ORIGINAL_USER" SUDO_ASKPASS="$SUDO_ASKPASS_HELPER" \
           yay -S --noconfirm --needed --sudoloop "$package" &>/dev/null; then
            log_message "OK" "Recovered $package with YAY" "retry"
            recovered=$((recovered + 1))
        fi
    done < "$failed_file"
    
    log_message "OK" "Recovered $recovered packages with YAY" "retry"
}

cleanup() {
    log_message "PROC" "Cleaning up..." "cleanup"
    
    # Clean package cache
    log_message "INFO" "Cleaning package cache..." "cleanup"
    pacman -Sc --noconfirm &>/dev/null
    
    # Clean yay cache
    if command -v yay &>/dev/null; then
        sudo -u "$ORIGINAL_USER" yay -Sc --noconfirm &>/dev/null
    fi
    
    # Remove temp files
    rm -f blackarch_packages.txt
    rm -rf /tmp/yay-build-*
    rm -rf /tmp/kygox-*
    
    log_message "OK" "Cleanup complete" "cleanup"
}

handle_interrupt() {
    echo -e "\n\n${FAIL} Installation interrupted by user"
    log_message "WARN" "Installation interrupted (SIGINT/SIGTERM)" "main"
    
    cleanup_sudo_cache
    
    echo -e "${INFO} Partial installation may have completed. Check logs in $LOG_DIR"
    exit 130
}

parse_arguments() {
    INSTALL_MODE=""
    GROUP_NAME=""
    PACKAGE_LIST=""
    QUIET_MODE="false"
    SKIP_AUR="false"
    NO_SUDO_CACHE="false"

    if [ $# -eq 0 ]; then
        show_usage
        exit 0
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--all)
                INSTALL_MODE="all"
                shift
                ;;
            -g|--group)
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    INSTALL_MODE="group"
                    GROUP_NAME="$2"
                    shift 2
                else
                    echo -e "${FAIL} --group needs an argument, genius"
                    show_usage
                    exit 1
                fi
                ;;
            -p|--packages)
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    INSTALL_MODE="custom"
                    PACKAGE_LIST="$2"
                    shift 2
                else
                    echo -e "${FAIL} --packages needs a file path"
                    show_usage
                    exit 1
                fi
                ;;
            -q|--quiet)
                QUIET_MODE="true"
                shift
                ;;
            --skip-aur)
                SKIP_AUR="true"
                shift
                ;;
            --no-sudo-cache)
                NO_SUDO_CACHE="true"
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            *)
                echo -e "${FAIL} Unknown option: $1"
                echo -e "${INFO} Try --help if you're lost"
                exit 1
                ;;
        esac
    done

    if [ -z "$INSTALL_MODE" ]; then
        echo -e "${FAIL} No installation mode selected"
        echo -e "${INFO} Use -a, -g GROUP, or -p FILE"
        show_usage
        exit 1
    fi
}

show_summary() {
    local success_count=0
    local failed_count=0
    local skipped_count=0
    
    [ -f "$LOG_DIR/successful_packages.txt" ] && success_count=$(wc -l < "$LOG_DIR/successful_packages.txt")
    [ -f "$LOG_DIR/failed_packages.txt" ] && failed_count=$(wc -l < "$LOG_DIR/failed_packages.txt")
    
    if [ "$QUIET_MODE" != "true" ]; then
        echo
        echo -e "${BOLD}════════════════════════════════════════════════════${RESET}"
        echo -e "${BOLD}                 INSTALLATION COMPLETE                ${RESET}"
        echo -e "${BOLD}════════════════════════════════════════════════════${RESET}"
        echo
        echo -e "${BOLD}Statistics (because metrics matter):${RESET}"
        echo -e "  ${BGREEN}Successful:${RESET}  $success_count packages"
        echo -e "  ${BRED}Failed:${RESET}      $failed_count packages"
        echo
        
        if [ "$failed_count" -gt 0 ]; then
            echo -e "${WARN} Failed packages logged in: $LOG_DIR/failed_packages.txt"
            echo -e "${INFO} You can manually install them or try again"
        fi
        
        echo -e "${INFO} Full logs available in: $LOG_DIR"
        echo
        echo -e "${DIM}KygoX v$VERSION | 0xbv1 | q4n0@proton.me${RESET}"
        echo -e "${DIM}If it worked, you're welcome. If it didn't, check the logs.${RESET}"
        echo
    fi
}

verify_installation() {
    log_message "PROC" "Verifying installation..." "verify"
    
    local tools_to_check=(
        "nmap" "wireshark" "aircrack-ng" "metasploit"
        "sqlmap" "john" "hashcat" "hydra"
        "gobuster" "nikto" "burpsuite"
    )
    
    local working=0
    local missing=0
    
    for tool in "${tools_to_check[@]}"; do
        # Check both tool name and package mapping
        local package="${tool_packages[$tool]:-$tool}"
        
        if command -v "$tool" &>/dev/null || pacman -Q "$package" &>/dev/null 2>&1; then
            working=$((working + 1))
            log_message "OK" "Tool verified: $tool" "verify"
        else
            missing=$((missing + 1))
            log_message "WARN" "Tool missing: $tool" "verify"
        fi
    done
    
    log_message "OK" "Verification complete: $working working, $missing missing" "verify"
    
    if [ "$missing" -gt 0 ]; then
        echo -e "${WARN} Some core tools are missing. Check the logs for details."
    fi
}

# Main execution flow - where the magic happens
main() {
    # Set up signal handlers
    trap handle_interrupt SIGINT SIGTERM
    trap cleanup_sudo_cache EXIT
    
    # Show banner
    display_banner
    
    # Parse command line arguments
    parse_arguments "$@"
    
    # Redirect output if quiet mode
    if [ "$QUIET_MODE" == "true" ]; then
        exec 1>>"$MAIN_LOG" 2>&1
    fi
    
    # Check root privileges
    check_root
    
    log_message "OK" "KygoX v$VERSION starting..." "main"
    log_message "INFO" "Installation mode: $INSTALL_MODE" "main"
    
    # Set up sudo caching BEFORE any operations
    setup_sudo_cache
    
    # Core setup
    log_message "PROC" "Initializing core system..." "main"
    add_blackarch_repo || { 
        log_message "FAIL" "BlackArch setup failed" "main"
        exit 1
    }
    
    fix_pacman_keys
    update_system || {
        log_message "WARN" "System update failed but continuing anyway" "main"
    }
    
    install_yay || {
        log_message "WARN" "YAY installation failed - AUR packages will be skipped" "main"
        SKIP_AUR="true"
    }
    
    # Install dependencies
    install_base_dependencies
    
    # Install AUR packages (with sudo caching, no password prompts!)
    install_aur_packages
    
    # Main package installation
    if [ -n "$INSTALL_MODE" ]; then
        get_blackarch_packages || {
            log_message "FAIL" "Failed to get package list" "main"
            exit 1
        }
        
        install_packages
        
        # Retry failed packages with YAY
        if command -v yay &>/dev/null && [ "$SKIP_AUR" != "true" ]; then
            retry_failed_with_yay
        fi
    fi
    
    # Verification
    verify_installation
    
    # Cleanup
    cleanup
    
    log_message "OK" "Installation completed" "main"
}

# Script entry point - let's do this
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
    show_summary
fi

# Author: 0xbv1 | 0xb0rn3
# Contact: IG: theehiv3 | X: 0xbv1 | Threads: theehiv3 | Email: q4n0@proton.me
# If you're reading this, you're probably trying to figure out what went wrong.
# Check the logs first before complaining.
