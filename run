#!/usr/bin/env bash
# KYGOX - Because your pathetic security testing setup needs actual tools
# Version 0.1.8 - When script kiddies graduate to something less embarrassing
# Author: 0xbv1 | 0xb0rn3 
# Contact: IG: theehiv3 | X: 0xbv1 | Threads: theehiv3 | Email: q4n0@proton.me
# License: Do whatever the hell you want, but don't blame me when it breaks

# Get the actual user before they sudo'd like an amateur
ORIGINAL_USER=$SUDO_USER
SUDO_ASKPASS_HELPER="/tmp/.kygox_askpass_$$"

# Terminal colors - because monochrome is for cowards
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
DARK='\033[1;30m'
BRED='\033[1;31m'
BGREEN='\033[1;32m'
BYELLOW='\033[1;33m'
BBLUE='\033[1;34m'
BPURPLE='\033[1;35m'
BCYAN='\033[1;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# Status indicators - because emojis are apparently professional now
OK="[${BGREEN}✓${RESET}]"
FAIL="[${BRED}✗${RESET}]"
INFO="[${BBLUE}*${RESET}]"
WARN="[${BYELLOW}!${RESET}]"
PROC="[${BPURPLE}↻${RESET}]"

# Directories - organized chaos is still chaos
LOG_DIR="kygox_logs"
MAIN_LOG="$LOG_DIR/installation.log"
BACKUP_DIR="$LOG_DIR/backups"
PACKAGE_LOG_DIR="$LOG_DIR/package_logs"
DEFAULT_TOOLKIT="default.txt"

# Version info - semantic versioning is for people who plan ahead
VERSION="0.1.8"
VERSION_NAME="Stop Asking For Passwords Edition"

# Tool mappings - because package names make no damn sense
declare -A tool_packages=(
    ["nmap"]="nmap"
    ["masscan"]="masscan"
    ["zmap"]="zmap"
    ["rustscan"]="rustscan"
    ["wireshark"]="wireshark-qt"
    ["tshark"]="wireshark-cli"
    ["tcpdump"]="tcpdump"
    ["aircrack-ng"]="aircrack-ng"
    ["bettercap"]="bettercap"
    ["kismet"]="kismet"
    ["wifite"]="wifite"
    ["reaver"]="reaver"
    ["sqlmap"]="sqlmap"
    ["nikto"]="nikto"
    ["gobuster"]="gobuster"
    ["dirb"]="dirb"
    ["wfuzz"]="wfuzz"
    ["ffuf"]="ffuf"
    ["whatweb"]="whatweb"
    ["wpscan"]="wpscan"
    ["nuclei"]="nuclei"
    ["httpx"]="httpx"
    ["subfinder"]="subfinder"
    ["john"]="john"
    ["hashcat"]="hashcat"
    ["hydra"]="hydra"
    ["medusa"]="medusa"
    ["msfconsole"]="metasploit"
    ["msfvenom"]="metasploit"
    ["searchsploit"]="exploitdb"
    ["impacket-smbserver"]="impacket"
    ["theharvester"]="theharvester"
    ["recon-ng"]="recon-ng"
    ["amass"]="amass"
    ["sherlock"]="sherlock-project"
    ["phoneinfoga"]="phoneinfoga"
    ["volatility"]="volatility3"
    ["autopsy"]="autopsy"
    ["binwalk"]="binwalk"
    ["exiftool"]="perl-image-exiftool"
    ["ghidra"]="ghidra"
    ["radare2"]="radare2"
    ["rizin"]="rizin"
    ["gdb"]="gdb"
    ["ltrace"]="ltrace"
    ["strace"]="strace"
    ["tor"]="tor"
    ["proxychains"]="proxychains-ng"
    ["lynis"]="lynis"
    ["chkrootkit"]="chkrootkit"
    ["rkhunter"]="rkhunter"
    ["apktool"]="android-apktool"
    ["jadx"]="jadx"
    ["frida"]="frida-tools"
    ["docker"]="docker"
    ["python3"]="python"
    ["ruby"]="ruby"
    ["go"]="go"
    ["rust"]="rust"
    ["gcc"]="gcc"
    ["git"]="git"
    ["curl"]="curl"
    ["wget"]="wget"
)

# 2025 security toolkit priorities - because staying current matters
declare -A priority_categories=(
    ["recon"]="10"
    ["exploitation"]="9"
    ["webapp"]="9"
    ["network"]="8"
    ["wireless"]="8"
    ["forensic"]="7"
    ["crypto"]="7"
    ["mobile"]="6"
    ["hardware"]="5"
    ["misc"]="3"
)

display_banner() {
    clear
    cat << 'EOF'
██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗
██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝
█████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝ 
██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗ 
██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗
╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    PENETRATION TESTING TOOLKIT INSTALLER
     Because clicking buttons is beneath you
EOF
    echo -e "          ${BOLD}Version $VERSION | $VERSION_NAME${RESET}"
    echo -e "   ${DIM}0xbv1 | IG: theehiv3 | X: 0xbv1 | q4n0@proton.me${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
}

show_usage() {
    echo -e "${BOLD}KygoX v$VERSION - Stop wasting time with manual installs${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${BOLD}Usage:${RESET}"
    echo -e "  sudo $0 [OPTIONS]"
    echo
    echo -e "${BOLD}Options that actually matter:${RESET}"
    echo -e "  -d, --default            Use the curated 2025 security toolkit (recommended)"
    echo -e "  -a, --all                Deploy everything (hope you have bandwidth)"
    echo -e "  -g, --group GROUP        Install specific tool category"
    echo -e "  -p, --packages FILE      Use your own damn package list"
    echo -e "  -q, --quiet              Shut up and install"
    echo -e "  --generate-default       Generate default.txt and exit"
    echo -e "  --skip-aur               Skip AUR (for the impatient)"
    echo -e "  --no-sudo-cache          Disable sudo caching (for the paranoid)"
    echo
    echo -e "${BOLD}Options for people who read documentation:${RESET}"
    echo -e "  -h, --help               This useless text"
    echo -e "  -v, --version            Version info nobody cares about"
    echo
    echo -e "${BOLD}Examples for the copy-paste warriors:${RESET}"
    echo -e "  sudo $0 -d                          # 2025 security toolkit (smart choice)"
    echo -e "  sudo $0 -a                          # YOLO mode"
    echo -e "  sudo $0 -g exploitation             # Script kiddie starter pack"
    echo -e "  sudo $0 -g wireless                 # WiFi \"hacker\" essentials"
    echo -e "  sudo $0 -p my_tools.txt             # Your curated bloatware"
    echo -e "  sudo $0 --generate-default          # Just build the toolkit list"
    echo
    echo -e "${BOLD}Tool categories (pick your poison):${RESET}"
    echo -e "  exploitation, wireless, webapp, scanner, forensic, crypto"
    echo -e "  Run 'pacman -Sg | grep blackarch' for the full list"
    echo
    echo -e "${DIM}Author: 0xbv1 | Contact: q4n0@proton.me${RESET}"
}

show_version() {
    echo -e "${BOLD}KygoX - Penetration Testing Toolkit Installer${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${BOLD}Version:${RESET}     $VERSION ($VERSION_NAME)"
    echo -e "${BOLD}Author:${RESET}      0xbv1 | 0xb0rn3"
    echo -e "${BOLD}Contact:${RESET}     IG: theehiv3 | X: 0xbv1 | Threads: theehiv3"
    echo -e "${BOLD}Email:${RESET}       q4n0@proton.me"
    echo -e "${BOLD}Repository:${RESET}  github.com/0xb0rn3/kygox"
    echo
    echo -e "${BOLD}What this thing actually does:${RESET}"
    echo -e "  • Installs BlackArch repository (because you're too lazy)"
    echo -e "  • Generates intelligent 2025 security toolkit (surpassing Kali/Parrot)"
    echo -e "  • Handles package conflicts (by breaking things properly)"
    echo -e "  • Manages AUR packages (without asking for passwords 50 times)"
    echo -e "  • Cleans up after itself (unlike you)"
    echo -e "  • Supports ${#tool_packages[@]} tool mappings (that nobody asked for)"
    echo
    echo -e "${DIM}If it breaks, you get to keep both pieces.${RESET}"
}

log_message() {
    local level="$1"
    local message="$2"
    local component="${3:-main}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR" "$PACKAGE_LOG_DIR"
    echo "[$timestamp] [$level] [$component] $message" >> "$MAIN_LOG"
    
    if [ "$QUIET_MODE" != "true" ]; then
        case "$level" in
            "OK") echo -e "$OK $message" ;;
            "FAIL") echo -e "$FAIL $message" ;;
            "INFO") echo -e "$INFO $message" ;;
            "WARN") echo -e "$WARN $message" ;;
            "PROC") echo -e "$PROC $message" ;;
            *) echo -e "[?] $message" ;;
        esac
    fi
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${FAIL} Nice try, but this needs root. Ever heard of sudo?"
        echo -e "${INFO} Run: ${BOLD}sudo $0 [options]${RESET}"
        exit 1
    fi
    
    if [ -z "$ORIGINAL_USER" ]; then
        echo -e "${FAIL} Can't figure out who you actually are. This is awkward."
        echo -e "${INFO} Make sure you're using sudo, not running as root directly"
        exit 1
    fi
    
    if ! id "$ORIGINAL_USER" &>/dev/null; then
        log_message "FAIL" "User '$ORIGINAL_USER' doesn't exist. Quantum user detected?" "init"
        exit 1
    fi
    
    log_message "OK" "Running as root with actual user: $ORIGINAL_USER" "init"
}

# Intelligent BlackArch repository parser - because manually maintaining lists is for peasants
generate_intelligent_toolkit() {
    log_message "PROC" "Generating intelligent 2025 security toolkit..." "toolkit"
    
    # Create Python script for intelligent parsing
    cat > "/tmp/toolkit_generator.py" << 'PYEOF'
#!/usr/bin/env python3
"""
BlackArch Intelligent Toolkit Generator
Because manually curating 2800+ tools is for masochists
"""
import subprocess
import re
import json
import sys
from collections import defaultdict, Counter

class ToolkitGenerator:
    def __init__(self):
        self.categories = {
            'recon': {
                'priority': 10,
                'keywords': ['nmap', 'masscan', 'zmap', 'subfinder', 'amass', 'nuclei', 'httpx', 
                           'rustscan', 'shodan', 'censys', 'theharvester', 'recon-ng', 'dnsrecon',
                           'dnsenum', 'fierce', 'sublist3r', 'assetfinder', 'findomain', 'gobuster',
                           'dirb', 'dirbuster', 'wfuzz', 'ffuf', 'feroxbuster', 'katana', 'hakrawler',
                           'gospider', 'waybackurls', 'gau', 'paramspider', 'arjun', 'meg', 'unfurl',
                           'anew', 'notify', 'interactsh', 'dnsx', 'naabu', 'mapcidr', 'shuffledns',
                           'chaos', 'uncover', 'asnmap', 'tlsx', 'cloudlist', 'pdtm'],
                'blacklist': ['recon-all', 'reconnoitre-ping']
            },
            'exploitation': {
                'priority': 9,
                'keywords': ['metasploit', 'exploit', 'payload', 'msfconsole', 'msfvenom', 'beef',
                           'armitage', 'cobalt', 'empire', 'powersploit', 'shellcode', 'rop',
                           'covenant', 'sliver', 'pupy', 'koadic', 'silenttrinity', 'mythic',
                           'villain', 'havoc', 'bruteratel', 'nighthawk', 'poshc2', 'merlin',
                           'donut', 'scarecrow', 'veil', 'shellter', 'unicorn', 'invoke',
                           'powercat', 'nishang', 'powerview', 'bloodhound', 'sharpview'],
                'blacklist': ['exploit-suggester']
            },
            'webapp': {
                'priority': 9,
                'keywords': ['burp', 'sqlmap', 'nikto', 'skipfish', 'wapiti', 'w3af', 'zap',
                           'commix', 'xsser', 'wpscan', 'joomscan', 'droopescan', 'davtest',
                           'padbuster', 'nosqlmap', 'wfuzz', 'parameth', 'arjun', 'dalfox',
                           'xsstrike', 'xsshunter', 'beef-xss', 'sqlninja', 'bbqsql', 'jsql',
                           'ghauri', 'blind-sql', 'xxeinjector', 'ssti', 'tplmap', 'retire',
                           'wappalyzer', 'builtwith', 'wafw00f', 'cloudflare-enum', 'subjack',
                           'subzy', 'can-i-take-over-xyz', 'nuclei-templates', 'jaeles',
                           'qsreplace', 'urldedupe', 'uro', 'x8', 'param-miner', 'backslash'],
                'blacklist': ['webapp-config']
            },
            'wireless': {
                'priority': 8,
                'keywords': ['aircrack', 'wifite', 'kismet', 'bettercap', 'reaver', 'pixie',
                           'wps', 'hostapd', 'airodump', 'aireplay', 'wash', 'cowpatty',
                           'pyrit', 'hcxtools', 'hcxdumptool', 'wpa_supplicant', 'fern',
                           'wifiphisher', 'fluxion', 'eaphammer', 'hostapd-wpe', 'freeradius-wpe',
                           'wifi-honey', 'wifipumpkin3', 'pwnagotchi', 'wardriving', 'wigle',
                           'bluetooth', 'bluez', 'ubertooth', 'hackrf', 'gr-gsm', 'gqrx',
                           'rtl-sdr', 'sdrsharp', 'gnuradio', 'inspectrum', 'universal-radio-hacker',
                           'urh', 'rfcat', 'yard-stick', 'proxmark3', 'chameleon', 'flipper'],
                'blacklist': []
            },
            'network': {
                'priority': 8,
                'keywords': ['wireshark', 'tcpdump', 'ettercap', 'mitm', 'arp', 'netcat', 'socat',
                           'proxychains', 'tor', 'i2p', 'stunnel', 'sslstrip', 'mitmproxy',
                           'responder', 'impacket', 'crackmapexec', 'enum4linux', 'nbtscan',
                           'netdiscover', 'arp-scan', 'alive6', 'thc-ipv6', 'atk6', 'exploit6',
                           'fuzz6', 'implementation6', 'fake6', 'flood6', 'smurf6', 'rsmurf6',
                           'dnsdict6', 'inverse_lookup6', 'node_query6', 'passive_discovery6',
                           'redir6', 'toobig6', 'trace6', 'alive6', 'detect-new-ip6',
                           'dos-new-ip6', 'parasite6', 'sendpees6', 'sendpeesmp6', 'randicmp6'],
                'blacklist': ['network-manager']
            },
            'crypto': {
                'priority': 7,
                'keywords': ['john', 'hashcat', 'hydra', 'medusa', 'ncrack', 'ophcrack',
                           'rainbow', 'hash', 'crack', 'decrypt', 'cipher', 'steganography',
                           'stego', 'openssl', 'gpg', 'truecrypt', 'veracrypt', 'hashid',
                           'hash-identifier', 'name-that-hash', 'haiti', 'crackstation',
                           'rockyou', 'seclists', 'wordlists', 'cupp', 'cewl', 'crunch',
                           'maskprocessor', 'hashcat-utils', 'princeprocessor', 'kwprocessor',
                           'pack', 'pipal', 'mentalist', 'rsmangler', 'duplicut', 'rli',
                           'dehashed', 'h8mail', 'holehe', 'sherlock', 'maigret', 'socialscan'],
                'blacklist': ['hashcat-legacy']
            },
            'forensics': {
                'priority': 7,
                'keywords': ['volatility', 'autopsy', 'sleuthkit', 'binwalk', 'foremost',
                           'testdisk', 'photorec', 'scalpel', 'bulk_extractor', 'regripper',
                           'chkrootkit', 'rkhunter', 'lynis', 'clamav', 'yara', 'plaso',
                           'log2timeline', 'psort', 'psteal', 'timesketch', 'dff', 'xmount',
                           'afflib', 'libewf', 'libbde', 'libfvde', 'libfsapfs', 'libfsext',
                           'libfshfs', 'libfsntfs', 'libfsvhdi', 'libfswim', 'libodraw',
                           'libqcow', 'libsigscan', 'libsmdev', 'libsmraw', 'libvhdi',
                           'libvmdk', 'libvshadow', 'libvslvm', 'libfwnt', 'libfwsi'],
                'blacklist': []
            },
            'mobile': {
                'priority': 6,
                'keywords': ['apktool', 'dex2jar', 'jadx', 'frida', 'objection', 'mobsf',
                           'android', 'ios', 'mobile', 'adb', 'fastboot', 'aapt', 'aapt2',
                           'baksmali', 'smali', 'dex-tools', 'enjarify', 'procyon', 'cfr',
                           'fernflower', 'krakatau', 'bytecode-viewer', 'gda', 'qark',
                           'mobsfscan', 'semgrep', 'bandit', 'safety', 'piprot', 'cyclonedx',
                           'drozer', 'needle', 'passionfruit', 'mobileaudit', 'house',
                           'ostorlab', 'qark', 'super', 'mariana-trench', 'infer', 'sonarqube'],
                'blacklist': []
            },
            'reverse': {
                'priority': 8,
                'keywords': ['ghidra', 'radare2', 'rizin', 'ida', 'x64dbg', 'ollydbg', 'gdb',
                           'pwndbg', 'gef', 'peda', 'voltron', 'angr', 'z3', 'capstone',
                           'keystone', 'unicorn', 'triton', 'miasm', 'barf', 'manticore',
                           'symbolic', 'execution', 'binary', 'analysis', 'disassembly',
                           'decompiler', 'hex-rays', 'retdec', 'snowman', 'boomerang',
                           'reko', 'pharos', 'mcsema', 'remill', 'lifter', 'llvm',
                           'bindiff', 'diaphora', 'turbodiff', 'patchdiff2', 'binsec'],
                'blacklist': []
            },
            'osint': {
                'priority': 8,
                'keywords': ['maltego', 'spiderfoot', 'recon-ng', 'theharvester', 'shodan',
                           'censys', 'zoomeye', 'fofa', 'binaryedge', 'onyphe', 'hunter',
                           'clearbit', 'fullcontact', 'pipl', 'spokeo', 'whitepages',
                           'intelius', 'beenverified', 'truthfinder', 'instantcheckmate',
                           'peoplefinders', 'facebook', 'linkedin', 'twitter', 'instagram',
                           'tiktok', 'youtube', 'telegram', 'discord', 'reddit', 'github',
                           'gitlab', 'bitbucket', 'stackoverflow', 'medium', 'wordpress',
                           'blogger', 'tumblr', 'pinterest', 'flickr', 'deviantart'],
                'blacklist': []
            },
            'misc': {
                'priority': 3,
                'keywords': ['git', 'python', 'perl', 'ruby', 'gcc', 'make', 'cmake',
                           'curl', 'wget', 'vim', 'tmux', 'screen', 'zsh', 'bash',
                           'fish', 'powershell', 'pwsh', 'docker', 'podman', 'kubernetes',
                           'vagrant', 'virtualbox', 'vmware', 'qemu', 'kvm', 'xen',
                           'ansible', 'terraform', 'packer', 'consul', 'vault', 'nomad'],
                'blacklist': []
            }
        }
        
        # 2025 trending tools that should definitely be included
        self.trending_2025 = [
            'nuclei', 'httpx', 'subfinder', 'katana', 'naabu', 'dnsx', 'interactsh',
            'rustscan', 'feroxbuster', 'gospider', 'hakrawler', 'waybackurls',
            'gau', 'anew', 'notify', 'proxify', 'mapcidr', 'shuffledns',
            'cloudlist', 'tlsx', 'asnmap', 'pdtm', 'uncover', 'chaos-client',
            'dalfox', 'x8', 'param-miner', 'qsreplace', 'uro', 'urldedupe',
            'jaeles', 'ghauri', 'sqlmap', 'commix', 'xsstrike', 'retire',
            'wafw00f', 'subjack', 'subzy', 'takeover', 'nuclei-templates',
            'crackmapexec', 'bloodhound', 'sharphound', 'rubeus', 'mimikatz',
            'impacket', 'responder', 'enum4linux-ng', 'kerbrute', 'sprayhound',
            'sliver', 'covenant', 'mythic', 'havoc', 'villain', 'poshc2',
            'donut', 'scarecrow', 'veil', 'shellter', 'unicorn', 'invoke-obfuscation',
            'powerview', 'powerup', 'powersploit', 'nishang', 'empire', 'starkiller',
            'volatility3', 'rekall', 'lime', 'avml', 'fmem', 'linpmem',
            'plaso', 'timesketch', 'grr', 'velociraptor', 'osquery', 'fleet',
            'yara', 'yara-python', 'yaralyzer', 'yargen', 'signature-base',
            'frida', 'objection', 'mobsf', 'qark', 'drozer', 'needle',
            'passionfruit', 'house', 'mobileaudit', 'super', 'mariana-trench',
            'semgrep', 'bandit', 'safety', 'piprot', 'cyclonedx', 'syft',
            'grype', 'trivy', 'clair', 'anchore', 'twistlock', 'aqua',
            'ghidra', 'radare2', 'rizin', 'angr', 'z3-solver', 'capstone',
            'keystone-engine', 'unicorn-engine', 'triton-framework', 'miasm',
            'barf-project', 'manticore', 'symbolic-execution', 'binary-ninja',
            'cutter', 'x64dbg', 'gdb', 'pwndbg', 'gef', 'peda'
        ]
        
        # Essential tools that must be included regardless
        self.essential_tools = [
            'nmap', 'wireshark-qt', 'metasploit', 'burpsuite', 'sqlmap',
            'aircrack-ng', 'john', 'hashcat', 'hydra', 'gobuster',
            'nikto', 'nuclei', 'volatility3', 'binwalk', 'radare2',
            'ghidra', 'frida', 'impacket', 'responder', 'crackmapexec',
            'bloodhound', 'enum4linux', 'theharvester', 'recon-ng',
            'wpscan', 'whatweb', 'skipfish', 'w3af', 'owasp-zap',
            'masscan', 'zmap', 'rustscan', 'httpx', 'subfinder',
            'amass', 'katana', 'feroxbuster', 'ffuf', 'wfuzz',
            'dirb', 'dirbuster', 'gobuster', 'dalfox', 'xsstrike',
            'commix', 'ghauri', 'retire', 'wafw00f', 'subjack',
            'subzy', 'takeover', 'bettercap', 'ettercap', 'mitmproxy',
            'proxychains-ng', 'tor', 'i2p', 'stunnel', 'sslstrip',
            'netdiscover', 'nbtscan', 'arp-scan', 'tcpdump', 'netcat',
            'socat', 'chisel', 'ligolo', 'rpivot', 'sshuttle',
            'wifite', 'kismet', 'reaver', 'pixiewps', 'cowpatty',
            'pyrit', 'hcxtools', 'hcxdumptool', 'wpa-supplicant',
            'fern-wifi-cracker', 'wifiphisher', 'fluxion', 'eaphammer',
            'autopsy', 'sleuthkit', 'foremost', 'testdisk', 'photorec',
            'scalpel', 'bulk-extractor', 'regripper', 'plaso', 'log2timeline',
            'chkrootkit', 'rkhunter', 'lynis', 'clamav', 'yara',
            'medusa', 'ncrack', 'ophcrack', 'rainbow-crack', 'hashid',
            'hash-identifier', 'name-that-hash', 'haiti', 'crackstation',
            'rockyou', 'seclists', 'wordlists', 'cupp', 'cewl',
            'crunch', 'maskprocessor', 'hashcat-utils', 'princeprocessor',
            'apktool', 'dex2jar', 'jadx', 'objection', 'mobsf',
            'qark', 'drozer', 'needle', 'android-sdk', 'aapt',
            'baksmali', 'smali', 'dex-tools', 'enjarify', 'procyon',
            'maltego', 'spiderfoot', 'shodan', 'censys', 'zoomeye',
            'sherlock', 'maigret', 'holehe', 'socialscan', 'phoneinfoga',
            'osrframework', 'twint', 'instaloader', 'gallery-dl',
            'git', 'python', 'python-pip', 'ruby', 'perl', 'nodejs',
            'npm', 'go', 'rust', 'gcc', 'make', 'cmake', 'curl',
            'wget', 'vim', 'tmux', 'screen', 'zsh', 'docker'
        ]

    def get_blackarch_packages(self):
        """Get all BlackArch packages with their groups"""
        try:
            # Get all blackarch groups
            groups_output = subprocess.check_output(['pacman', '-Sg'], universal_newlines=True)
            blackarch_groups = [line.split()[0] for line in groups_output.split('\n') 
                              if line.startswith('blackarch-')]
            
            packages_by_group = {}
            all_packages = set()
            
            for group in blackarch_groups:
                try:
                    group_output = subprocess.check_output(['pacman', '-Sgq', group], 
                                                         universal_newlines=True)
                    packages = [pkg.strip() for pkg in group_output.split('\n') if pkg.strip()]
                    packages_by_group[group] = packages
                    all_packages.update(packages)
                except subprocess.CalledProcessError:
                    continue
            
            return packages_by_group, list(all_packages)
        except subprocess.CalledProcessError as e:
            print(f"Error getting BlackArch packages: {e}", file=sys.stderr)
            return {}, []

    def score_package(self, package_name, group_name):
        """Score a package based on relevance for 2025 security testing"""
        score = 0
        
        # Essential tools get maximum priority
        if package_name in self.essential_tools:
            return 1000
        
        # 2025 trending tools get high priority
        if package_name in self.trending_2025:
            score += 500
        
        # Category-based scoring
        for category, info in self.categories.items():
            if any(keyword in package_name.lower() for keyword in info['keywords']):
                score += info['priority'] * 10
                break
        
        # Group-based bonus
        if group_name:
            group_suffix = group_name.replace('blackarch-', '')
            if group_suffix in self.categories:
                score += self.categories[group_suffix]['priority'] * 5
        
        # Penalize blacklisted items
        for category, info in self.categories.items():
            if package_name in info['blacklist']:
                score -= 100
        
        # Length penalty for overly specific tools
        if len(package_name) > 20:
            score -= 5
        
        return max(score, 0)

    def filter_duplicates_and_conflicts(self, packages):
        """Remove duplicate functionality and conflicting packages"""
        filtered = []
        seen_base_names = set()
        
        # Define tool families where we only want the best one
        tool_families = {
            'burpsuite': ['burpsuite', 'burpsuite-pro'],
            'metasploit': ['metasploit', 'metasploit-framework'],
            'wireshark': ['wireshark', 'wireshark-qt', 'wireshark-gtk'],
            'hashcat': ['hashcat', 'hashcat-legacy', 'hashcat-utils'],
            'volatility': ['volatility', 'volatility3', 'volatility-community'],
            'radare': ['radare2', 'radare2-cutter', 'rizin'],
            'john': ['john', 'johnny'],
            'aircrack': ['aircrack-ng', 'aircrack-ng-scripts']
        }
        
        for package in packages:
            base_name = package.split('-')[0]
            
            # Handle tool families
            family_found = False
            for family, variants in tool_families.items():
                if package in variants:
                    if family not in seen_base_names:
                        # Pick the best variant
                        best_variant = variants[0]  # Usually the main package
                        if package == best_variant:
                            filtered.append(package)
                            seen_base_names.add(family)
                    family_found = True
                    break
            
            if not family_found and base_name not in seen_base_names:
                filtered.append(package)
                seen_base_names.add(base_name)
        
        return filtered

    def generate_toolkit(self, max_packages=300):
        """Generate the ultimate 2025 security toolkit"""
        packages_by_group, all_packages = self.get_blackarch_packages()
        
        if not all_packages:
            print("Failed to get BlackArch packages", file=sys.stderr)
            return []
        
        # Score all packages
        scored_packages = []
        for group, packages in packages_by_group.items():
            for package in packages:
                score = self.score_package(package, group)
                if score > 0:
                    scored_packages.append((package, score, group))
        
        # Sort by score descending
        scored_packages.sort(key=lambda x: x[1], reverse=True)
        
        # Take top packages and filter
        top_packages = [pkg[0] for pkg in scored_packages[:max_packages*2]]
        filtered_packages = self.filter_duplicates_and_conflicts(top_packages)
        
        # Ensure essential tools are included
        final_toolkit = list(self.essential_tools)
        for pkg in filtered_packages:
            if pkg not in final_toolkit and len(final_toolkit) < max_packages:
                final_toolkit.append(pkg)
        
        return final_toolkit[:max_packages]

if __name__ == "__main__":
    generator = ToolkitGenerator()
    toolkit = generator.generate_toolkit()
    
    if toolkit:
        for tool in toolkit:
            print(tool)
    else:
        sys.exit(1)
PYEOF
    
    # Run the Python generator
    if python3 /tmp/toolkit_generator.py > "$DEFAULT_TOOLKIT" 2>/dev/null; then
        local count=$(wc -l < "$DEFAULT_TOOLKIT")
        log_message "OK" "Generated intelligent toolkit with $count packages" "toolkit"
        
        # Add some metadata
        {
            echo "# KygoX v$VERSION - 2025 Security Toolkit"
            echo "# Generated: $(date)"
            echo "# Curated from BlackArch repository - because manual curation is for peasants"
            echo "# This surpasses Kali and Parrot OS default toolkits"
            echo "#"
            cat "$DEFAULT_TOOLKIT"
        } > "$DEFAULT_TOOLKIT.tmp" && mv "$DEFAULT_TOOLKIT.tmp" "$DEFAULT_TOOLKIT"
        
        log_message "OK" "Default toolkit saved to $DEFAULT_TOOLKIT" "toolkit"
    else
        log_message "FAIL" "Python toolkit generator failed, using fallback..." "toolkit"
        generate_fallback_toolkit
    fi
    
    # Cleanup
    rm -f /tmp/toolkit_generator.py
}

generate_fallback_toolkit() {
    log_message "INFO" "Using fallback toolkit generation..." "toolkit"
    
    # Comprehensive fallback toolkit - manually curated for maximum coverage
    cat > "$DEFAULT_TOOLKIT" << 'TOOLEOF'
# KygoX v0.1.8 - 2025 Security Toolkit (Comprehensive Fallback)
# Because even fallbacks should be better than Kali defaults

# Network Reconnaissance & Discovery
nmap
nmap-scripts
masscan
zmap
rustscan
netdiscover
arp-scan
nbtscan
enum4linux
enum4linux-ng
alive6
fping
hping3
netcat
socat
proxychains-ng
chisel
ligolo-ng
rpivot
sshuttle

# DNS & Subdomain Enumeration
subfinder
amass
assetfinder
findomain
sublist3r
dnsrecon
dnsenum
fierce
dnsmap
dnstwist
massdns
shuffledns
puredns
dnsx
chaos-client
uncover
asnmap

# Web Application Security
burpsuite
owasp-zap
sqlmap
commix
ghauri
nikto
skipfish
wapiti
w3af
wpscan
joomscan
droopescan
davtest
padbuster
nosqlmap
wfuzz
ffuf
gobuster
dirb
dirbuster
feroxbuster
katana
hakrawler
gospider
meg
paramspider
arjun
dalfox
xsstrike
xsshunter-express
beef-xss
retire
whatweb
wafw00f
cloudflare-enum
subjack
subzy
can-i-take-over-xyz
nuclei
nuclei-templates
jaeles
qsreplace
urldedupe
uro
x8
param-miner
backslash-powered-scanner

# Network Analysis & Monitoring
wireshark-qt
wireshark-cli
tcpdump
ettercap-gtk
bettercap
mitmproxy
sslstrip
sslsplit
dnsspoof
arpspoof
driftnet
ngrep
chaosreader
tcpflow
tcpreplay
tcptrace
ssldump
p0f
prads

# Wireless Security
aircrack-ng
wifite
kismet
reaver
pixiewps
wash
cowpatty
pyrit
hcxtools
hcxdumptool
wpa-supplicant
fern-wifi-cracker
wifiphisher
fluxion
eaphammer
hostapd-wpe
freeradius-wpe
wifi-honey
wifipumpkin3
pwnagotchi
wardriving
wigle-wifi-wardriving

# Software Defined Radio & RF
hackrf
rtl-sdr
gqrx
gnuradio
inspectrum
universal-radio-hacker
rfcat
yard-stick-one
proxmark3
chameleon-mini
flipper-zero
ubertooth-one
gr-gsm
kalibrate-rtl

# Exploitation Frameworks
metasploit
beef
armitage
social-engineer-toolkit
covenant
sliver
pupy
koadic
silenttrinity
mythic-c2
villain
havoc-c2
bruteratel-c4
nighthawk-c2
poshc2
merlin-c2
empire
starkiller
powershell-empire

# Payload Generators & Obfuscators
msfvenom
donut
scarecrow
veil
shellter
unicorn
invoke-obfuscation
chameleon
phantom-evasion
avet
sharpshooter
macro-pack
darkarmour
crypter

# Password Attacks & Hash Cracking
john
hashcat
hashcat-utils
hydra
medusa
ncrack
patator
crowbar
brutespray
crackmapexec
kerbrute
sprayhound
lsassy
pypykatz
impacket-secretsdump
mimikatz
lazagne
ophcrack
rainbow-crack
hashid
hash-identifier
name-that-hash
haiti

# Wordlist Generation & Management
cupp
cewl
crunch
maskprocessor
princeprocessor
kwprocessor
pack
pipal
mentalist
rsmangler
duplicut
rli
wordlist-maker
username-anarchy
namemash

# Windows Post-Exploitation
impacket
responder
bloodhound
sharphound
rubeus
powerview
powerup
powersploit
nishang
invoke-mimikatz
powercat
powershell-mafia
empire-powershell
inveigh
kerberoast
asreproast
goldenpac
psexec
smbexec
wmiexec
dcomexec
atexec

# Linux Post-Exploitation
linpeas
linenum
linux-exploit-suggester
unix-privesc-check
traitor
gtfobins
lse
pspy
linux-smart-enumeration
bashark
uptux

# Forensics & Analysis
volatility3
rekall
lime-forensics
avml
fmem
linpmem
autopsy
sleuthkit
foremost
testdisk
photorec
scalpel
bulk-extractor
regripper
plaso
log2timeline
psort
psteal
timesketch
dff
xmount
afflib
libewf

# Memory Analysis
volatility
volatility3
rekall
lime
avml
fmem
linpmem
memoryze
mandiant-redline
winpmem

# Digital Forensics Tools
autopsy
sleuthkit
foremost
testdisk
photorec
scalpel
bulk-extractor
recoverjpeg
safecopy
ddrescue
dc3dd
dcfldd
ewftools
afftools
disktype
file
hexdump
xxd
binwalk

# Anti-Forensics & Privacy
bleachbit
wipe
secure-delete
shred
dban
nwipe
truecrypt
veracrypt
cryptsetup
steghide
outguess
stegosuite
openstego
steganabara
stegsolve

# System Security & Hardening
lynis
chkrootkit
rkhunter
clamav
tiger
aide
samhain
tripwire
ossec
wazuh
suricata
snort
bro
zeek

# Reverse Engineering & Binary Analysis
ghidra
radare2
rizin
cutter
x64dbg
ollydbg
immunity-debugger
gdb
pwndbg
gef
peda
voltron
angr
z3-solver
capstone
keystone-engine
unicorn-engine
triton-framework
miasm
barf-project
manticore
symbolic-execution
binary-ninja
retdec
snowman-decompiler
boomerang-decompiler
reko-decompiler

# Mobile Security
apktool
dex2jar
jadx
frida
frida-tools
objection
mobsf
qark
drozer
needle
passionfruit
house
mobileaudit
ostorlab
super
mariana-trench
android-sdk
aapt
aapt2
baksmali
smali
dex-tools
enjarify
procyon
cfr
fernflower
krakatau
bytecode-viewer
gda

# OSINT & Information Gathering
maltego
spiderfoot
recon-ng
theharvester
shodan
censys
zoomeye
fofa
binaryedge
onyphe
hunter-io
clearbit-connect
fullcontact
pipl
spokeo
whitepages
intelius
beenverified
truthfinder
instantcheckmate
peoplefinders
sherlock
maigret
holehe
socialscan
phoneinfoga
osrframework
twint
instaloader
gallery-dl
youtube-dl
metagoofil
foca
exiftool

# Social Engineering
social-engineer-toolkit
king-phisher
gophish
evilginx2
modlishka
phishery
beef
browser-exploitation-framework
social-mapper
phishing-frenzy
lucy
simplyemail
theharvestor
creepy
datasploit

# Cloud Security
prowler
scout-suite
cloudsploit
pacu
weirdaal
cloudmapper
cartography
cs-suite
cloud-enum
cloud-service-enum
gcp-enum
azure-enum
aws-enum
s3-bucket-finder
lazys3
s3recon
cloudscraper

# Container Security
docker-bench-security
clair
anchore
twistlock
aqua-scanner
falco
sysdig
grype
trivy
syft
docker-compose
podman
buildah
skopeo
dive
hadolint

# Vulnerability Scanners
openvas
nessus
nexpose
qualys
rapid7
nuclei
nmap-vulners
vulscan
vulners
searchsploit
exploit-db
metasploit-framework
nmap-scripts
nikto
skipfish
w3af
wapiti
arachni

# Network Tunneling & Pivoting
proxychains-ng
tor
i2p
stunnel
sslh
ssh
autossh
sshuttle
chisel
ligolo-ng
rpivot
plink
ngrok
localtunnel
serveo
expose
pagekite
cloudflare-tunnel

# Development Tools & Utilities
git
python
python3
python-pip
ruby
perl
nodejs
npm
yarn
go
rust
gcc
g++
clang
make
cmake
autotools-dev
build-essential
pkg-config
curl
wget
httpie
jq
yq
xmlstarlet
html-xml-utils
parallel
tmux
screen
zsh
fish
vim
nano
emacs
code
sublime-text

# Database Tools
mysql-client
postgresql-client
mongodb-tools
redis-tools
sqlitebrowser
dbeaver
adminer
phpmyadmin
pgadmin
robomongo
nosqlbooster
sqlmap
sqsh
isql
tsql
osql

# Virtualization & Emulation
virtualbox
vmware-workstation
qemu
kvm
xen
docker
podman
lxc
lxd
vagrant
packer
multipass
parallels

# Monitoring & Logging
wireshark
tcpdump
ntopng
nagios
zabbix
icinga
cacti
observium
librenms
pandora-fms
centreon
check-mk
sensu
grafana
prometheus
elk-stack
splunk
graylog
rsyslog
syslog-ng

# Backup & Recovery
rsync
rclone
duplicity
borgbackup
restic
bacula
amanda
tar
gzip
bzip2
xz
7zip
rar
unrar
zip
unzip

# Network Services
apache2
nginx
lighttpd
mysql-server
postgresql
mongodb
redis-server
memcached
elasticsearch
kibana
logstash
rabbitmq
activemq
kafka
zookeeper
consul
etcd
nomad
vault

# Text Processing & Analysis
grep
sed
awk
sort
uniq
cut
tr
head
tail
less
more
cat
tee
wc
diff
patch
strings
hexdump
xxd
od
base64
openssl
gpg

# Archive & Compression
tar
gzip
gunzip
bzip2
bunzip2
xz
unxz
7zip
zip
unzip
rar
unrar
compress
uncompress
zstd
lz4

# System Information & Monitoring
htop
iotop
nethogs
iftop
nload
bmon
vnstat
lsof
ss
netstat
ps
top
free
df
du
lscpu
lshw
lspci
lsusb
dmidecode
hwinfo
inxi
neofetch

# File System Tools
fdisk
parted
gparted
mkfs
fsck
mount
umount
losetup
cryptsetup
lvm2
mdadm
smartmontools
hdparm
sdparm
sg3-utils

# Scheduling & Automation
cron
at
systemd
ansible
puppet
chef
saltstack
fabric
invoke
make
cmake
ninja
scons
TOOLEOF
    
    log_message "OK" "Comprehensive fallback toolkit generated with $(grep -c '^[^#]' "$DEFAULT_TOOLKIT") packages" "toolkit"
}

setup_sudo_cache() {
    if [ "$NO_SUDO_CACHE" == "true" ]; then
        log_message "INFO" "Sudo caching disabled by paranoid user" "sudo"
        return 0
    fi
    
    log_message "PROC" "Setting up intelligent sudo caching..." "sudo"
    
    # Create askpass helper that returns empty (for sudoloop in yay)
    cat > "$SUDO_ASKPASS_HELPER" << 'EOHELPER'
#!/bin/bash
echo ""
EOHELPER
    chmod +x "$SUDO_ASKPASS_HELPER"
    
    # Prime sudo cache
    echo -e "${INFO} One-time authentication required for the entire installation"
    sudo -v
    
    # Keep sudo alive in background
    (
        while true; do
            sudo -n true 2>/dev/null || break
            sleep 50
        done
    ) &
    SUDO_KEEPER_PID=$!
    
    # Export for yay to use
    export SUDO_ASKPASS="$SUDO_ASKPASS_HELPER"
    
    log_message "OK" "Sudo cache configured - no more password prompts" "sudo"
}

cleanup_sudo_cache() {
    if [ -n "$SUDO_KEEPER_PID" ]; then
        kill "$SUDO_KEEPER_PID" 2>/dev/null
    fi
    rm -f "$SUDO_ASKPASS_HELPER" 2>/dev/null
    unset SUDO_ASKPASS
    log_message "INFO" "Sudo cache cleaned up" "sudo"
}

add_blackarch_repo() {
    log_message "PROC" "Adding BlackArch repository..." "setup"
    
    if grep -q "^\[blackarch\]" /etc/pacman.conf; then
        log_message "OK" "BlackArch already configured - skipping" "setup"
        return 0
    fi
    
    log_message "INFO" "Downloading BlackArch bootstrap script..." "setup"
    
    if ! curl -s -o strap.sh https://blackarch.org/strap.sh; then
        log_message "FAIL" "Failed to download BlackArch script. Check your internet." "setup"
        return 1
    fi
    
    if [ ! -f strap.sh ] || [ ! -s strap.sh ]; then
        log_message "FAIL" "BlackArch script is empty or corrupted" "setup"
        return 1
    fi
    
    chmod +x strap.sh
    
    if ./strap.sh &>/dev/null; then
        rm -f strap.sh
        log_message "OK" "BlackArch repository added successfully" "setup"
        return 0
    else
        rm -f strap.sh
        log_message "FAIL" "BlackArch installation failed" "setup"
        return 1
    fi
}

fix_pacman_keys() {
    log_message "PROC" "Fixing pacman keyring (this takes forever)..." "setup"
    
    # Kill any existing gpg-agent processes that might interfere
    killall gpg-agent 2>/dev/null
    
    # Remove old gnupg dir if corrupted
    rm -rf /etc/pacman.d/gnupg.old 2>/dev/null
    mv /etc/pacman.d/gnupg /etc/pacman.d/gnupg.old 2>/dev/null
    
    log_message "INFO" "Initializing new keyring..." "setup"
    pacman-key --init &>/dev/null
    
    log_message "INFO" "Populating keyring with Arch and BlackArch keys..." "setup"
    pacman-key --populate archlinux &>/dev/null
    pacman-key --populate blackarch &>/dev/null 2>&1
    
    log_message "INFO" "Refreshing keys (go get coffee)..." "setup"
    pacman-key --refresh-keys --keyserver keyserver.ubuntu.com &>/dev/null 2>&1 || true
    
    log_message "OK" "Keyring should be functional now" "setup"
}

update_system() {
    log_message "PROC" "Updating system packages..." "setup"
    
    local attempts=3
    for ((i=1; i<=attempts; i++)); do
        log_message "INFO" "Update attempt $i of $attempts..." "setup"
        
        if pacman -Syu --noconfirm &>/dev/null; then
            log_message "OK" "System updated successfully" "setup"
            return 0
        else
            log_message "WARN" "Update attempt $i failed" "setup"
            [ $i -lt $attempts ] && sleep 2
        fi
    done
    
    log_message "FAIL" "System update failed after $attempts attempts" "setup"
    return 1
}

install_yay() {
    if command -v yay &>/dev/null; then
        log_message "OK" "YAY already installed" "setup"
        return 0
    fi
    
    log_message "PROC" "Installing YAY AUR helper..." "setup"
    
    local deps=("git" "base-devel" "go")
    log_message "INFO" "Installing YAY dependencies: ${deps[*]}" "setup"
    
    if ! pacman -S --noconfirm --needed "${deps[@]}" &>/dev/null; then
        log_message "FAIL" "Failed to install YAY dependencies" "setup"
        return 1
    fi
    
    local build_dir="/tmp/yay-build-$"
    mkdir -p "$build_dir"
    cd "$build_dir"
    
    log_message "INFO" "Cloning YAY repository..." "setup"
    if ! sudo -u "$ORIGINAL_USER" git clone https://aur.archlinux.org/yay.git &>/dev/null; then
        log_message "FAIL" "Failed to clone YAY repository" "setup"
        rm -rf "$build_dir"
        return 1
    fi
    
    cd yay
    
    log_message "INFO" "Building YAY..." "setup"
    if sudo -u "$ORIGINAL_USER" makepkg -si --noconfirm &>/dev/null; then
        log_message "OK" "YAY installed successfully" "setup"
        cd /
        rm -rf "$build_dir"
        return 0
    else
        log_message "FAIL" "YAY build failed" "setup"
        cd /
        rm -rf "$build_dir"
        return 1
    fi
}

install_base_dependencies() {
    log_message "PROC" "Installing base dependencies..." "setup"
    
    local core_deps=(
        "base-devel" "cmake" "make" "gcc" "pkg-config"
        "git" "curl" "wget" "unzip" "tar" "gzip"
    )
    
    local lib_deps=(
        "openssl" "libpcap" "libnet" "libnetfilter_queue"
        "sqlite" "zlib" "pcre2"
    )
    
    local wireless_deps=(
        "iw" "wireless_tools" "net-tools"
    )
    
    local dev_deps=(
        "python" "python-pip" "python-setuptools"
        "ruby" "perl" "nodejs" "npm"
    )
    
    install_dep_group() {
        local group_name="$1"
        shift
        local deps=("$@")
        
        log_message "INFO" "Installing $group_name dependencies..." "setup"
        
        if pacman -S --noconfirm --needed "${deps[@]}" &>/dev/null; then
            log_message "OK" "$group_name dependencies installed"
            return 0
        else
            log_message "WARN" "Some $group_name dependencies failed"
            return 1
        fi
    }
    
    install_dep_group "core" "${core_deps[@]}"
    install_dep_group "library" "${lib_deps[@]}"
    install_dep_group "wireless" "${wireless_deps[@]}"
    install_dep_group "development" "${dev_deps[@]}"
    
    log_message "OK" "Base dependencies installation completed" "setup"
}

install_aur_packages() {
    if [ "$SKIP_AUR" == "true" ]; then
        log_message "INFO" "Skipping AUR packages as requested" "aur"
        return 0
    fi
    
    log_message "PROC" "Installing AUR packages..." "aur"
    
    # Critical AUR packages for 2025 security toolkit
    local aur_packages=(
        "nuclei-bin"
        "httpx-bin"
        "subfinder-bin"
        "katana-bin"
        "naabu-bin"
        "dnsx-bin"
        "interactsh-bin"
        "proxify-bin"
        "mapcidr-bin"
        "shuffledns-bin"
        "massdns-bin"
        "amass-bin"
        "assetfinder-bin"
        "findomain-bin"
        "waybackurls-bin"
        "gau-bin"
        "anew-bin"
        "notify-bin"
        "gf-bin"
        "qsreplace-bin"
        "hakrawler-bin"
        "gospider-bin"
        "dalfox-bin"
        "kxss-bin"
        "paramspider"
        "arjun"
        "corsy"
        "secretfinder"
        "truffelhog"
        "gitleaks-bin"
        "shodan"
        "censys"
        "feroxbuster-bin"
        "rustscan-bin"
        "ffuf-bin"
        "chaos-client-bin"
        "tlsx-bin"
        "asnmap-bin"
        "uncover-bin"
        "pdtm-bin"
        "cloudlist-bin"
        "x8"
        "param-miner"
        "retire"
        "wafw00f"
        "subjack-bin"
        "subzy-bin"
        "takeover"
        "jaeles-bin"
        "ghauri"
        "xsstrike"
        "commix"
        "uro"
        "urldedupe"
        "backslash-powered-scanner"
        "ligolo-ng-bin"
        "chisel-bin"
        "rpivot"
        "kerbrute-bin"
        "sprayhound"
        "enum4linux-ng"
        "lsassy"
        "pypykatz"
        "bloodhound-bin"
        "sharphound-bin"
        "crackmapexec"
        "impacket"
        "responder"
        "sliver-bin"
        "covenant"
        "mythic-bin"
        "havoc-bin"
        "villain"
        "poshc2"
        "donut-bin"
        "scarecrow-bin"
        "veil"
        "shellter"
        "unicorn"
        "invoke-obfuscation"
        "volatility3"
        "rekall"
        "lime-forensics"
        "avml"
        "plaso"
        "log2timeline"
        "timesketch"
        "grr-client"
        "velociraptor"
        "osquery"
        "yara"
        "yara-python"
        "yaralyzer"
        "yargen"
        "signature-base"
        "frida-tools"
        "objection"
        "mobsf"
        "qark"
        "drozer"
        "needle"
        "passionfruit"
        "house"
        "mobileaudit"
        "super"
        "mariana-trench"
        "semgrep"
        "bandit"
        "safety"
        "piprot"
        "cyclonedx-cli"
        "syft"
        "grype"
        "trivy"
        "clair"
        "anchore-cli"
        "ghidra"
        "radare2-cutter"
        "angr"
        "z3-solver"
        "capstone-tool"
        "keystone-tool"
        "unicorn-engine"
        "triton-framework"
        "miasm"
        "barf-project"
        "manticore"
        "binary-ninja-demo"
        "retdec"
        "snowman-decompiler"
        "boomerang-decompiler"
        "reko-decompiler"
        "maltego"
        "spiderfoot"
        "sherlock-project"
        "maigret"
        "holehe"
        "socialscan"
        "phoneinfoga"
        "osrframework"
        "twint"
        "instaloader"
        "gallery-dl"
        "youtube-dl"
        "metagoofil"
        "exiftool"
        "social-engineer-toolkit"
        "king-phisher"
        "gophish"
        "evilginx2"
        "modlishka"
        "phishery"
        "social-mapper"
        "prowler"
        "scout-suite"
        "cloudsploit"
        "pacu"
        "weirdaal"
        "cloudmapper"
        "cs-suite"
        "cloud-enum"
        "s3-bucket-finder"
        "lazys3"
        "s3recon"
        "cloudscraper"
        "docker-bench-security"
        "hadolint"
        "dive"
        "buildah"
        "skopeo"
        "podman-compose"
        "openvas"
        "nexpose"
        "nmap-vulners"
        "vulscan"
        "vulners"
        "nmap-scripts"
        "cupp"
        "cewl"
        "crunch"
        "maskprocessor"
        "princeprocessor"
        "kwprocessor"
        "pack"
        "pipal"
        "mentalist"
        "rsmangler"
        "duplicut"
        "rli"
        "wordlist-maker"
        "username-anarchy"
        "namemash"
        "linpeas"
        "linenum"
        "linux-exploit-suggester"
        "unix-privesc-check"
        "traitor"
        "pspy"
        "linux-smart-enumeration"
        "bashark"
        "uptux"
        "powerview"
        "powerup"
        "powersploit"
        "nishang"
        "rubeus"
        "mimikatz"
        "lazagne"
        "hashid"
        "hash-identifier"
        "name-that-hash"
        "haiti"
        "rockyou"
        "seclists"
        "wifite2"
        "wifiphisher"
        "fluxion"
        "eaphammer"
        "pwnagotchi"
        "hackrf"
        "rtl-sdr"
        "gqrx"
        "gnuradio"
        "inspectrum"
        "universal-radio-hacker"
        "rfcat"
        "proxmark3"
        "ubertooth"
        "flipper-zero-firmware"
        "autopsy"
        "sleuthkit"
        "foremost"
        "testdisk"
        "photorec"
        "scalpel"
        "bulk-extractor"
        "regripper"
        "chkrootkit"
        "rkhunter"
        "lynis"
        "clamav"
        "tiger"
        "aide"
        "samhain"
        "tripwire"
        "ossec"
        "wazuh"
        "suricata"
        "snort"
        "zeek"
        "steghide"
        "outguess"
        "stegosuite"
        "openstego"
        "steganabara"
        "stegsolve"
        "bleachbit"
        "wipe"
        "secure-delete"
        "dban"
        "nwipe"
        "truecrypt"
        "veracrypt"
        "pwndbg"
        "gef"
        "peda"
        "voltron"
        "x64dbg"
        "immunity-debugger"
    )
    
    local installed=0
    local failed=0
    local total=${#aur_packages[@]}
    
    log_message "INFO" "Processing $total AUR packages..." "aur"
    
    for package in "${aur_packages[@]}"; do
        # Check if already installed
        if pacman -Q "${package%-bin}" &>/dev/null || pacman -Q "$package" &>/dev/null; then
            log_message "INFO" "AUR package $package already installed" "aur"
            installed=$((installed + 1))
            continue
        fi
        
        log_message "PROC" "Installing AUR package: $package" "aur"
        
        # Use yay with sudoloop and askpass to avoid password prompts
        if sudo -u "$ORIGINAL_USER" SUDO_ASKPASS="$SUDO_ASKPASS_HELPER" \
           yay -S --noconfirm --needed --sudoloop --cleanafter "$package" &>/dev/null; then
            log_message "OK" "AUR package $package installed" "aur"
            installed=$((installed + 1))
        else
            log_message "WARN" "AUR package $package failed" "aur"
            failed=$((failed + 1))
            echo "$package" >> "$LOG_DIR/failed_aur.txt"
        fi
    done
    
    log_message "OK" "AUR installation: $installed successful, $failed failed" "aur"
}

get_blackarch_packages() {
    log_message "PROC" "Preparing package list..." "packages"
    
    case "$INSTALL_MODE" in
        "default")
            log_message "INFO" "Using intelligent 2025 security toolkit..." "packages"
            
            if [ ! -f "$DEFAULT_TOOLKIT" ]; then
                log_message "INFO" "Default toolkit not found, generating..." "packages"
                generate_intelligent_toolkit
            fi
            
            if [ -f "$DEFAULT_TOOLKIT" ]; then
                grep -v "^#" "$DEFAULT_TOOLKIT" | grep -v "^$" > blackarch_packages.txt
                local count=$(wc -l < blackarch_packages.txt)
                log_message "OK" "Loaded $count packages from default toolkit" "packages"
            else
                log_message "FAIL" "Failed to generate default toolkit" "packages"
                return 1
            fi
            ;;
            
        "all")
            log_message "INFO" "Fetching all BlackArch packages (this is insane)..." "packages"
            if pacman -Slq blackarch > blackarch_packages.txt 2>/dev/null; then
                local count=$(wc -l < blackarch_packages.txt)
                log_message "OK" "Found $count packages to install" "packages"
            else
                log_message "FAIL" "Failed to get BlackArch package list" "packages"
                return 1
            fi
            ;;
            
        "group")
            log_message "INFO" "Fetching packages for group: $GROUP_NAME" "packages"
            
            if ! pacman -Sg | grep -q "blackarch-$GROUP_NAME"; then
                log_message "FAIL" "Group 'blackarch-$GROUP_NAME' doesn't exist" "packages"
                echo -e "${WARN} Available groups:"
                pacman -Sg | grep blackarch | sort | column
                return 1
            fi
            
            if pacman -Sgq "blackarch-$GROUP_NAME" > blackarch_packages.txt 2>/dev/null; then
                local count=$(wc -l < blackarch_packages.txt)
                log_message "OK" "Found $count packages in group $GROUP_NAME" "packages"
            else
                log_message "FAIL" "Failed to get packages for group $GROUP_NAME" "packages"
                return 1
            fi
            ;;
            
        "custom")
            log_message "INFO" "Loading custom package list: $PACKAGE_LIST" "packages"
            
            if [ ! -f "$PACKAGE_LIST" ]; then
                log_message "FAIL" "Package list file not found: $PACKAGE_LIST" "packages"
                return 1
            fi
            
            grep -v "^#" "$PACKAGE_LIST" | grep -v "^$" > blackarch_packages.txt
            local count=$(wc -l < blackarch_packages.txt)
            log_message "OK" "Loaded $count packages from custom list" "packages"
            ;;
    esac
    
    # Validate packages exist in repository
    validate_packages_exist
    
    return 0
}

validate_packages_exist() {
    log_message "PROC" "Validating package availability..." "validate"
    
    local valid_packages=()
    local invalid_packages=()
    local total=0
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^# ]] && continue
        total=$((total + 1))
        
        # Check if package exists in any repository
        if pacman -Si "$package" &>/dev/null || pacman -Ss "^$package$" &>/dev/null; then
            valid_packages+=("$package")
        else
            invalid_packages+=("$package")
            log_message "WARN" "Package not found: $package" "validate"
        fi
    done < blackarch_packages.txt
    
    # Rewrite with only valid packages
    printf '%s\n' "${valid_packages[@]}" > blackarch_packages.txt
    
    local valid_count=${#valid_packages[@]}
    local invalid_count=${#invalid_packages[@]}
    
    log_message "OK" "Package validation: $valid_count valid, $invalid_count invalid" "validate"
    
    if [ "$invalid_count" -gt 0 ]; then
        printf '%s\n' "${invalid_packages[@]}" > "$LOG_DIR/invalid_packages.txt"
        log_message "INFO" "Invalid packages logged to $LOG_DIR/invalid_packages.txt" "validate"
    fi
}

handle_conflicts() {
    local package="$1"
    local error="$2"
    
    log_message "PROC" "Resolving conflicts for $package..." "conflict"
    
    # Try force overwrite first
    if pacman -S --noconfirm --overwrite='*' "$package" &>/dev/null; then
        log_message "OK" "Resolved conflicts for $package with overwrite" "conflict"
        return 0
    fi
    
    # Extract conflicting packages
    local conflicts=$(echo "$error" | grep -oE "conflicts with [^ ]+" | cut -d' ' -f3)
    
    for conflict in $conflicts; do
        log_message "INFO" "Removing conflicting package: $conflict" "conflict"
        pacman -R --noconfirm "$conflict" &>/dev/null
    done
    
    # Try again
    if pacman -S --noconfirm --needed "$package" &>/dev/null; then
        log_message "OK" "Resolved conflicts for $package" "conflict"
        return 0
    fi
    
    return 1
}

install_packages() {
    local total=$(wc -l < blackarch_packages.txt)
    local current=0
    local success=0
    local failed=0
    local skipped=0
    
    log_message "PROC" "Installing $total packages..." "install"
    
    > "$LOG_DIR/failed_packages.txt"
    > "$LOG_DIR/successful_packages.txt"
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^# ]] && continue
        
        current=$((current + 1))
        
        if [ "$QUIET_MODE" != "true" ]; then
            echo -ne "\r${PROC} Installing package $current/$total: $package"
        fi
        
        # Check if already installed
        if pacman -Q "$package" &>/dev/null; then
            skipped=$((skipped + 1))
            continue
        fi
        
        # Try to install
        local output=$(pacman -S --noconfirm --needed "$package" 2>&1)
        local result=$?
        
        if [ $result -eq 0 ]; then
            success=$((success + 1))
            echo "$package" >> "$LOG_DIR/successful_packages.txt"
        else
            # Handle conflicts
            if echo "$output" | grep -q "conflict"; then
                if handle_conflicts "$package" "$output"; then
                    success=$((success + 1))
                    echo "$package" >> "$LOG_DIR/successful_packages.txt"
                else
                    failed=$((failed + 1))
                    echo "$package" >> "$LOG_DIR/failed_packages.txt"
                fi
            else
                failed=$((failed + 1))
                echo "$package" >> "$LOG_DIR/failed_packages.txt"
            fi
        fi
        
    done < blackarch_packages.txt
    
    if [ "$QUIET_MODE" != "true" ]; then
        echo # New line after progress
    fi
    
    log_message "OK" "Installation complete: $success installed, $failed failed, $skipped skipped" "install"
}

retry_failed_with_yay() {
    local failed_file="$LOG_DIR/failed_packages.txt"
    
    if [ ! -s "$failed_file" ]; then
        return 0
    fi
    
    local count=$(wc -l < "$failed_file")
    log_message "PROC" "Retrying $count failed packages with YAY..." "retry"
    
    local recovered=0
    
    while IFS= read -r package; do
        [ -z "$package" ] && continue
        
        log_message "INFO" "Retrying $package with YAY..." "retry"
        
        if sudo -u "$ORIGINAL_USER" SUDO_ASKPASS="$SUDO_ASKPASS_HELPER" \
           yay -S --noconfirm --needed --sudoloop "$package" &>/dev/null; then
            log_message "OK" "Recovered $package with YAY" "retry"
            recovered=$((recovered + 1))
        fi
    done < "$failed_file"
    
    log_message "OK" "Recovered $recovered packages with YAY" "retry"
}

cleanup() {
    log_message "PROC" "Cleaning up..." "cleanup"
    
    # Clean package cache
    log_message "INFO" "Cleaning package cache..." "cleanup"
    pacman -Sc --noconfirm &>/dev/null
    
    # Clean yay cache
    if command -v yay &>/dev/null; then
        sudo -u "$ORIGINAL_USER" yay -Sc --noconfirm &>/dev/null
    fi
    
    # Remove temp files
    rm -f blackarch_packages.txt
    rm -rf /tmp/yay-build-*
    rm -rf /tmp/kygox-*
    rm -f /tmp/toolkit_generator.py
    
    log_message "OK" "Cleanup complete" "cleanup"
}

handle_interrupt() {
    echo -e "\n\n${FAIL} Installation interrupted by user"
    log_message "WARN" "Installation interrupted (SIGINT/SIGTERM)" "main"
    
    cleanup_sudo_cache
    
    echo -e "${INFO} Partial installation may have completed. Check logs in $LOG_DIR"
    exit 130
}

parse_arguments() {
    INSTALL_MODE=""
    GROUP_NAME=""
    PACKAGE_LIST=""
    QUIET_MODE="false"
    SKIP_AUR="false"
    NO_SUDO_CACHE="false"
    GENERATE_ONLY="false"
    
    if [ $# -eq 0 ]; then
        show_usage
        exit 0
    fi
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--default)
                INSTALL_MODE="default"
                shift
                ;;
            -a|--all)
                INSTALL_MODE="all"
                shift
                ;;
            -g|--group)
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    INSTALL_MODE="group"
                    GROUP_NAME="$2"
                    shift 2
                else
                    echo -e "${FAIL} --group needs an argument, genius"
                    show_usage
                    exit 1
                fi
                ;;
            -p|--packages)
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    INSTALL_MODE="custom"
                    PACKAGE_LIST="$2"
                    shift 2
                else
                    echo -e "${FAIL} --packages needs a file path"
                    show_usage
                    exit 1
                fi
                ;;
            -q|--quiet)
                QUIET_MODE="true"
                shift
                ;;
            --generate-default)
                GENERATE_ONLY="true"
                shift
                ;;
            --skip-aur)
                SKIP_AUR="true"
                shift
                ;;
            --no-sudo-cache)
                NO_SUDO_CACHE="true"
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            *)
                echo -e "${FAIL} Unknown option: $1"
                echo -e "${INFO} Try --help if you're lost"
                exit 1
                ;;
        esac
    done
    
    if [ "$GENERATE_ONLY" != "true" ] && [ -z "$INSTALL_MODE" ]; then
        echo -e "${FAIL} No installation mode selected"
        echo -e "${INFO} Use -d (default), -a, -g GROUP, or -p FILE"
        show_usage
        exit 1
    fi
}

show_summary() {
    local success_count=0
    local failed_count=0
    
    [ -f "$LOG_DIR/successful_packages.txt" ] && success_count=$(wc -l < "$LOG_DIR/successful_packages.txt")
    [ -f "$LOG_DIR/failed_packages.txt" ] && failed_count=$(wc -l < "$LOG_DIR/failed_packages.txt")
    
    if [ "$QUIET_MODE" != "true" ]; then
        echo
        echo -e "${BOLD}╔════════════════════════════════════════════════════╗${RESET}"
        echo -e "${BOLD}║                 INSTALLATION COMPLETE                ║${RESET}"
        echo -e "${BOLD}╚════════════════════════════════════════════════════╝${RESET}"
        echo
        echo -e "${BOLD}Statistics (because metrics matter):${RESET}"
        echo -e "  ${BGREEN}Successful:${RESET}  $success_count packages"
        echo -e "  ${BRED}Failed:${RESET}      $failed_count packages"
        echo
        
        if [ "$failed_count" -gt 0 ]; then
            echo -e "${WARN} Failed packages logged in: $LOG_DIR/failed_packages.txt"
            echo -e "${INFO} You can manually install them or try again"
        fi
        
        echo -e "${INFO} Full logs available in: $LOG_DIR"
        echo -e "${INFO} Default toolkit: $DEFAULT_TOOLKIT"
        echo
        echo -e "${BOLD}Your 2025 security arsenal is now ready for deployment.${RESET}"
        echo -e "${DIM}This setup surpasses Kali and Parrot OS default installations.${RESET}"
        echo
        echo -e "${DIM}KygoX v$VERSION | 0xbv1 | q4n0@proton.me${RESET}"
        echo -e "${DIM}If it worked, you're welcome. If it didn't, check the logs.${RESET}"
        echo
    fi
}

verify_installation() {
    log_message "PROC" "Verifying installation..." "verify"
    
    local tools_to_check=(
        "nmap" "wireshark" "aircrack-ng" "metasploit"
        "sqlmap" "john" "hashcat" "hydra"
        "gobuster" "nikto" "burpsuite" "nuclei"
        "httpx" "subfinder" "ffuf"
    )
    
    local working=0
    local missing=0
    
    for tool in "${tools_to_check[@]}"; do
        # Check both tool name and package mapping
        local package="${tool_packages[$tool]:-$tool}"
        
        if command -v "$tool" &>/dev/null || pacman -Q "$package" &>/dev/null 2>&1; then
            working=$((working + 1))
            log_message "OK" "Tool verified: $tool" "verify"
        else
            missing=$((missing + 1))
            log_message "WARN" "Tool missing: $tool" "verify"
        fi
    done
    
    log_message "OK" "Verification complete: $working working, $missing missing" "verify"
    
    if [ "$missing" -gt 0 ]; then
        echo -e "${WARN} Some core tools are missing. Check the logs for details."
    fi
}

# Main execution flow - where the magic happens
main() {
    # Set up signal handlers
    trap handle_interrupt SIGINT SIGTERM
    trap cleanup_sudo_cache EXIT
    
    # Show banner
    display_banner
    
    # Parse command line arguments
    parse_arguments "$@"
    
    # Handle generate-only mode
    if [ "$GENERATE_ONLY" == "true" ]; then
        log_message "INFO" "Generating default toolkit only..." "main"
        
        # Need BlackArch repo for intelligent generation
        if ! grep -q "^\[blackarch\]" /etc/pacman.conf; then
            check_root
            add_blackarch_repo || {
                log_message "WARN" "BlackArch not available, using fallback" "main"
            }
        fi
        
        generate_intelligent_toolkit
        
        if [ -f "$DEFAULT_TOOLKIT" ]; then
            local count=$(grep -c '^[^#]' "$DEFAULT_TOOLKIT")
            echo -e "${OK} Default toolkit generated: $DEFAULT_TOOLKIT ($count packages)"
            echo -e "${INFO} Use 'sudo $0 -d' to install this toolkit"
        else
            echo -e "${FAIL} Failed to generate default toolkit"
            exit 1
        fi
        
        exit 0
    fi
    
    # Redirect output if quiet mode
    if [ "$QUIET_MODE" == "true" ]; then
        exec 1>>"$MAIN_LOG" 2>&1
    fi
    
    # Check root privileges
    check_root
    
    log_message "OK" "KygoX v$VERSION starting..." "main"
    log_message "INFO" "Installation mode: $INSTALL_MODE" "main"
    
    # Set up sudo caching BEFORE any operations
    setup_sudo_cache
    
    # Core setup
    log_message "PROC" "Initializing core system..." "main"
    add_blackarch_repo || { 
        log_message "FAIL" "BlackArch setup failed" "main"
        exit 1
    }
    
    fix_pacman_keys
    update_system || {
        log_message "WARN" "System update failed but continuing anyway" "main"
    }
    
    install_yay || {
        log_message "WARN" "YAY installation failed - AUR packages will be skipped" "main"
        SKIP_AUR="true"
    }
    
    # Install dependencies
    install_base_dependencies
    
    # Generate default toolkit if using default mode
    if [ "$INSTALL_MODE" == "default" ] && [ ! -f "$DEFAULT_TOOLKIT" ]; then
        generate_intelligent_toolkit
    fi
    
    # Install AUR packages (with sudo caching, no password prompts!)
    install_aur_packages
    
    # Main package installation
    if [ -n "$INSTALL_MODE" ]; then
        get_blackarch_packages || {
            log_message "FAIL" "Failed to get package list" "main"
            exit 1
        }
        
        install_packages
        
        # Retry failed packages with YAY
        if command -v yay &>/dev/null && [ "$SKIP_AUR" != "true" ]; then
            retry_failed_with_yay
        fi
    fi
    
    # Verification
    verify_installation
    
    # Cleanup
    cleanup
    
    log_message "OK" "Installation completed" "main"
}

# Script entry point - let's do this
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
    show_summary
fi

# Author: 0xbv1 | 0xb0rn3
# Contact: IG: theehiv3 | X: 0xbv1 | Threads: theehiv3 | Email: q4n0@proton.me
# If you're reading this, you're probably trying to figure out what went wrong.
# Check the logs first before complaining.
# The default.txt toolkit was intelligently curated to surpass Kali and Parrot OS.
