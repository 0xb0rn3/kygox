#!/usr/bin/env bash
# KYGOX - Enhanced Arch Linux Penetration Testing Toolkit
# Author: 0xbv1 | 0xb0rn3 
# Contact: IG: theehiv3 | X: 0xbv1 | Threads: theehiv3 | Email: q4n0@proton.me
# License: Do whatever the hell you want, but don't blame me when it breaks
set -euo pipefail

# Core Configuration
readonly VERSION="0.2.0-beta"
readonly VERSION_NAME="Venom"
readonly SCRIPT_NAME="KygoX"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"
readonly ALT_REPO="https://github.com/0xb0rn3/krilin"

# Environment Variables
ORIGINAL_USER="${SUDO_USER:-$(logname 2>/dev/null || echo $USER)}"
SUDO_TIMEOUT_PID=""
LOG_DIR="kygox_logs"
MAIN_LOG="$LOG_DIR/installation.log"
BACKUP_DIR="$LOG_DIR/backups"
DEFAULT_TOOLKIT="toolkit.txt"

# Installation Modes
INSTALL_MODE=""
GROUP_NAME=""
PACKAGE_FILE=""
QUIET_MODE=false
SKIP_AUR=false
GENERATE_ONLY=false
FORCE_CONTINUE=false
CHECK_UPDATE=false
AUTO_UPDATE=false

# Color Definitions
declare -r RED='\033[0;31m'
declare -r GREEN='\033[0;32m'
declare -r YELLOW='\033[0;33m'
declare -r BLUE='\033[0;34m'
declare -r PURPLE='\033[0;35m'
declare -r CYAN='\033[0;36m'
declare -r WHITE='\033[1;37m'
declare -r DARK='\033[1;30m'
declare -r BOLD='\033[1m'
declare -r DIM='\033[2m'
declare -r RESET='\033[0m'

# Status Indicators
declare -r SUCCESS="[${GREEN}✓${RESET}]"
declare -r ERROR="[${RED}✗${RESET}]"
declare -r INFO="[${BLUE}ℹ${RESET}]"
declare -r WARNING="[${YELLOW}⚠ ${RESET}]"
declare -r PROCESS="[${PURPLE}⚡${RESET}]"
declare -r SECURITY="[${CYAN}🔒${RESET}]"

# Core Security Tools - 2025 Collection
declare -a CORE_TOOLS=(
    "nmap" "masscan" "rustscan" "zmap"
    "wireshark-qt" "tcpdump" "ettercap" "bettercap"
    "metasploit" "sqlmap" "burpsuite" "owasp-zap"
    "aircrack-ng" "wifite" "kismet" "reaver"
    "john" "hashcat" "hydra" "medusa"
    "gobuster" "ffuf" "nikto" "whatweb"
    "nuclei" "httpx" "subfinder" "amass"
    "volatility3" "binwalk" "autopsy" "sleuthkit"
    "ghidra" "radare2" "rizin" "gdb"
    "frida" "apktool" "jadx" "mobsf"
    "theharvester" "recon-ng" "maltego" "sherlock"
    "impacket" "responder" "crackmapexec" "bloodhound"
    "yara" "clamav" "lynis" "chkrootkit"
)

# Trending Tools for 2025
declare -a TRENDING_2025=(
    "katana" "naabu" "dnsx" "interactsh"
    "feroxbuster" "hakrawler" "waybackurls" "gau"
    "dalfox" "x8" "param-miner" "ghauri"
    "sliver" "covenant" "havoc" "villain"
    "chaos-client" "uncover" "tlsx" "asnmap"
    "semgrep" "bandit" "trivy" "grype"
    "mobsf" "qark" "objection" "drozer"
    "angr" "miasm" "barf" "capstone"
    "proxify" "notify" "anew" "urldedupe"
)

# Enhanced UI Functions with Fixed Arrow Key Detection
interactive_menu() {
    local title="$1"
    shift
    local options=("$@")
    local selected=0
    local key=""
    
    # Clear screen and show title
    clear
    echo -e "\n${BOLD}$title${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    
    while true; do
        # Display menu options
        for i in "${!options[@]}"; do
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}▶ ${options[i]}${RESET}"
            else
                echo -e "    ${options[i]}"
            fi
        done
        
        echo -e "\n${DIM}Use ↑/↓ arrows to navigate, Enter to select, Q to quit${RESET}"
        
        # Read single character with proper escape sequence handling
        IFS= read -rsn1 key
        
        # Handle escape sequences for arrow keys
        if [[ "$key" == $'\x1b' ]]; then
            IFS= read -rsn1 -t 0.1 key
            if [[ "$key" == '[' ]]; then
                IFS= read -rsn1 -t 0.1 key
                case "$key" in
                    'A') # Up arrow
                        if ((selected > 0)); then
                            ((selected--))
                        fi
                        ;;
                    'B') # Down arrow
                        if ((selected < ${#options[@]} - 1)); then
                            ((selected++))
                        fi
                        ;;
                esac
            fi
        elif [[ "$key" == '' ]]; then # Enter key
            return $selected
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then # Quit
            echo -e "\n${INFO} Exiting..."
            exit 0
        fi
        
        # Clear previous menu for redraw
        clear
        echo -e "\n${BOLD}$title${RESET}"
        echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    done
}

# Python-based Package Installation Progress Tracker
create_python_installer() {
    cat > /tmp/kygox_installer.py << 'PYEOF'
#!/usr/bin/env python3
import subprocess
import sys
import time
import threading
from datetime import datetime

class PackageInstaller:
    def __init__(self, packages, log_file):
        self.packages = packages
        self.log_file = log_file
        self.total = len(packages)
        self.current = 0
        self.success = 0
        self.failed = 0
        self.success_list = []
        self.failed_list = []
        self.installing = ""
        self.show_progress = True
        
    def log_message(self, level, message):
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        with open(self.log_file, 'a') as f:
            f.write(f"[{timestamp}] [{level}] [installer] {message}\n")
    
    def update_progress(self):
        while self.show_progress:
            if self.current > 0:
                percentage = int((self.current / self.total) * 100)
                bar_length = 50
                filled = int((percentage / 100) * bar_length)
                bar = '█' * filled + '░' * (bar_length - filled)
                
                status = f"Installing: {self.installing[:40]:<40}"
                progress = f"[{bar}] {percentage}% ({self.current}/{self.total})"
                stats = f"✓{self.success} ✗{self.failed}"
                
                print(f"\r\033[K{status}")
                print(f"\r\033[K{progress} {stats}", end='', flush=True)
                print("\033[1A", end='')
            time.sleep(0.1)
    
    def install_package(self, package):
        self.installing = package
        try:
            result = subprocess.run(
                ['pacman', '-S', '--noconfirm', '--needed', package],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                self.success += 1
                self.success_list.append(package)
                self.log_message("SUCCESS", f"Installed: {package}")
                return True
            else:
                self.failed += 1
                self.failed_list.append(package)
                self.log_message("ERROR", f"Failed to install: {package} - {result.stderr[:100]}")
                return False
                
        except subprocess.TimeoutExpired:
            self.failed += 1
            self.failed_list.append(package)
            self.log_message("ERROR", f"Timeout installing: {package}")
            return False
        except Exception as e:
            self.failed += 1
            self.failed_list.append(package)
            self.log_message("ERROR", f"Exception installing {package}: {str(e)}")
            return False
    
    def install_batch(self, batch):
        try:
            result = subprocess.run(
                ['pacman', '-S', '--noconfirm', '--needed'] + batch,
                capture_output=True,
                text=True,
                timeout=600
            )
            
            if result.returncode == 0:
                self.success += len(batch)
                self.success_list.extend(batch)
                for pkg in batch:
                    self.log_message("SUCCESS", f"Batch installed: {pkg}")
                return True
            else:
                # Try individual installation for failed batch
                return False
                
        except Exception:
            return False
    
    def run(self):
        print(f"\n🔧 Installing {self.total} security packages...\n")
        
        # Start progress thread
        progress_thread = threading.Thread(target=self.update_progress)
        progress_thread.daemon = True
        progress_thread.start()
        
        batch_size = 5
        current_batch = []
        
        for package in self.packages:
            self.current += 1
            current_batch.append(package)
            
            if len(current_batch) == batch_size or self.current == self.total:
                # Try batch installation first
                if not self.install_batch(current_batch):
                    # Fall back to individual installation
                    self.success -= len(current_batch)  # Reset batch count
                    self.success_list = [p for p in self.success_list if p not in current_batch]
                    
                    for pkg in current_batch:
                        self.install_package(pkg)
                
                current_batch = []
                time.sleep(0.1)
        
        self.show_progress = False
        progress_thread.join(timeout=1)
        
        # Final display
        print(f"\r\033[K")
        print(f"\r\033[K")
        print(f"📦 Package Installation Complete!")
        print(f"   ✓ Successful: {self.success}")
        print(f"   ✗ Failed: {self.failed}")
        print(f"   📊 Success Rate: {int((self.success/self.total)*100)}%")
        
        # Save results
        with open('kygox_logs/successful_packages.log', 'w') as f:
            f.write('\n'.join(self.success_list))
        
        if self.failed_list:
            with open('kygox_logs/failed_packages.log', 'w') as f:
                f.write('\n'.join(self.failed_list))
        
        return self.success, self.failed

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 installer.py <package_file> <log_file>")
        sys.exit(1)
    
    package_file = sys.argv[1]
    log_file = sys.argv[2]
    
    try:
        with open(package_file, 'r') as f:
            packages = [line.strip() for line in f if line.strip() and not line.startswith('#')]
    except FileNotFoundError:
        print(f"Error: Package file {package_file} not found")
        sys.exit(1)
    
    installer = PackageInstaller(packages, log_file)
    success_count, failed_count = installer.run()
    
    sys.exit(0 if failed_count == 0 else 1)

if __name__ == "__main__":
    main()
PYEOF
    chmod +x /tmp/kygox_installer.py
}

# System Functions
log_message() {
    local level="$1"
    local message="$2"
    local component="${3:-system}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] [$component] $message" >> "$MAIN_LOG"
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        case "$level" in
            "SUCCESS") echo -e "$SUCCESS $message" ;;
            "ERROR") echo -e "$ERROR $message" ;;
            "INFO") echo -e "$INFO $message" ;;
            "WARNING") echo -e "$WARNING $message" ;;
            "PROCESS") echo -e "$PROCESS $message" ;;
            "SECURITY") echo -e "$SECURITY $message" ;;
            *) echo -e "[$level] $message" ;;
        esac
    fi
}

display_banner() {
    clear
    cat << 'EOF'
██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗
██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝
█████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝ 
██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗ 
██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗
╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    ARCH LINUX PENETRATION TESTING TOOLKIT
      Professional Security Arsenal Deployment
EOF
    echo -e "            ${BOLD}Version $VERSION | $VERSION_NAME${RESET}"
    echo -e "   ${DIM}0xbv1 | IG: theehiv3 | X: 0xbv1 | q4n0@proton.me${RESET}"
    echo -e "      ${DIM}Repository: $REPO_URL${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
}

show_usage() {
    echo -e "${BOLD}KygoX v$VERSION - Arch Linux System Security Toolkit Installer${RESET}"
    echo -e "${DARK}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${BOLD}USAGE:${RESET} sudo $0 [OPTIONS]"
    echo
    echo -e "${GREEN}-d, --default${RESET}            Install curated security toolkit"
    echo -e "${GREEN}-a, --all${RESET}                Install complete BlackArch repository"
    echo -e "${GREEN}-g, --group GROUP${RESET}        Install specific tool category"
    echo -e "${GREEN}-f, --file FILE${RESET}          Install from custom package list"
    echo -e "${GREEN}-i, --interactive${RESET}        Interactive installation mode"
    echo -e "${YELLOW}-q, --quiet${RESET}              Silent installation mode"
    echo -e "${YELLOW}--skip-aur${RESET}               Skip AUR package installations"
    echo -e "${YELLOW}--generate-toolkit${RESET}       Generate toolkit file only"
    echo -e "${CYAN}--check-update${RESET}           Check for script updates"
    echo -e "${BLUE}-h, --help${RESET}               Display this help"
    echo -e "${BLUE}-v, --version${RESET}            Display version information"
    echo
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo -e "  sudo $0 -d                      # Install curated toolkit"
    echo -e "  sudo $0 -i                      # Interactive mode"
    echo -e "  sudo $0 -g exploitation         # Install exploitation tools"
    echo
}

interactive_installation() {
    echo -e "${BOLD}Welcome to KygoX Interactive Installation${RESET}"
    echo -e "${DIM}Use arrow keys to navigate, Enter to select${RESET}"
    echo
    
    local main_options=(
        "🎯 Default Security Toolkit (Recommended)"
        "🌍 Complete BlackArch Repository"
        "📦 Specific Tool Category"
        "📄 Custom Package List"
        "⚙️ Generate Toolkit Only"
        "🔄 Check for Updates"
        "❌ Exit"
    )
    
    interactive_menu "Select Installation Mode:" "${main_options[@]}"
    local choice=$?
    
    case $choice in
        0) INSTALL_MODE="default" ;;
        1) 
            INSTALL_MODE="all"
            echo -e "${WARNING} This installs ALL BlackArch packages (several GB)"
            echo -ne "${INFO} Continue? [y/N]: "
            read -r confirm
            [[ ! "$confirm" =~ ^[Yy]$ ]] && exit 0
            ;;
        2)
            local categories=(
                "reconnaissance" "exploitation" "web-application"
                "network-analysis" "wireless-security" "password-attacks"
                "forensics" "reverse-engineering" "mobile-security"
            )
            interactive_menu "Select Category:" "${categories[@]}"
            GROUP_NAME="${categories[$?]}"
            INSTALL_MODE="group"
            ;;
        3)
            echo -ne "${INFO} Enter custom package file path: "
            read -r PACKAGE_FILE
            [[ ! -f "$PACKAGE_FILE" ]] && { echo -e "${ERROR} File not found"; exit 1; }
            INSTALL_MODE="file"
            ;;
        4) GENERATE_ONLY=true ;;
        5) CHECK_UPDATE=true ;;
        6) exit 0 ;;
    esac
    
    if [[ "$GENERATE_ONLY" != "true" && "$CHECK_UPDATE" != "true" ]]; then
        local addon_options=(
            "🔇 Quiet Mode"
            "🚫 Skip AUR Packages" 
            "💪 Force Continue on Errors"
            "🎯 Standard Installation"
        )
        
        interactive_menu "Additional Options:" "${addon_options[@]}"
        case $? in
            0) QUIET_MODE=true ;;
            1) SKIP_AUR=true ;;
            2) FORCE_CONTINUE=true ;;
        esac
    fi
}

# Simplified Distribution Detection
detect_distribution() {
    if [[ ! -f /etc/arch-release ]] && ! command -v pacman >/dev/null 2>&1; then
        if [[ -f /etc/debian_version ]]; then
            echo -e "${WARNING} Detected Debian-based system"
            echo -e "${INFO} For Debian/Ubuntu systems, use: ${CYAN}$ALT_REPO${RESET}"
            exit 1
        else
            echo -e "${ERROR} KygoX requires Arch Linux or Arch-based distributions"
            exit 1
        fi
    fi
    log_message "SUCCESS" "✓ Arch-based system detected" "distro"
}

# Simplified Requirements Check
check_system_requirements() {
    [[ $EUID -ne 0 ]] && { echo -e "${ERROR} Run with: sudo $0"; exit 1; }
    
    if ! ping -c 1 8.8.8.8 &>/dev/null; then
        [[ "$FORCE_CONTINUE" != "true" ]] && { echo -e "${ERROR} Internet required"; exit 1; }
    fi
    
    local space=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $space -lt 5 ]]; then
        [[ "$FORCE_CONTINUE" != "true" ]] && { echo -e "${ERROR} Need 5GB+ disk space"; exit 1; }
    fi
    
    log_message "SUCCESS" "System requirements verified" "system"
}

# Enhanced BlackArch Setup
add_blackarch_repository() {
    if grep -q "^\[blackarch\]" /etc/pacman.conf; then
        log_message "SUCCESS" "BlackArch repository already configured"
        return 0
    fi
    
    log_message "PROCESS" "Setting up BlackArch repository..."
    
    # Backup pacman.conf
    mkdir -p "$BACKUP_DIR"
    cp /etc/pacman.conf "$BACKUP_DIR/pacman.conf.backup.$(date +%s)"
    
    # Use direct BlackArch setup method
    curl -s https://blackarch.org/strap.sh | bash
    
    if grep -q "^\[blackarch\]" /etc/pacman.conf; then
        log_message "SUCCESS" "BlackArch repository configured"
        return 0
    else
        log_message "ERROR" "BlackArch setup failed"
        return 1
    fi
}

# Streamlined Package Database Update
update_package_database() {
    log_message "PROCESS" "Updating package databases..."
    
    local attempts=0
    local max_attempts=3
    
    while [[ $attempts -lt $max_attempts ]]; do
        if pacman -Sy --noconfirm; then
            log_message "SUCCESS" "Package database updated"
            return 0
        fi
        
        ((attempts++))
        [[ $attempts -lt $max_attempts ]] && sleep 2
    done
    
    log_message "ERROR" "Failed to update package database"
    return 1
}

# Essential Tools Installation
install_base_requirements() {
    log_message "PROCESS" "Installing base requirements..."
    
    local base_tools=(
        "base-devel" "git" "curl" "wget" "python" "python-pip"
    )
    
    for tool in "${base_tools[@]}"; do
        pacman -S --noconfirm --needed "$tool" &>/dev/null || \
            log_message "WARNING" "Failed to install: $tool"
    done
    
    log_message "SUCCESS" "Base requirements installed"
}

# YAY Installation
install_yay_helper() {
    if command -v yay >/dev/null 2>&1; then
        log_message "SUCCESS" "YAY already available"
        return 0
    fi
    
    log_message "PROCESS" "Installing YAY AUR helper..."
    
    local build_dir="/tmp/yay-build"
    mkdir -p "$build_dir"
    
    if sudo -u "$ORIGINAL_USER" git clone https://aur.archlinux.org/yay.git "$build_dir" &>/dev/null; then
        cd "$build_dir"
        if sudo -u "$ORIGINAL_USER" makepkg -si --noconfirm &>/dev/null; then
            log_message "SUCCESS" "YAY installed successfully"
            cd - >/dev/null
            rm -rf "$build_dir"
            return 0
        fi
    fi
    
    log_message "ERROR" "YAY installation failed"
    return 1
}

# Enhanced Toolkit Generation
generate_security_toolkit() {
    log_message "PROCESS" "Generating security toolkit..."
    
    cat > "$DEFAULT_TOOLKIT" << EOF
# KygoX v$VERSION - Security Toolkit
# Generated: $(date)

# Network Reconnaissance
nmap
masscan
rustscan
netdiscover

# Web Security
burpsuite
sqlmap
nikto
gobuster
nuclei

# Wireless Security  
aircrack-ng
wifite
kismet

# Password Attacks
john
hashcat
hydra

# Network Analysis
wireshark-qt
tcpdump
ettercap

# Exploitation
metasploit
impacket
responder

# Forensics
volatility3
binwalk
sleuthkit

# Reverse Engineering
ghidra
radare2
gdb

# OSINT
theharvester
sherlock

# System Security
yara
lynis

EOF

    local count=$(grep -c '^[^#]' "$DEFAULT_TOOLKIT" | grep -v '^$' || echo "0")
    log_message "SUCCESS" "Toolkit generated with $count tools"
}

# Package List Preparation
get_package_list() {
    case "$INSTALL_MODE" in
        "default")
            [[ ! -f "$DEFAULT_TOOLKIT" ]] && generate_security_toolkit
            grep '^[^#]' "$DEFAULT_TOOLKIT" | grep -v '^$' > package_list.tmp
            ;;
        "all")
            pacman -Slq blackarch > package_list.tmp 2>/dev/null
            ;;
        "group")
            pacman -Sgq "blackarch-$GROUP_NAME" > package_list.tmp 2>/dev/null || {
                echo -e "${ERROR} Group 'blackarch-$GROUP_NAME' not found"
                return 1
            }
            ;;
        "file")
            [[ ! -f "$PACKAGE_FILE" ]] && { echo -e "${ERROR} File not found"; return 1; }
            grep '^[^#]' "$PACKAGE_FILE" | grep -v '^$' > package_list.tmp
            ;;
    esac
    
    local count=$(wc -l < package_list.tmp)
    log_message "SUCCESS" "Package list prepared: $count packages"
}

# Enhanced Package Installation with Python Progress
install_packages() {
    log_message "PROCESS" "Starting package installation..."
    
    # Create Python installer
    create_python_installer
    
    # Validate packages exist
    log_message "INFO" "Validating package availability..."
    local valid_packages=()
    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue
        if pacman -Si "$pkg" &>/dev/null; then
            valid_packages+=("$pkg")
        fi
    done < package_list.tmp
    
    # Write validated packages
    printf '%s\n' "${valid_packages[@]}" > validated_packages.tmp
    
    # Run Python installer for better progress tracking
    if python3 /tmp/kygox_installer.py validated_packages.tmp "$MAIN_LOG"; then
        log_message "SUCCESS" "Package installation completed"
    else
        log_message "WARNING" "Some packages failed to install"
    fi
    
    # Cleanup
    rm -f /tmp/kygox_installer.py validated_packages.tmp package_list.tmp
}

# AUR Package Installation
install_aur_packages() {
    [[ "$SKIP_AUR" == "true" || ! command -v yay >/dev/null 2>&1 ]] && return 0
    
    log_message "PROCESS" "Installing AUR packages..."
    
    local aur_tools=(
        "nuclei-bin" "httpx-bin" "subfinder-bin" "katana-bin"
        "feroxbuster-bin" "waybackurls-bin"
    )
    
    for tool in "${aur_tools[@]}"; do
        if sudo -u "$ORIGINAL_USER" yay -S --noconfirm --needed "$tool" &>/dev/null; then
            log_message "SUCCESS" "AUR installed: $tool"
        else
            log_message "WARNING" "AUR failed: $tool"
        fi
    done
}

# Installation Verification
verify_installation() {
    log_message "PROCESS" "Verifying installation..."
    
    local critical=("nmap" "wireshark" "metasploit" "sqlmap" "john" "hashcat")
    local working=0
    
    for tool in "${critical[@]}"; do
        if command -v "$tool" >/dev/null 2>&1 || pacman -Q "$tool" &>/dev/null; then
            ((working++))
        fi
    done
    
    log_message "SUCCESS" "Verification: $working/${#critical[@]} critical tools available"
    [[ $working -lt ${#critical[@]} ]] && return 1 || return 0
}

# System Cleanup
cleanup_system() {
    log_message "INFO" "Cleaning up..."
    pacman -Sc --noconfirm >/dev/null 2>&1
    command -v yay >/dev/null && sudo -u "$ORIGINAL_USER" yay -Sc --noconfirm >/dev/null 2>&1
    rm -f package_list.tmp validated_packages.tmp
    log_message "SUCCESS" "Cleanup completed"
}

# Enhanced Update Checking with Python
check_for_updates() {
    log_message "PROCESS" "Checking for updates..." "update"
    
    cat > /tmp/kygox_updater.py << 'PYEOF'
#!/usr/bin/env python3
import urllib.request
import json
import re
import sys
import os

def get_latest_version():
    try:
        url = "https://api.github.com/repos/0xb0rn3/kygox/releases/latest"
        with urllib.request.urlopen(url, timeout=10) as response:
            data = json.loads(response.read().decode())
            return data['tag_name'].lstrip('v'), data['body'][:100]
    except:
        return None, None

def get_current_version():
    try:
        with open(sys.argv[1], 'r') as f:
            content = f.read()
            match = re.search(r'readonly VERSION="([^"]+)"', content)
            return match.group(1) if match else "unknown"
    except:
        return "unknown"

def compare_versions(v1, v2):
    def normalize(v):
        return [int(x) for x in v.split('-')[0].split('.')]
    
    norm_v1, norm_v2 = normalize(v1), normalize(v2)
    max_len = max(len(norm_v1), len(norm_v2))
    norm_v1.extend([0] * (max_len - len(norm_v1)))
    norm_v2.extend([0] * (max_len - len(norm_v2)))
    
    return 1 if norm_v1 > norm_v2 else -1 if norm_v1 < norm_v2 else 0

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 updater.py <script_path>")
        sys.exit(1)
    
    current = get_current_version()
    latest, notes = get_latest_version()
    
    if not latest:
        print("UPDATE_CHECK_FAILED")
        sys.exit(1)
    
    if compare_versions(latest, current) > 0:
        print(f"UPDATE_AVAILABLE|{latest}|{notes}")
    else:
        print("UP_TO_DATE")

if __name__ == "__main__":
    main()
PYEOF

    if ! command -v python3 >/dev/null 2>&1; then
        log_message "WARNING" "Python3 not available for update check"
        return 1
    fi
    
    local result=$(python3 /tmp/kygox_updater.py "$0" 2>/dev/null)
    rm -f /tmp/kygox_updater.py
    
    case "$result" in
        "UP_TO_DATE")
            log_message "SUCCESS" "KygoX is up to date (v$VERSION)"
            ;;
        "UPDATE_AVAILABLE|"*)
            local latest=$(echo "$result" | cut -d'|' -f2)
            local notes=$(echo "$result" | cut -d'|' -f3)
            echo -e "${INFO} ${BOLD}Update Available: v$latest${RESET}"
            echo -e "  ${DIM}$notes${RESET}"
            if [[ "$AUTO_UPDATE" == "true" ]] || { echo -ne "${INFO} Update now? [y/N]: "; read -r response; [[ "$response" =~ ^[Yy]$ ]]; }; then
                perform_update "$latest"
            fi
            ;;
        *)
            log_message "WARNING" "Update check failed"
            ;;
    esac
}

# Self-Update Function
perform_update() {
    local new_version="$1"
    log_message "PROCESS" "Performing self-update to v$new_version..."
    
    local script_path="$0"
    local backup_path="${script_path}.backup.v${VERSION}"
    local download_url="https://raw.githubusercontent.com/0xb0rn3/kygox/main/run"
    
    # Backup current version
    cp "$script_path" "$backup_path"
    
    # Download new version
    if curl -fsSL "$download_url" -o "${script_path}.new"; then
        chmod +x "${script_path}.new"
        mv "${script_path}.new" "$script_path"
        
        log_message "SUCCESS" "Updated to v$new_version"
        echo -e "${SUCCESS} KygoX updated to v$new_version"
        echo -e "${INFO} Backup: $backup_path"
        echo -e "${INFO} Restarting..."
        
        exec "$script_path" "$@"
    else
        log_message "ERROR" "Update download failed"
        mv "$backup_path" "$script_path"
        echo -e "${ERROR} Update failed, restored backup"
    fi
}

# Enhanced Installation Summary
display_summary() {
    [[ "$QUIET_MODE" == "true" ]] && return
    
    local success=0
    local failed=0
    
    [[ -f "$LOG_DIR/successful_packages.log" ]] && success=$(wc -l < "$LOG_DIR/successful_packages.log")
    [[ -f "$LOG_DIR/failed_packages.log" ]] && failed=$(wc -l < "$LOG_DIR/failed_packages.log")
    
    clear
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${BOLD}                    INSTALLATION COMPLETE                       ${RESET}"
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${BOLD}📊 STATISTICS:${RESET}"
    echo -e "  ${GREEN}✓ Successful:${RESET} $success packages"
    echo -e "  ${RED}✗ Failed:${RESET}     $failed packages"
    echo -e "  ${CYAN}📈 Success Rate:${RESET} $((success*100/(success+failed)))%"
    echo
    echo -e "${BOLD}🛡️ SECURITY ARSENAL:${RESET}"
    echo -e "  Core Tools: ${GREEN}${#CORE_TOOLS[@]}${RESET} | Trending 2025: ${GREEN}${#TRENDING_2025[@]}${RESET}"
    echo
    echo -e "${BOLD}📝 LOGS:${RESET}"
    echo -e "  Main: ${CYAN}$MAIN_LOG${RESET}"
    [[ $success -gt 0 ]] && echo -e "  Success: ${CYAN}$LOG_DIR/successful_packages.log${RESET}"
    [[ $failed -gt 0 ]] && echo -e "  Failed: ${CYAN}$LOG_DIR/failed_packages.log${RESET}"
    echo
    if [[ $failed -eq 0 ]]; then
        echo -e "${SUCCESS} ${BOLD}Complete security toolkit deployment successful!${RESET}"
    else
        echo -e "${WARNING} Installation completed with some failures. Check logs for details."
    fi
    echo
    echo -e "${BOLD}🚀 QUICK START:${RESET}"
    echo -e "  Network Scan: ${GREEN}nmap -sV <target>${RESET}"
    echo -e "  Web Enum: ${GREEN}gobuster dir -u <url> -w /usr/share/wordlists/dirb/common.txt${RESET}"
    echo -e "  WiFi Audit: ${GREEN}wifite${RESET}"
    echo -e "  Password Crack: ${GREEN}john --wordlist=rockyou.txt <hashfile>${RESET}"
    echo
    echo -e "${DIM}KygoX v$VERSION | 0xb0rn3 | Repository: $REPO_URL${RESET}"
}

# Signal Handler
handle_interrupt() {
    echo
    log_message "WARNING" "Installation interrupted"
    echo -e "${WARNING} Installation interrupted. Check logs for details."
    cleanup_system
    exit 130
}

# Command Line Parser
parse_args() {
    INSTALL_MODE=""
    
    [[ $# -eq 0 ]] && { INSTALL_MODE="interactive"; return; }
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--default) INSTALL_MODE="default"; shift ;;
            -a|--all) INSTALL_MODE="all"; shift ;;
            -i|--interactive) INSTALL_MODE="interactive"; shift ;;
            -g|--group)
                [[ -n "$2" && ! "$2" =~ ^- ]] || { echo -e "${ERROR} --group needs argument"; exit 1; }
                INSTALL_MODE="group"; GROUP_NAME="$2"; shift 2 ;;
            -f|--file)
                [[ -n "$2" && ! "$2" =~ ^- ]] || { echo -e "${ERROR} --file needs argument"; exit 1; }
                INSTALL_MODE="file"; PACKAGE_FILE="$2"; shift 2 ;;
            -q|--quiet) QUIET_MODE=true; shift ;;
            --skip-aur) SKIP_AUR=true; shift ;;
            --generate-toolkit) GENERATE_ONLY=true; shift ;;
            --force) FORCE_CONTINUE=true; shift ;;
            --check-update) CHECK_UPDATE=true; shift ;;
            --auto-update) AUTO_UPDATE=true; shift ;;
            -h|--help) show_usage; exit 0 ;;
            -v|--version) 
                echo -e "${BOLD}KygoX v$VERSION ($VERSION_NAME)${RESET}"
                echo -e "Professional Arch Linux Security Toolkit"
                echo -e "Repository: $REPO_URL"
                exit 0 ;;
            *) echo -e "${ERROR} Unknown option: $1"; show_usage; exit 1 ;;
        esac
    done
    
    if [[ -z "$INSTALL_MODE" && "$GENERATE_ONLY" != "true" && "$CHECK_UPDATE" != "true" ]]; then
        echo -e "${ERROR} No installation mode specified"
        show_usage; exit 1
    fi
}

# Main Execution Function
main() {
    trap handle_interrupt SIGINT SIGTERM
    
    display_banner
    parse_args "$@"
    
    # Handle special modes
    if [[ "$CHECK_UPDATE" == "true" ]]; then
        check_for_updates
        exit $?
    fi
    
    if [[ "$INSTALL_MODE" == "interactive" ]]; then
        interactive_installation
    fi
    
    if [[ "$GENERATE_ONLY" == "true" ]]; then
        generate_security_toolkit
        echo -e "${SUCCESS} Toolkit generated: ${BOLD}$DEFAULT_TOOLKIT${RESET}"
        exit 0
    fi
    
    # Initialize logging
    mkdir -p "$LOG_DIR" "$BACKUP_DIR"
    log_message "INFO" "KygoX v$VERSION installation started"
    
    # Auto-update check
    [[ "$AUTO_UPDATE" == "true" ]] && check_for_updates
    
    # System validation
    detect_distribution
    check_system_requirements
    
    # Core installation steps
    echo -e "${INFO} Preparing security toolkit installation..."
    
    add_blackarch_repository || { echo -e "${ERROR} BlackArch setup failed"; exit 1; }
    update_package_database || { echo -e "${ERROR} Database update failed"; exit 1; }
    install_base_requirements
    
    # AUR helper
    [[ "$SKIP_AUR" != "true" ]] && install_yay_helper
    
    # Package installation
    get_package_list || { echo -e "${ERROR} Package list preparation failed"; exit 1; }
    install_packages
    install_aur_packages
    
    # Verification and cleanup
    verify_installation
    cleanup_system
    
    log_message "SUCCESS" "KygoX installation completed"
    display_summary
}

# Script Entry Point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
