#!/usr/bin/env bash
#
# kygoX - Arch Linux Security Testing Suite
# Version 0.2.0 Phoenix
# Author: 0xb0rn3 | Contact: IG: theehiv3 | X: 0xbv1 | Email: q4n0@proton.me
#
# Advanced security toolkit installer with integrated repository management
#

set -euo pipefail

# =============================================================================
# CONFIGURATION
# =============================================================================

readonly SCRIPT_VERSION="0.2.0"
readonly SCRIPT_CODENAME="Phoenix"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$HOME/.kygox"
readonly CACHE_DIR="/tmp/kygox_cache"

# Security Repository Configuration (Obfuscated)
readonly SECURITY_REPO_NAME="pentesting"
readonly SECURITY_REPO_DISPLAY="Security Arsenal"
readonly SECURITY_MIRROR_FILE="arsenal-mirrorlist"
readonly SECURITY_KEYRING_NAME="arsenal-keyring"
readonly SECURITY_OFFICIALS_PKG="arsenal-officials"

# Repository URLs (obfuscated variable names)
readonly ARSENAL_BASE_URL="https://blackarch.org"
readonly ARSENAL_KEYRING_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst"
readonly ARSENAL_KEYRING_SIG_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst.sig"
readonly ARSENAL_MIRROR_URL="https://blackarch.org/blackarch-mirrorlist"
readonly ARSENAL_GPG_KEY="4345771566D76038C7FEB43863EC0ADBEA87E4E3"

# Colors and UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Global State
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g AUTO_FIX=true
declare -g TOTAL_AVAILABLE_TOOLS=0
declare -g OLD_UMASK=""

# Package Categories with keywords for dynamic detection
declare -A CATEGORIES=(
    ["1"]="information-gathering:Information Gathering:nmap scan recon enum discover finger whois dns"
    ["2"]="vulnerability-analysis:Vulnerability Analysis:vuln cve exploit nikto openvas lynis audit"
    ["3"]="web-applications:Web Application Analysis:web http burp zap dir url spider crawl"
    ["4"]="password-attacks:Password Attacks:pass hash crack brute john hydra medusa wordlist"
    ["5"]="wireless-attacks:Wireless Attacks:wifi wireless air bluetooth rfid 802.11"
    ["6"]="exploitation:Exploitation Tools:exploit shell payload metasploit framework beef"
    ["7"]="forensics:Digital Forensics:forensic recover carve timeline memory disk volatility"
    ["8"]="sniffing-spoofing:Sniffing & Spoofing:sniff capture spoof mitm proxy wireshark"
)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Logging with timestamps
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local color=""
    local icon=""
    
    case "$level" in
        "SUCCESS") color="$GREEN"; icon="✓" ;;
        "ERROR")   color="$RED";   icon="✗" ;;
        "WARNING") color="$YELLOW"; icon="⚠" ;;
        "INFO")    color="$CYAN";  icon="ℹ" ;;
        "DEBUG")   color="$DIM";   icon="•" ;;
        *)         color="$WHITE"; icon="•" ;;
    esac
    
    # Log to file
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox.log"
    
    # Display to console
    if [[ "$level" == "DEBUG" && "$VERBOSE_MODE" != "true" ]]; then
        return
    fi
    
    echo -e "${color}${icon}${RESET} ${message}"
}

# Error handling
error_exit() {
    local exit_code="${2:-1}"
    log_message "ERROR" "$1"
    echo -e "${RED}${BOLD}Fatal Error:${RESET} $1" >&2
    cleanup_on_exit "$exit_code"
}

# Banner display with tool count
display_banner() {
    clear
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║  ██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗                               ║
║  ██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝                               ║
║  █████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝                                ║
║  ██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗                                ║
║  ██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗                               ║
║  ╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝                               ║
║                                                                              ║
║             kygoX - Arch Linux Security Testing Suite                       ║
║                      Version 0.2.0 Phoenix                                  ║
║                   By 0xb0rn3 | IG: theehiv3 | X: 0xbv1                     ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
EOF

    echo
    echo -e "${CYAN}${BOLD}System Dashboard:${RESET}"
    echo -e "  ${WHITE}•${RESET} OS: $(get_system_info)"
    echo -e "  ${WHITE}•${RESET} Kernel: $(uname -r)"
    echo -e "  ${WHITE}•${RESET} User: $ORIGINAL_USER"
    echo -e "  ${WHITE}•${RESET} Python: $(get_python_version)"
    
    # Get and display tool count
    local tool_count=$(get_total_security_tools)
    if [[ $tool_count -gt 0 ]]; then
        echo -e "  ${WHITE}•${RESET} Available Security Tools: ${GREEN}${BOLD}$tool_count${RESET}"
    else
        echo -e "  ${WHITE}•${RESET} Available Security Tools: ${YELLOW}Scanning...${RESET}"
    fi
    echo
}

# System info functions
get_system_info() {
    if [[ -f /etc/os-release ]]; then
        grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2
    else
        echo "Unknown Linux Distribution"
    fi
}

get_python_version() {
    if command -v python3 &>/dev/null; then
        python3 --version | cut -d' ' -f2
    else
        echo "Not installed"
    fi
}

# =============================================================================
# INTEGRATED SECURITY REPOSITORY SETUP 
# =============================================================================

# Set secure umask
set_secure_umask() {
    OLD_UMASK=$(umask)
    umask 0022
}

# Reset umask
reset_secure_umask() {
    if [[ -n "$OLD_UMASK" ]]; then
        umask "$OLD_UMASK"
    fi
}

# Check internet connectivity to security repository
check_security_repo_connectivity() {
    log_message "DEBUG" "Testing connectivity to security repository..."
    
    local tool='curl'
    local tool_opts='-s --connect-timeout 8'
    
    if ! $tool $tool_opts "$ARSENAL_BASE_URL/" > /dev/null 2>&1; then
        return 1
    fi
    
    return 0
}

# Add necessary GPG options for security repository
configure_gpg_for_security_repo() {
    log_message "DEBUG" "Configuring GPG for security repository..."
    
    local gpg_conf='/etc/pacman.d/gnupg/gpg.conf'
    
    # Add SHA-1 support for compatibility
    if [[ -f "$gpg_conf" ]] && ! grep -q 'allow-weak-key-signatures' "$gpg_conf"; then
        echo 'allow-weak-key-signatures' >> "$gpg_conf"
        log_message "DEBUG" "Added weak key signature support to GPG"
    fi
    
    return 0
}

# Create temporary directory for security repository setup
make_secure_tmp_dir() {
    local tmp_dir
    tmp_dir=$(mktemp -d /tmp/kygox_security_setup.XXXXXXXX)
    
    if [[ ! -d "$tmp_dir" ]]; then
        error_exit "Could not create temporary directory"
    fi
    
    # Set cleanup trap
    trap "rm -rf '$tmp_dir'" EXIT
    
    cd "$tmp_dir" || error_exit "Could not enter temporary directory"
    
    log_message "DEBUG" "Created temporary directory: $tmp_dir"
}

# Download security repository keyring
fetch_security_keyring() {
    log_message "DEBUG" "Downloading security repository keyring..."
    
    # Download keyring package
    if ! curl -s -O "$ARSENAL_KEYRING_URL"; then
        error_exit "Failed to download security keyring package"
    fi
    
    # Download signature
    if ! curl -s -O "$ARSENAL_KEYRING_SIG_URL"; then
        error_exit "Failed to download security keyring signature"
    fi
    
    log_message "DEBUG" "Security keyring downloaded successfully"
}

# Verify security repository keyring signature
verify_security_keyring() {
    log_message "DEBUG" "Verifying security repository keyring signature..."
    
    # Try multiple keyservers
    local keyservers=(
        "keyserver.ubuntu.com"
        "hkps://keyserver.ubuntu.com:443"
        "hkp://pgp.mit.edu:80"
    )
    
    local key_imported=false
    
    for keyserver in "${keyservers[@]}"; do
        if gpg --keyserver "$keyserver" --recv-keys "$ARSENAL_GPG_KEY" > /dev/null 2>&1; then
            key_imported=true
            break
        fi
    done
    
    if [[ "$key_imported" != "true" ]]; then
        log_message "WARNING" "Could not import security repository key from keyservers"
        return 1
    fi
    
    # Verify signature
    if ! gpg --keyserver-options no-auto-key-retrieve \
        --with-fingerprint *.pkg.tar.zst.sig > /dev/null 2>&1; then
        log_message "WARNING" "Security keyring signature verification failed"
        return 1
    fi
    
    log_message "DEBUG" "Security keyring signature verified"
    return 0
}

# Clean up signature files
cleanup_signature_files() {
    rm -f *.pkg.tar.zst.sig 2>/dev/null || true
}

# Initialize pacman GPG if needed
initialize_pacman_gpg() {
    log_message "DEBUG" "Initializing pacman GPG..."
    
    if ! pacman-key --init > /dev/null 2>&1; then
        log_message "WARNING" "Pacman GPG initialization failed"
        return 1
    fi
    
    return 0
}

# Install security repository keyring
install_security_keyring() {
    log_message "DEBUG" "Installing security repository keyring..."
    
    # Find keyring package
    local keyring_pkg
    keyring_pkg=$(find . -name "*.pkg.tar.zst" -type f | head -1)
    
    if [[ -z "$keyring_pkg" ]]; then
        error_exit "Security keyring package not found"
    fi
    
    # Install keyring
    if ! pacman --config /dev/null --noconfirm -U "$keyring_pkg" > /dev/null 2>&1; then
        error_exit "Security keyring installation failed"
    fi
    
    # Populate keyring
    pacman-key --populate > /dev/null 2>&1 || true
    
    log_message "DEBUG" "Security keyring installed successfully"
}

# Download security repository mirror list
fetch_security_mirrors() {
    log_message "DEBUG" "Fetching security repository mirror list..."
    
    local mirror_path="/etc/pacman.d"
    local mirror_file="$mirror_path/$SECURITY_MIRROR_FILE"
    
    if ! curl -s "$ARSENAL_MIRROR_URL" -o "$mirror_file"; then
        log_message "WARNING" "Could not fetch mirror list, using default configuration"
        
        # Create basic mirror configuration
        cat > "$mirror_file" << EOF
# Security Arsenal Mirror List
# Generated by kygoX v$SCRIPT_VERSION

Server = https://mirror.yandex.ru/mirrors/blackarch/\$repo/os/\$arch
Server = https://ftp.halifax.rwth-aachen.de/blackarch/\$repo/os/\$arch
Server = https://blackarch.mirror.garr.it/\$repo/os/\$arch
Server = https://mirror.23m.com/blackarch/\$repo/os/\$arch
EOF
        
        log_message "DEBUG" "Created default security repository mirror configuration"
    else
        log_message "DEBUG" "Security repository mirror list updated"
    fi
}

# Update pacman.conf with security repository
update_pacman_conf_for_security() {
    log_message "DEBUG" "Updating pacman configuration for security repository..."
    
    # Remove any existing security repository entries
    sed -i "/${SECURITY_REPO_NAME}/{N;d}" /etc/pacman.conf 2>/dev/null || true
    
    # Add security repository configuration
    cat >> "/etc/pacman.conf" << EOF

# Security Arsenal Repository - Managed by kygoX
[$SECURITY_REPO_NAME]
Include = /etc/pacman.d/$SECURITY_MIRROR_FILE
EOF
    
    log_message "DEBUG" "Pacman configuration updated for security repository"
}

# Synchronize package databases
synchronize_security_databases() {
    log_message "DEBUG" "Synchronizing security repository databases..."
    
    if pacman -Sy > /dev/null 2>&1; then
        log_message "DEBUG" "Security repository databases synchronized"
        return 0
    else
        log_message "WARNING" "Security repository database synchronization failed"
        return 1
    fi
}

# Install security repository meta-package (optional)
install_security_meta_package() {
    log_message "DEBUG" "Installing security repository meta-package..."
    
    # Try to install officials meta-package if available
    if pacman -S --noconfirm --needed "$SECURITY_REPO_NAME-officials" > /dev/null 2>&1; then
        log_message "DEBUG" "Security repository meta-package installed"
    else
        log_message "DEBUG" "Security repository meta-package not available or already installed"
    fi
}

# Main security repository setup function
setup_security_repository() {
    log_message "INFO" "Setting up security repository infrastructure..."
    
    # Check if already configured
    if grep -q "\[$SECURITY_REPO_NAME\]" /etc/pacman.conf 2>/dev/null; then
        log_message "INFO" "Security repository already configured"
        
        # Update total tools count
        get_total_security_tools > /dev/null
        return 0
    fi
    
    # Check internet connectivity
    if ! check_security_repo_connectivity; then
        error_exit "Cannot connect to security repository. Check internet connection."
    fi
    
    # Set secure permissions
    set_secure_umask
    
    # Create temporary workspace
    make_secure_tmp_dir
    
    # Configure GPG
    configure_gpg_for_security_repo
    
    # Download and verify keyring
    fetch_security_keyring
    
    # Verify keyring (optional, continue on failure)
    verify_security_keyring || log_message "WARNING" "Keyring verification skipped"
    
    # Clean up signature files
    cleanup_signature_files
    
    # Initialize pacman GPG
    initialize_pacman_gpg
    
    # Install keyring
    install_security_keyring
    
    # Configure mirrors
    fetch_security_mirrors
    
    # Update pacman configuration
    update_pacman_conf_for_security
    
    # Synchronize databases
    if ! synchronize_security_databases; then
        error_exit "Failed to synchronize security repository databases"
    fi
    
    # Install meta-package (optional)
    install_security_meta_package
    
    # Reset permissions
    reset_secure_umask
    
    # Update tool count
    get_total_security_tools > /dev/null
    
    log_message "SUCCESS" "Security repository configured successfully"
    log_message "INFO" "$SECURITY_REPO_DISPLAY is ready for use"
}

# =============================================================================
# DYNAMIC TOOL ANALYSIS SYSTEM
# =============================================================================

# Get total available security tools
get_total_security_tools() {
    if [[ $TOTAL_AVAILABLE_TOOLS -eq 0 ]]; then
        log_message "DEBUG" "Calculating total available security tools..."
        
        # Count packages from security repository
        if pacman -Sl "$SECURITY_REPO_NAME" &>/dev/null; then
            TOTAL_AVAILABLE_TOOLS=$(pacman -Sl "$SECURITY_REPO_NAME" 2>/dev/null | wc -l)
        else
            TOTAL_AVAILABLE_TOOLS=0
        fi
        
        log_message "DEBUG" "Found $TOTAL_AVAILABLE_TOOLS total security tools"
    fi
    
    echo $TOTAL_AVAILABLE_TOOLS
}

# Create Python tool analyzer
create_tool_analyzer() {
    cat > "$CACHE_DIR/tool_analyzer.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Tool Analyzer
Analyzes available security tools and categorizes them dynamically
"""

import sys
import subprocess
import re
from collections import defaultdict

class ToolAnalyzer:
    def __init__(self, repo_name="pentesting"):
        self.repo_name = repo_name
        self.categories = {}
        
    def get_available_packages(self):
        """Get all available packages from security repository"""
        try:
            result = subprocess.run(
                ['pacman', '-Sl', self.repo_name],
                capture_output=True,
                text=True,
                check=True
            )
            packages = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        packages.append(parts[1])
            return packages
        except subprocess.CalledProcessError:
            return []
    
    def categorize_tools(self, packages, keywords_map):
        """Categorize tools based on keyword patterns"""
        categorized = defaultdict(list)
        
        for package in packages:
            package_lower = package.lower()
            categorized_flag = False
            
            for category, keywords_str in keywords_map.items():
                keywords = keywords_str.split()
                
                # Check if package name contains any category keywords
                if any(keyword in package_lower for keyword in keywords):
                    categorized[category].append(package)
                    categorized_flag = True
                    break
            
            # If not categorized, put in miscellaneous
            if not categorized_flag:
                categorized['miscellaneous'].append(package)
        
        return dict(categorized)
    
    def analyze_category(self, category_keywords):
        """Analyze tools available for a specific category"""
        packages = self.get_available_packages()
        if not packages:
            return []
        
        keywords = category_keywords.split()
        matching_packages = []
        
        for package in packages:
            package_lower = package.lower()
            if any(keyword in package_lower for keyword in keywords):
                matching_packages.append(package)
        
        return matching_packages
    
    def get_package_info(self, package):
        """Get detailed information about a package"""
        try:
            result = subprocess.run(
                ['pacman', '-Si', package],
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode == 0:
                info = {}
                for line in result.stdout.split('\n'):
                    if ':' in line:
                        key, value = line.split(':', 1)
                        info[key.strip()] = value.strip()
                return info
            return {}
        except:
            return {}

def main():
    if len(sys.argv) < 2:
        print("Usage: tool_analyzer.py <action> [args]", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    analyzer = ToolAnalyzer()
    
    if action == "count_total":
        packages = analyzer.get_available_packages()
        print(len(packages))
    
    elif action == "analyze_category":
        if len(sys.argv) < 3:
            print("Usage: tool_analyzer.py analyze_category <keywords>", file=sys.stderr)
            sys.exit(1)
        
        keywords = sys.argv[2]
        matching_packages = analyzer.analyze_category(keywords)
        
        print(f"CATEGORY_COUNT:{len(matching_packages)}")
        for package in matching_packages[:20]:  # Show first 20
            print(f"PACKAGE:{package}")
        
        if len(matching_packages) > 20:
            print(f"MORE:{len(matching_packages) - 20}")
    
    elif action == "get_info":
        if len(sys.argv) < 3:
            print("Usage: tool_analyzer.py get_info <package>", file=sys.stderr)
            sys.exit(1)
        
        package = sys.argv[2]
        info = analyzer.get_package_info(package)
        
        if info:
            print(f"NAME:{info.get('Name', 'Unknown')}")
            print(f"VERSION:{info.get('Version', 'Unknown')}")
            print(f"DESCRIPTION:{info.get('Description', 'No description available')}")
            print(f"SIZE:{info.get('Download Size', 'Unknown')}")
        else:
            print("INFO_NOT_AVAILABLE")

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/tool_analyzer.py"
}

# Analyze category tools dynamically
analyze_category_tools() {
    local category_key="$1"
    
    if [[ ! "${CATEGORIES[$category_key]:-}" ]]; then
        echo "0"
        return
    fi
    
    local cat_info="${CATEGORIES[$category_key]}"
    local keywords=$(echo "$cat_info" | cut -d':' -f3)
    
    # Use Python analyzer to get category tools
    if [[ -f "$CACHE_DIR/tool_analyzer.py" ]]; then
        python3 "$CACHE_DIR/tool_analyzer.py" analyze_category "$keywords" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# =============================================================================
# SYSTEM VALIDATION
# =============================================================================

validate_system() {
    log_message "INFO" "Validating system requirements..."
    
    # Check root privileges
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    
    # Validate original user
    if [[ -z "$ORIGINAL_USER" || "$ORIGINAL_USER" == "root" ]]; then
        error_exit "Cannot determine original user. Please run with 'sudo $0'"
    fi
    
    # Check for Arch-based system
    if ! command -v pacman &>/dev/null; then
        if command -v apt &>/dev/null; then
            error_exit "Debian-based system detected. Use KRILIN instead: https://github.com/0xb0rn3/krilin"
        else
            error_exit "This tool requires an Arch-based distribution with pacman"
        fi
    fi
    
    # Check internet connectivity
    if ! ping -c 1 -W 3 archlinux.org &>/dev/null; then
        error_exit "Internet connectivity required for package downloads"
    fi
    
    # Check disk space (minimum 5GB)
    local available_space
    available_space=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $available_space -lt 5 ]]; then
        log_message "WARNING" "Only ${available_space}GB available. Some installations may fail."
    fi
    
    log_message "SUCCESS" "System validation completed"
}

# Install dependencies
install_dependencies() {
    log_message "INFO" "Installing required dependencies..."
    
    local required_packages=("curl" "wget" "python" "python-pip" "base-devel")
    local missing_packages=()
    
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        log_message "INFO" "Installing missing packages: ${missing_packages[*]}"
        pacman -Sy --noconfirm
        if ! pacman -S --noconfirm --needed "${missing_packages[@]}"; then
            error_exit "Failed to install required dependencies"
        fi
    fi
    
    log_message "SUCCESS" "Dependencies installed successfully"
}

# Check package availability
check_package_availability() {
    local package="$1"
    
    # Check if already installed
    if pacman -Qi "$package" &>/dev/null; then
        echo "installed"
        return 0
    fi
    
    # Check if available in any repository
    if pacman -Si "$package" &>/dev/null 2>&1; then
        echo "available"
        return 0
    fi
    
    echo "unavailable"
    return 1
}

# =============================================================================
# ERROR HANDLING SYSTEM
# =============================================================================

create_error_handler() {
    cat > "$CACHE_DIR/error_handler.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Error Handler and System Monitor
Monitors installation processes and handles errors intelligently
"""

import sys
import subprocess
import time
import signal
import os
from pathlib import Path

class InstallationMonitor:
    def __init__(self, log_file):
        self.log_file = Path(log_file)
        self.errors = []
        self.warnings = []
        self.running = True
        
    def monitor_installation(self, package_name, timeout=300):
        """Monitor package installation and detect errors"""
        start_time = time.time()
        
        while self.running and (time.time() - start_time) < timeout:
            if self.log_file.exists():
                try:
                    with open(self.log_file, 'r') as f:
                        lines = f.readlines()
                        
                    # Check last few lines for errors
                    recent_lines = lines[-10:] if len(lines) > 10 else lines
                    
                    for line in recent_lines:
                        line = line.strip().lower()
                        
                        # Critical errors that should stop installation
                        if any(error in line for error in [
                            'error: failed to commit transaction',
                            'error: target not found',
                            'error: failed retrieving file',
                            'conflicting files',
                            'could not resolve host',
                            'connection timed out',
                            'failed to synchronize',
                            'unable to lock database'
                        ]):
                            self.errors.append(line)
                            return False
                        
                        # Success indicators
                        if any(success in line for success in [
                            f'successfully installed {package_name}',
                            'installation completed',
                            'success',
                            'nothing to do'
                        ]):
                            return True
                            
                except IOError:
                    pass
            
            time.sleep(1)
        
        return None  # Timeout or process still running
    
    def suggest_fixes(self):
        """Suggest fixes based on detected errors"""
        fixes = []
        
        for error in self.errors:
            if 'target not found' in error:
                fixes.append("Update package database with: pacman -Sy")
            elif 'failed retrieving file' in error:
                fixes.append("Check internet connection and retry")
            elif 'conflicting files' in error:
                fixes.append("Force installation or resolve conflicts manually")
            elif 'could not resolve host' in error:
                fixes.append("Check DNS settings and internet connectivity")
            elif 'unable to lock database' in error:
                fixes.append("Wait for other package operations to complete")
        
        return fixes
    
    def auto_fix_common_issues(self):
        """Attempt to automatically fix common issues"""
        fixes_applied = []
        
        # Kill any hanging pacman processes
        try:
            subprocess.run(['pkill', '-f', 'pacman'], check=False, capture_output=True)
            fixes_applied.append("Killed hanging pacman processes")
        except:
            pass
        
        # Remove lock files
        lock_files = ['/var/lib/pacman/db.lck']
        for lock_file in lock_files:
            if os.path.exists(lock_file):
                try:
                    os.remove(lock_file)
                    fixes_applied.append(f"Removed lock file: {lock_file}")
                except:
                    pass
        
        # Update package database
        try:
            subprocess.run(['pacman', '-Sy'], check=True, capture_output=True)
            fixes_applied.append("Updated package database")
        except subprocess.CalledProcessError:
            pass
        
        # Clear package cache if needed
        try:
            subprocess.run(['pacman', '-Scc', '--noconfirm'], check=True, capture_output=True)
            fixes_applied.append("Cleared package cache")
        except subprocess.CalledProcessError:
            pass
        
        return fixes_applied

def main():
    if len(sys.argv) < 3:
        print("Usage: error_handler.py <package_name> <log_file>", file=sys.stderr)
        sys.exit(1)
    
    package_name = sys.argv[1]
    log_file = sys.argv[2]
    
    monitor = InstallationMonitor(log_file)
    
    # Monitor installation
    result = monitor.monitor_installation(package_name)
    
    if result is True:
        print("SUCCESS")
    elif result is False:
        print("ERROR")
        fixes = monitor.suggest_fixes()
        if fixes:
            print("SUGGESTED_FIXES:", ";".join(fixes))
        
        # Attempt auto-fix
        auto_fixes = monitor.auto_fix_common_issues()
        if auto_fixes:
            print("AUTO_FIXES_APPLIED:", ";".join(auto_fixes))
    else:
        print("TIMEOUT")
    
    sys.exit(0 if result is True else 1)

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/error_handler.py"
}

# =============================================================================
# PACKAGE INSTALLATION ENGINE
# =============================================================================

install_single_package() {
    local package="$1"
    local max_retries=3
    local retry_count=0
    
    log_message "INFO" "Installing package: $package"
    
    while [[ $retry_count -lt $max_retries ]]; do
        if [[ "$DRY_RUN" == "true" ]]; then
            log_message "INFO" "[DRY RUN] Would install: $package"
            return 0
        fi
        
        # Create temporary log for this installation
        local temp_log="/tmp/install_${package}_$$.log"
        
        # Start installation in background and monitor
        (
            pacman -S --noconfirm --needed "$package" 2>&1 | tee "$temp_log"
            echo "PACMAN_EXIT_CODE:$?" >> "$temp_log"
        ) &
        
        local install_pid=$!
        
        # Monitor with Python error handler
        if [[ -f "$CACHE_DIR/error_handler.py" ]]; then
            python3 "$CACHE_DIR/error_handler.py" "$package" "$temp_log" &
            local monitor_pid=$!
        fi
        
        # Wait for installation to complete
        wait "$install_pid"
        local exit_code=$?
        
        # Kill monitor if still running
        if [[ -n "${monitor_pid:-}" ]]; then
            kill "$monitor_pid" 2>/dev/null || true
        fi
        
        # Check installation result
        if [[ $exit_code -eq 0 ]]; then
            log_message "SUCCESS" "Installed: $package"
            rm -f "$temp_log"
            return 0
        else
            ((retry_count++))
            log_message "WARNING" "Installation failed for $package (attempt $retry_count)"
            
            # Auto-fix if enabled
            if [[ "$AUTO_FIX" == "true" && $retry_count -lt $max_retries ]]; then
                log_message "INFO" "Attempting auto-fix..."
                
                # Remove lock files
                rm -f /var/lib/pacman/db.lck 2>/dev/null || true
                
                # Update package database
                pacman -Sy --noconfirm &>/dev/null || true
                
                # Clear package cache if needed
                if [[ $retry_count -gt 1 ]]; then
                    pacman -Scc --noconfirm &>/dev/null || true
                fi
                
                sleep 2
            fi
        fi
        
        rm -f "$temp_log"
    done
    
    log_message "ERROR" "Failed to install $package after $max_retries attempts"
    return 1
}

install_packages() {
    local packages=("$@")
    local total_packages=${#packages[@]}
    local installed_count=0
    local failed_count=0
    local skipped_count=0
    
    if [[ $total_packages -eq 0 ]]; then
        log_message "WARNING" "No packages specified for installation"
        return 0
    fi
    
    log_message "INFO" "Installing $total_packages packages..."
    
    # Process packages sequentially for better error handling
    for package in "${packages[@]}"; do
        local status
        status=$(check_package_availability "$package")
        
        case "$status" in
            "installed")
                log_message "INFO" "$package already installed"
                ((skipped_count++))
                ;;
            "available")
                if install_single_package "$package"; then
                    ((installed_count++))
                else
                    ((failed_count++))
                fi
                ;;
            "unavailable")
                log_message "WARNING" "$package not available in repositories"
                ((failed_count++))
                ;;
        esac
    done
    
    # Report results
    echo
    log_message "SUCCESS" "Installation completed:"
    echo -e "  ${GREEN}✓${RESET} Installed: $installed_count"
    echo -e "  ${YELLOW}⚠${RESET} Skipped: $skipped_count"
    echo -e "  ${RED}✗${RESET} Failed: $failed_count"
}

# =============================================================================
# USER INTERFACE WITH DYNAMIC ANALYSIS
# =============================================================================

show_main_menu() {
    echo -e "${CYAN}${BOLD}kygoX Security Toolkit Selection${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    
    # Show total available tools
    local total_tools=$(get_total_security_tools)
    if [[ $total_tools -gt 0 ]]; then
        echo -e "${GREEN}${BOLD}📊 Security Arsenal Dashboard: $total_tools tools available${RESET}"
    else
        echo -e "${YELLOW}${BOLD}📊 Scanning security repository...${RESET}"
    fi
    echo
    
    for key in $(printf '%s\n' "${!CATEGORIES[@]}" | sort -n); do
        local cat_info="${CATEGORIES[$key]}"
        local cat_name=$(echo "$cat_info" | cut -d':' -f2)
        
        echo -e "  ${CYAN}$key${RESET}) $cat_name ${DIM}(analyzing...)${RESET}"
    done
    
    echo
    echo -e "${YELLOW}${BOLD}Special Options:${RESET}"
    echo -e "  ${CYAN}9${RESET}) Custom Package Selection"
    echo -e "  ${CYAN}0${RESET}) System Information & Repository Status"
    echo -e "  ${CYAN}q${RESET}) Quit"
    echo
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
}

show_category_analysis() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        log_message "ERROR" "Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}Analyzing $cat_name Tools...${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    
    # Show scanning animation
    echo -ne "${YELLOW}Scanning repository... ${RESET}"
    for i in {1..5}; do
        echo -ne "⣾⣽⣻⢿⡿⣟⣯⣷"
        sleep 0.2
        echo -ne "\b\b\b\b\b\b\b\b"
    done
    echo -e "${GREEN}✓${RESET}"
    
    # Get analysis results
    local analysis_result
    analysis_result=$(analyze_category_tools "$key")
    
    local tool_count=0
    local available_tools=()
    
    # Parse analysis results
    while IFS= read -r line; do
        if [[ "$line" =~ ^CATEGORY_COUNT:([0-9]+)$ ]]; then
            tool_count=${BASH_REMATCH[1]}
        elif [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
            available_tools+=("${BASH_REMATCH[1]}")
        fi
    done <<< "$analysis_result"
    
    echo
    echo -e "${GREEN}${BOLD}Found $tool_count tools in $cat_name category${RESET}"
    
    if [[ ${#available_tools[@]} -gt 0 ]]; then
        echo
        echo -e "${CYAN}Available tools (showing first 20):${RESET}"
        local count=0
        for tool in "${available_tools[@]}"; do
            if [[ $count -ge 20 ]]; then
                echo -e "  ${DIM}... and $((tool_count - 20)) more tools${RESET}"
                break
            fi
            
            # Check installation status
            local status
            status=$(check_package_availability "$tool")
            case "$status" in
                "installed") echo -e "  ${GREEN}✓${RESET} $tool ${DIM}(installed)${RESET}" ;;
                "available") echo -e "  ${CYAN}•${RESET} $tool" ;;
                "unavailable") echo -e "  ${RED}✗${RESET} $tool ${DIM}(unavailable)${RESET}" ;;
            esac
            ((count++))
        done
    else
        echo -e "${YELLOW}No tools found matching this category${RESET}"
    fi
    
    echo
}

handle_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        [1-8])
            show_category_analysis "$choice"
            echo
            read -p "Proceed with installation of this category? [Y/n]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                install_category_dynamic "$choice"
            fi
            ;;
        9)
            custom_package_selection
            ;;
        0)
            show_system_info
            ;;
        q|Q)
            exit 0
            ;;
        *)
            log_message "ERROR" "Invalid selection: $choice"
            return 1
            ;;
    esac
}

install_category_dynamic() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        log_message "ERROR" "Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    local keywords=$(echo "$cat_info" | cut -d':' -f3)
    
    echo -e "${CYAN}${BOLD}Installing $cat_name Tools${RESET}"
    
    # Get dynamic package list
    local analysis_result
    analysis_result=$(analyze_category_tools "$key")
    
    local packages=()
    while IFS= read -r line; do
        if [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
            packages+=("${BASH_REMATCH[1]}")
        fi
    done <<< "$analysis_result"
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        log_message "WARNING" "No packages found for $cat_name"
        return 1
    fi
    
    install_packages "${packages[@]}"
}

custom_package_selection() {
    echo -e "${CYAN}${BOLD}Custom Package Selection${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${YELLOW}Enter package names separated by spaces.${RESET}"
    echo -e "${DIM}Example: nmap nikto sqlmap burpsuite metasploit${RESET}"
    echo
    
    read -p "Packages to install: " -r packages_input
    
    if [[ -n "$packages_input" ]]; then
        read -ra selected_packages <<< "$packages_input"
        
        echo -e "\n${CYAN}Selected packages:${RESET}"
        for package in "${selected_packages[@]}"; do
            local status
            status=$(check_package_availability "$package")
            case "$status" in
                "installed") echo -e "  ${GREEN}✓${RESET} $package (already installed)" ;;
                "available") echo -e "  ${CYAN}ℹ${RESET} $package (available)" ;;
                "unavailable") echo -e "  ${RED}✗${RESET} $package (not found)" ;;
            esac
        done
        
        echo
        read -p "Proceed with installation? [Y/n]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_packages "${selected_packages[@]}"
        fi
    else
        log_message "WARNING" "No packages specified"
    fi
}

show_system_info() {
    echo -e "${CYAN}${BOLD}System Information & Repository Status${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    echo -e "${YELLOW}${BOLD}Hardware:${RESET}"
    echo -e "  CPU: $(cat /proc/cpuinfo | grep 'model name' | head -1 | cut -d':' -f2 | xargs)"
    echo -e "  Cores: $(nproc)"
    echo -e "  Memory: $(free -h | grep '^Mem:' | awk '{print $2 " total, " $3 " used"}')"
    echo -e "  Storage: $(df -h / | tail -1 | awk '{print $2 " total, " $4 " available"}')"
    echo
    
    echo -e "${YELLOW}${BOLD}System:${RESET}"
    echo -e "  Distribution: $(get_system_info)"
    echo -e "  Kernel: $(uname -r)"
    echo -e "  Architecture: $(uname -m)"
    echo -e "  Uptime: $(uptime -p)"
    echo
    
    echo -e "${YELLOW}${BOLD}Repository Status:${RESET}"
    echo -e "  Total Installed Packages: $(pacman -Q | wc -l)"
    
    local total_security_tools=$(get_total_security_tools)
    if [[ $total_security_tools -gt 0 ]]; then
        echo -e "  Security Tools Available: ${GREEN}$total_security_tools${RESET}"
        echo -e "  Security Tools Installed: $(pacman -Q | grep -v '^lib' | grep -E '(scan|hack|test|security|audit|recon|enum|exploit|crack|forensic|sniff|proxy|brute)' | wc -l || echo "0")"
    else
        echo -e "  Security Repository: ${RED}Not configured${RESET}"
    fi
    echo
    
    echo -e "${YELLOW}${BOLD}kygoX Status:${RESET}"
    echo -e "  Version: $SCRIPT_VERSION ($SCRIPT_CODENAME)"
    echo -e "  Cache Directory: $CACHE_DIR"
    echo -e "  Log Directory: $LOG_DIR"
    echo
}

# =============================================================================
# COMMAND LINE ARGUMENT PARSING
# =============================================================================

show_help() {
    cat << 'HELP_TEXT'
kygoX v0.2.0 Phoenix - Arch Linux Security Testing Suite

USAGE:
    sudo ./kygox [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be installed without installing
    -f, --force            Force installation of packages
    --no-auto-fix          Disable automatic error fixing
    --update-db            Update security repository database and exit

EXAMPLES:
    sudo ./kygox                    # Interactive mode with dynamic analysis
    sudo ./kygox -v                 # Verbose interactive mode
    sudo ./kygox --dry-run          # Preview installations

FEATURES:
    • Dynamic tool counting and analysis
    • Real-time repository scanning
    • Category-specific tool discovery
    • Intelligent error handling and recovery
    • Comprehensive installation monitoring
    • Integrated security repository management

CATEGORIES:
    1. Information Gathering    - Network reconnaissance and OSINT tools
    2. Vulnerability Analysis   - Security assessment and scanning tools  
    3. Web Application Analysis - Web security testing frameworks
    4. Password Attacks         - Password cracking and analysis tools
    5. Wireless Attacks         - WiFi and wireless security tools
    6. Exploitation Tools       - Penetration testing frameworks
    7. Digital Forensics        - Forensics and data recovery tools
    8. Sniffing & Spoofing      - Network monitoring and manipulation

SUPPORT:
    Repository: https://github.com/0xb0rn3/kygox
    Author: 0xb0rn3 (IG: theehiv3, X: 0xbv1)
HELP_TEXT
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --no-auto-fix)
                AUTO_FIX=false
                shift
                ;;
            --update-db)
                setup_security_repository
                get_total_security_tools
                echo "Repository updated. Total tools available: $TOTAL_AVAILABLE_TOOLS"
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

# =============================================================================
# CLEANUP AND MAIN EXECUTION
# =============================================================================

cleanup_on_exit() {
    local exit_code="${1:-0}"
    
    log_message "INFO" "Performing cleanup operations..."
    
    # Reset umask if needed
    reset_secure_umask
    
    # Kill any background processes
    jobs -p 2>/dev/null | xargs -r kill 2>/dev/null || true
    
    # Clean temporary files
    rm -rf "$CACHE_DIR" 2>/dev/null || true
    
    log_message "INFO" "kygoX session ended"
    exit "$exit_code"
}

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Create cache directory
    mkdir -p "$CACHE_DIR"
    
    # Display banner with tool count
    display_banner
    
    # System validation and setup
    validate_system
    install_dependencies
    setup_security_repository
    
    # Create analysis tools
    create_tool_analyzer
    create_error_handler
    
    # Show status
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}DRY RUN MODE - No packages will be installed${RESET}"
        echo
    fi
    
    # Main interactive loop
    while true; do
        show_main_menu
        read -p "Select option: " -r choice
        echo
        
        if ! handle_menu_selection "$choice"; then
            echo -e "${RED}Invalid selection. Please try again.${RESET}"
            sleep 1
        fi
        
        echo
        read -p "Press Enter to continue..." -r
    done
}

# Signal handlers
trap 'cleanup_on_exit 130' INT TERM
trap 'cleanup_on_exit $?' EXIT

# Execute main function with all arguments
main "$@"
