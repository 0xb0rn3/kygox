#!/usr/bin/env bash
#
# KYGOX - Enhanced Arch Linux Security Testing Suite
# Version 0.2.0 - Complete Rewrite
# Author: 0xb0rn3 | Contact: IG: theehiv3 | X: 0xbv1 | Email: q4n0@proton.me
#
# This version focuses on:
# - Real-time BlackArch repository scraping
# - Intelligent package availability checking
# - Hybrid bash-Python architecture for optimal performance
# - Reliable tool management and installation
#

set -euo pipefail

# =============================================================================
# CONFIGURATION AND GLOBALS
# =============================================================================

readonly SCRIPT_VERSION="0.2.0"
readonly SCRIPT_CODENAME="Phoenix"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$HOME/.kygox"
readonly CACHE_DIR="/tmp/kygox_cache"
readonly BLACKARCH_MIRROR="https://blackarch.org"
readonly BLACKARCH_REPO_URL="https://blackarch.org/strap.sh"

# Performance Settings
readonly MAX_PARALLEL_JOBS=4
readonly DOWNLOAD_TIMEOUT=30
readonly INSTALL_TIMEOUT=300

# Colors and UI Elements
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Status Icons
readonly ICON_SUCCESS="âœ“"
readonly ICON_ERROR="âœ—"
readonly ICON_WARNING="âš "
readonly ICON_INFO="â„¹"
readonly ICON_LOADING="âŸ³"
readonly ICON_ROCKET="ğŸš€"
readonly ICON_SHIELD="ğŸ›¡"
readonly ICON_TOOLS="ğŸ”§"

# Global State Variables
declare -g INTERACTIVE_MODE=true
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g CLEANUP_AFTER=true
declare -g PARALLEL_JOBS=2

# Package Management
declare -gA AVAILABLE_PACKAGES
declare -gA INSTALLED_PACKAGES
declare -gA FAILED_PACKAGES
declare -ga INSTALL_QUEUE

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Logging functions with timestamps and levels
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local color=""
    local icon=""
    
    case "$level" in
        "SUCCESS") color="$GREEN"; icon="$ICON_SUCCESS" ;;
        "ERROR")   color="$RED";   icon="$ICON_ERROR" ;;
        "WARNING") color="$YELLOW"; icon="$ICON_WARNING" ;;
        "INFO")    color="$CYAN";  icon="$ICON_INFO" ;;
        "DEBUG")   color="$DIM";   icon="â€¢" ;;
        *)         color="$WHITE"; icon="â€¢" ;;
    esac
    
    # Log to file
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox.log"
    
    # Display to console
    if [[ "$level" == "DEBUG" && "$VERBOSE_MODE" != "true" ]]; then
        return
    fi
    
    echo -e "${color}${icon}${RESET} ${message}"
}

# Enhanced error handling with context
error_exit() {
    local exit_code="${2:-1}"
    log_message "ERROR" "$1"
    echo -e "${RED}${BOLD}Fatal Error:${RESET} $1" >&2
    echo -e "${YELLOW}Check logs at: ${LOG_DIR}/kygox.log${RESET}" >&2
    cleanup_on_exit "$exit_code"
}

# Progress indicator for long operations
show_progress() {
    local pid=$1
    local message="$2"
    local chars="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local i=0
    
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${CYAN}%s${RESET} %s..." "${chars:$i:1}" "$message"
        i=$(((i + 1) % ${#chars}))
        sleep 0.1
    done
    
    # Clear the line and show completion
    printf "\r${GREEN}${ICON_SUCCESS}${RESET} %s completed\n" "$message"
}

# Banner display with system information
display_banner() {
    clear
    cat << 'EOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                              â•‘
â•‘  â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â•‘
â•‘  â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•”â•     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•‘
â•‘  â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•‘
â•‘  â•šâ•â•  â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â• â•‘
â•‘                                                                              â•‘
â•‘                 ENHANCED ARCH SECURITY TESTING SUITE                        â•‘
â•‘                      Version 0.2.0 "Phoenix"                               â•‘
â•‘                   Engineered by 0xb0rn3 | @theehiv3                        â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

    echo
    echo -e "${CYAN}${BOLD}System Information:${RESET}"
    echo -e "  ${WHITE}â€¢${RESET} OS: $(get_system_info)"
    echo -e "  ${WHITE}â€¢${RESET} Kernel: $(uname -r)"
    echo -e "  ${WHITE}â€¢${RESET} Architecture: $(uname -m)"
    echo -e "  ${WHITE}â€¢${RESET} User: $ORIGINAL_USER"
    echo -e "  ${WHITE}â€¢${RESET} Python: $(get_python_version)"
    echo
}

# System information gathering
get_system_info() {
    if [[ -f /etc/os-release ]]; then
        grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2
    else
        echo "Unknown Linux Distribution"
    fi
}

get_python_version() {
    if command -v python3 &>/dev/null; then
        python3 --version | cut -d' ' -f2
    else
        echo "Not installed"
    fi
}

# =============================================================================
# SYSTEM VALIDATION AND REQUIREMENTS
# =============================================================================

# Comprehensive system validation
validate_system() {
    log_message "INFO" "Validating system requirements..."
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    
    # Validate original user
    if [[ -z "$ORIGINAL_USER" || "$ORIGINAL_USER" == "root" ]]; then
        error_exit "Cannot determine original user. Please run with 'sudo $0'"
    fi
    
    # Check for Arch-based system
    if ! command -v pacman &>/dev/null; then
        if command -v apt &>/dev/null; then
            error_exit "Debian-based system detected. Use KRILIN instead: https://github.com/0xb0rn3/krilin"
        else
            error_exit "This tool requires an Arch-based distribution with pacman"
        fi
    fi
    
    # Check internet connectivity
    if ! ping -c 1 -W 3 archlinux.org &>/dev/null; then
        error_exit "Internet connectivity required for package downloads"
    fi
    
    # Check available disk space (minimum 5GB)
    local available_space
    available_space=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $available_space -lt 5 ]]; then
        log_message "WARNING" "Only ${available_space}GB available. Some installations may fail."
        if [[ "$INTERACTIVE_MODE" == "true" ]]; then
            read -p "Continue anyway? [y/N]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                exit 0
            fi
        fi
    fi
    
    log_message "SUCCESS" "System validation completed"
}

# Install required dependencies
install_dependencies() {
    log_message "INFO" "Installing required dependencies..."
    
    local required_packages=(
        "curl"
        "wget" 
        "git"
        "python"
        "python-pip"
        "python-requests"
        "python-beautifulsoup4"
        "python-lxml"
        "base-devel"
        "pacman-contrib"
    )
    
    local missing_packages=()
    
    # Check for missing packages
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    # Install missing packages
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        log_message "INFO" "Installing missing packages: ${missing_packages[*]}"
        
        # Update package database first
        pacman -Sy --noconfirm
        
        # Install packages with error handling
        if ! pacman -S --noconfirm --needed "${missing_packages[@]}"; then
            error_exit "Failed to install required dependencies"
        fi
        
        log_message "SUCCESS" "Dependencies installed successfully"
    else
        log_message "SUCCESS" "All dependencies already satisfied"
    fi
}

# =============================================================================
# BLACKARCH REPOSITORY MANAGEMENT
# =============================================================================

# Setup BlackArch repository with enhanced error handling
setup_blackarch_repo() {
    log_message "INFO" "Setting up BlackArch repository..."
    
    # Check if already configured
    if grep -q "\[blackarch\]" /etc/pacman.conf; then
        log_message "INFO" "BlackArch repository already configured"
        return 0
    fi
    
    # Download and execute strap script with error handling
    local temp_script="/tmp/blackarch-strap.sh"
    
    if ! curl -fsSL "$BLACKARCH_REPO_URL" -o "$temp_script" --connect-timeout "$DOWNLOAD_TIMEOUT"; then
        error_exit "Failed to download BlackArch strap script"
    fi
    
    # Verify script integrity (basic check)
    if [[ ! -s "$temp_script" ]]; then
        error_exit "Downloaded strap script is empty or corrupted"
    fi
    
    # Execute strap script
    if ! bash "$temp_script" &>/dev/null; then
        error_exit "Failed to execute BlackArch strap script"
    fi
    
    # Clean up
    rm -f "$temp_script"
    
    # Update package database
    if ! pacman -Sy --noconfirm; then
        error_exit "Failed to update package database after BlackArch setup"
    fi
    
    log_message "SUCCESS" "BlackArch repository configured successfully"
}

# Dynamic BlackArch package discovery using Python
create_package_scraper() {
    cat > "$CACHE_DIR/blackarch_scraper.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
KYGOX BlackArch Package Scraper
Dynamically discovers available BlackArch packages and categorizes them
"""

import sys
import json
import subprocess
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple
import time

try:
    import requests
    from bs4 import BeautifulSoup
except ImportError:
    print("Error: Required Python packages not installed", file=sys.stderr)
    sys.exit(1)

class BlackArchScraper:
    def __init__(self):
        self.base_url = "https://blackarch.org"
        self.tools_url = f"{self.base_url}/tools.html"
        self.packages = {}
        self.categories = {}
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'KYGOX-PackageScraper/0.2.0'
        })
    
    def get_pacman_packages(self) -> Set[str]:
        """Get available BlackArch packages from pacman database"""
        try:
            result = subprocess.run(
                ['pacman', '-Sql', 'blackarch'],
                capture_output=True,
                text=True,
                check=True
            )
            return set(result.stdout.strip().split('\n')) if result.stdout.strip() else set()
        except (subprocess.CalledProcessError, FileNotFoundError):
            return set()
    
    def scrape_web_tools(self) -> Dict[str, List[str]]:
        """Scrape BlackArch website for tool categories"""
        try:
            response = self.session.get(self.tools_url, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            categories = {}
            
            # Find tool categories and packages
            for section in soup.find_all(['div', 'section'], class_=re.compile('category|tools')):
                category_name = None
                tools = []
                
                # Extract category name
                header = section.find(['h1', 'h2', 'h3', 'h4'])
                if header:
                    category_name = header.get_text().strip()
                
                # Extract tool names
                for link in section.find_all('a', href=re.compile(r'/tools/')):
                    tool_name = link.get_text().strip()
                    if tool_name and len(tool_name) > 1:
                        tools.append(tool_name)
                
                if category_name and tools:
                    categories[category_name] = tools
            
            return categories
            
        except Exception as e:
            print(f"Web scraping failed: {e}", file=sys.stderr)
            return {}
    
    def get_package_info(self, package: str) -> Dict:
        """Get detailed package information"""
        try:
            result = subprocess.run(
                ['pacman', '-Si', package],
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode == 0:
                info = {}
                for line in result.stdout.split('\n'):
                    if ':' in line:
                        key, value = line.split(':', 1)
                        info[key.strip()] = value.strip()
                return info
            return {}
            
        except Exception:
            return {}
    
    def categorize_packages(self, packages: Set[str]) -> Dict[str, List[str]]:
        """Categorize packages by type/purpose"""
        categories = {
            'Information Gathering': [],
            'Vulnerability Analysis': [],
            'Web Application Analysis': [],
            'Database Assessment': [],
            'Password Attacks': [],
            'Wireless Attacks': [],
            'Exploitation Tools': [],
            'Sniffing & Spoofing': [],
            'Post Exploitation': [],
            'Forensics': [],
            'Crypto & Stego': [],
            'Social Engineering': [],
            'Miscellaneous': []
        }
        
        # Define keyword patterns for categorization
        patterns = {
            'Information Gathering': ['nmap', 'recon', 'enum', 'scan', 'discover', 'finger', 'whois'],
            'Vulnerability Analysis': ['vuln', 'cve', 'exploit-db', 'nikto', 'openvas', 'lynis'],
            'Web Application Analysis': ['web', 'http', 'burp', 'zap', 'dir', 'url', 'spider'],
            'Database Assessment': ['sql', 'db', 'mysql', 'oracle', 'mongo', 'database'],
            'Password Attacks': ['pass', 'hash', 'crack', 'brute', 'john', 'hydra', 'medusa'],
            'Wireless Attacks': ['wifi', 'wireless', 'air', 'bluetooth', 'rfid', '802.11'],
            'Exploitation Tools': ['exploit', 'shell', 'payload', 'metasploit', 'framework'],
            'Sniffing & Spoofing': ['sniff', 'capture', 'spoof', 'mitm', 'proxy', 'wireshark'],
            'Post Exploitation': ['post', 'pivot', 'tunnel', 'persistence', 'escalat'],
            'Forensics': ['forensic', 'recover', 'carve', 'timeline', 'memory', 'disk'],
            'Crypto & Stego': ['crypto', 'stego', 'cipher', 'encode', 'decode', 'hash'],
            'Social Engineering': ['social', 'phish', 'se-', 'fake', 'clone']
        }
        
        # Categorize each package
        for package in packages:
            categorized = False
            package_lower = package.lower()
            
            for category, keywords in patterns.items():
                if any(keyword in package_lower for keyword in keywords):
                    categories[category].append(package)
                    categorized = True
                    break
            
            if not categorized:
                categories['Miscellaneous'].append(package)
        
        # Remove empty categories and sort packages
        return {cat: sorted(pkgs) for cat, pkgs in categories.items() if pkgs}
    
    def generate_package_database(self) -> Dict:
        """Generate comprehensive package database"""
        print("Discovering BlackArch packages...", file=sys.stderr)
        
        # Get packages from pacman
        pacman_packages = self.get_pacman_packages()
        print(f"Found {len(pacman_packages)} packages in pacman database", file=sys.stderr)
        
        # Scrape web for additional info
        web_categories = self.scrape_web_tools()
        print(f"Found {len(web_categories)} categories from web", file=sys.stderr)
        
        # Categorize packages
        categorized_packages = self.categorize_packages(pacman_packages)
        
        # Build final database
        database = {
            'metadata': {
                'timestamp': int(time.time()),
                'total_packages': len(pacman_packages),
                'categories': len(categorized_packages),
                'scraper_version': '0.2.0'
            },
            'packages': {
                'by_category': categorized_packages,
                'all_packages': sorted(list(pacman_packages))
            },
            'web_categories': web_categories
        }
        
        return database

def main():
    cache_dir = sys.argv[1] if len(sys.argv) > 1 else '/tmp/kygox_cache'
    Path(cache_dir).mkdir(exist_ok=True)
    
    scraper = BlackArchScraper()
    database = scraper.generate_package_database()
    
    # Save to file
    output_file = Path(cache_dir) / 'blackarch_packages.json'
    with open(output_file, 'w') as f:
        json.dump(database, f, indent=2)
    
    print(f"Package database saved to {output_file}", file=sys.stderr)
    print(json.dumps(database, indent=2))

if __name__ == "__main__":
    main()
PYTHON_SCRIPT
}

# Update package database with real-time scraping
update_package_database() {
    log_message "INFO" "Updating BlackArch package database..."
    
    mkdir -p "$CACHE_DIR"
    
    # Create Python scraper
    create_package_scraper
    
    # Run scraper with progress indication
    (
        python3 "$CACHE_DIR/blackarch_scraper.py" "$CACHE_DIR" > "$CACHE_DIR/blackarch_packages.json" 2>"$CACHE_DIR/scraper.log"
    ) &
    
    local scraper_pid=$!
    show_progress "$scraper_pid" "Scanning BlackArch repositories"
    
    # Check if scraper completed successfully
    if ! wait "$scraper_pid"; then
        log_message "WARNING" "Package database update failed, using cached data"
        if [[ ! -f "$CACHE_DIR/blackarch_packages.json" ]]; then
            create_fallback_database
        fi
    else
        log_message "SUCCESS" "Package database updated successfully"
    fi
    
    # Load package data into memory
    load_package_database
}

# Create fallback database if scraping fails
create_fallback_database() {
    log_message "INFO" "Creating fallback package database..."
    
    cat > "$CACHE_DIR/blackarch_packages.json" << 'EOF'
{
  "metadata": {
    "timestamp": 1672531200,
    "total_packages": 2800,
    "categories": 12,
    "scraper_version": "0.2.0-fallback"
  },
  "packages": {
    "by_category": {
      "Information Gathering": [
        "nmap", "masscan", "zmap", "rustscan", "unicornscan",
        "dnsrecon", "dnsenum", "fierce", "sublist3r", "amass",
        "theharvester", "recon-ng", "maltego", "shodan", "spiderfoot"
      ],
      "Vulnerability Analysis": [
        "nikto", "dirb", "gobuster", "wfuzz", "ffuf",
        "sqlmap", "wpscan", "joomscan", "cmsmap",
        "lynis", "openvas", "nuclei", "skipfish"
      ],
      "Web Application Analysis": [
        "burpsuite", "zaproxy", "w3af", "arachni",
        "davtest", "cadaver", "padbuster", "webscarab"
      ],
      "Password Attacks": [
        "john", "hashcat", "hydra", "medusa", "ncrack",
        "crunch", "cewl", "wordlists", "hashid"
      ],
      "Wireless Attacks": [
        "aircrack-ng", "wifite", "reaver", "bully", "pixiewps",
        "kismet", "horst", "cowpatty", "asleap"
      ],
      "Exploitation Tools": [
        "metasploit", "exploitdb", "searchsploit", "set",
        "beef", "armitage", "empire", "shellter"
      ]
    }
  }
}
EOF
}

# Load package database into memory for faster access
load_package_database() {
    if [[ -f "$CACHE_DIR/blackarch_packages.json" ]]; then
        # Extract categories and packages for bash arrays
        python3 -c "
import json
import sys

with open('$CACHE_DIR/blackarch_packages.json') as f:
    data = json.load(f)

categories = data['packages']['by_category']
for category, packages in categories.items():
    print(f'CATEGORY_{category.upper().replace(\" \", \"_\").replace(\"-\", \"_\")}=({\" \".join(packages)})')
" > "$CACHE_DIR/package_vars.sh"
        
        # Source the variables
        source "$CACHE_DIR/package_vars.sh" 2>/dev/null || true
        
        log_message "SUCCESS" "Package database loaded into memory"
    else
        log_message "ERROR" "Package database not found"
    fi
}

# =============================================================================
# PACKAGE INSTALLATION ENGINE
# =============================================================================

# Check package availability and status
check_package_availability() {
    local package="$1"
    local status=""
    
    # Check if already installed
    if pacman -Qi "$package" &>/dev/null; then
        status="installed"
    # Check if available in BlackArch
    elif pacman -Si "$package" &>/dev/null 2>&1; then
        status="available"
    else
        status="unavailable"
    fi
    
    echo "$status"
}

# Enhanced package installer with parallel processing
install_packages() {
    local packages=("$@")
    local total_packages=${#packages[@]}
    
    if [[ $total_packages -eq 0 ]]; then
        log_message "WARNING" "No packages specified for installation"
        return 0
    fi
    
    log_message "INFO" "Installing $total_packages packages..."
    
    # Create installation status tracking
    local installed_count=0
    local failed_count=0
    local skipped_count=0
    
    # Process packages in parallel batches
    local batch_size=$PARALLEL_JOBS
    local batch_num=1
    
    for ((i=0; i<total_packages; i+=batch_size)); do
        local batch=("${packages[@]:i:batch_size}")
        local pids=()
        
        log_message "INFO" "Processing batch $batch_num (${#batch[@]} packages)..."
        
        # Start parallel installations
        for package in "${batch[@]}"; do
            {
                local status
                status=$(check_package_availability "$package")
                
                case "$status" in
                    "installed")
                        log_message "INFO" "$package already installed"
                        echo "SKIPPED:$package" >> "$CACHE_DIR/install_results.tmp"
                        ;;
                    "available")
                        if install_single_package "$package"; then
                            echo "SUCCESS:$package" >> "$CACHE_DIR/install_results.tmp"
                        else
                            echo "FAILED:$package" >> "$CACHE_DIR/install_results.tmp"
                        fi
                        ;;
                    "unavailable")
                        log_message "WARNING" "$package not available in repositories"
                        echo "UNAVAILABLE:$package" >> "$CACHE_DIR/install_results.tmp"
                        ;;
                esac
            } &
            
            pids+=($!)
        done
        
        # Wait for batch completion
        for pid in "${pids[@]}"; do
            wait "$pid"
        done
        
        ((batch_num++))
    done
    
    # Process results
    if [[ -f "$CACHE_DIR/install_results.tmp" ]]; then
        while IFS=':' read -r status package; do
            case "$status" in
                "SUCCESS") ((installed_count++)) ;;
                "FAILED") ((failed_count++)) ;;
                "SKIPPED") ((skipped_count++)) ;;
                "UNAVAILABLE") ((failed_count++)) ;;
            esac
        done < "$CACHE_DIR/install_results.tmp"
        
        rm -f "$CACHE_DIR/install_results.tmp"
    fi
    
    # Report results
    log_message "SUCCESS" "Installation completed:"
    echo -e "  ${GREEN}${ICON_SUCCESS}${RESET} Installed: $installed_count"
    echo -e "  ${YELLOW}${ICON_WARNING}${RESET} Skipped: $skipped_count"
    echo -e "  ${RED}${ICON_ERROR}${RESET} Failed: $failed_count"
}

# Install single package with error handling
install_single_package() {
    local package="$1"
    local max_retries=3
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        if [[ "$DRY_RUN" == "true" ]]; then
            log_message "INFO" "[DRY RUN] Would install: $package"
            return 0
        fi
        
        log_message "DEBUG" "Installing $package (attempt $((retry_count + 1)))"
        
        # Install with timeout and error handling
        if timeout "$INSTALL_TIMEOUT" pacman -S --noconfirm --needed "$package" &>/dev/null; then
            log_message "SUCCESS" "Installed: $package"
            return 0
        else
            ((retry_count++))
            log_message "WARNING" "Installation failed for $package (attempt $retry_count)"
            
            if [[ $retry_count -lt $max_retries ]]; then
                sleep 2
            fi
        fi
    done
    
    log_message "ERROR" "Failed to install $package after $max_retries attempts"
    return 1
}

# =============================================================================
# USER INTERFACE AND MENUS
# =============================================================================

# Enhanced interactive menu system
show_main_menu() {
    echo -e "${CYAN}${BOLD}KYGOX Security Toolkit Selection${RESET}"
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo
    echo -e "${GREEN}${BOLD}Package Categories:${RESET}"
    echo -e "  ${CYAN}1${RESET}) ${ICON_TOOLS} Information Gathering     ${DIM}Network reconnaissance and OSINT${RESET}"
    echo -e "  ${CYAN}2${RESET}) ${ICON_SHIELD} Vulnerability Analysis   ${DIM}Security assessment tools${RESET}"
    echo -e "  ${CYAN}3${RESET}) ${ICON_ROCKET} Web Application Analysis ${DIM}Web security testing${RESET}"
    echo -e "  ${CYAN}4${RESET}) ${ICON_TOOLS} Password Attacks          ${DIM}Password cracking and analysis${RESET}"
    echo -e "  ${CYAN}5${RESET}) ${ICON_SHIELD} Wireless Attacks          ${DIM}WiFi and wireless security${RESET}"
    echo -e "  ${CYAN}6${RESET}) ${ICON_ROCKET} Exploitation Tools        ${DIM}Penetration testing frameworks${RESET}"
    echo
    echo -e "${YELLOW}${BOLD}Special Options:${RESET}"
    echo -e "  ${CYAN}7${RESET}) ${ICON_TOOLS} Custom Package Selection  ${DIM}Choose specific tools${RESET}"
    echo -e "  ${CYAN}8${RESET}) ${ICON_SHIELD} Complete BlackArch Suite ${DIM}Install all available tools${RESET}"
    echo -e "  ${CYAN}9${RESET}) ${ICON_ROCKET} System Information        ${DIM}View detailed system info${RESET}"
    echo
    echo -e "${RED}${BOLD}Management:${RESET}"
    echo -e "  ${CYAN}u${RESET}) Update package database    ${CYAN}c${RESET}) Cleanup system"
    echo -e "  ${CYAN}q${RESET}) Quit                       ${CYAN}h${RESET}) Help"
    echo
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
}

# Handle menu selections
handle_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        1) install_category "INFORMATION_GATHERING" ;;
        2) install_category "VULNERABILITY_ANALYSIS" ;;
        3) install_category "WEB_APPLICATION_ANALYSIS" ;;
        4) install_category "PASSWORD_ATTACKS" ;;
        5) install_category "WIRELESS_ATTACKS" ;;
        6) install_category "EXPLOITATION_TOOLS" ;;
        7) custom_package_selection ;;
        8) install_complete_suite ;;
        9) show_detailed_system_info ;;
        u|U) update_package_database ;;
        c|C) cleanup_system ;;
        h|H) show_help ;;
        q|Q) exit 0 ;;
        *) 
            log_message "ERROR" "Invalid selection: $choice"
            return 1
            ;;
    esac
}

# Install packages from a specific category
install_category() {
    local category="$1"
    local var_name="CATEGORY_$category"
    
    # Use indirect variable expansion to get package list
    local -n packages_ref="$var_name"
    local packages=("${packages_ref[@]}")
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        log_message "WARNING" "No packages found for category: $category"
        return 1
    fi
    
    echo -e "${CYAN}${BOLD}Installing ${category//[_]/ } Tools${RESET}"
    echo -e "${WHITE}Packages: ${packages[*]}${RESET}"
    echo
    
    if [[ "$INTERACTIVE_MODE" == "true" ]]; then
        read -p "Proceed with installation? [Y/n]: " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            log_message "INFO" "Installation cancelled"
            return 0
        fi
    fi
    
    install_packages "${packages[@]}"
}

# Custom package selection interface
custom_package_selection() {
    echo -e "${CYAN}${BOLD}Custom Package Selection${RESET}"
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo
    echo -e "${YELLOW}Enter package names separated by spaces.${RESET}"
    echo -e "${DIM}Example: nmap nikto sqlmap burpsuite metasploit${RESET}"
    echo
    
    read -p "Packages to install: " -r packages_input
    
    if [[ -n "$packages_input" ]]; then
        # Convert input to array
        read -ra selected_packages <<< "$packages_input"
        
        echo -e "\n${CYAN}Selected packages:${RESET}"
        for package in "${selected_packages[@]}"; do
            local status
            status=$(check_package_availability "$package")
            case "$status" in
                "installed") echo -e "  ${GREEN}${ICON_SUCCESS}${RESET} $package (already installed)" ;;
                "available") echo -e "  ${CYAN}${ICON_INFO}${RESET} $package (available)" ;;
                "unavailable") echo -e "  ${RED}${ICON_ERROR}${RESET} $package (not found)" ;;
            esac
        done
        
        echo
        read -p "Proceed with installation? [Y/n]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_packages "${selected_packages[@]}"
        fi
    else
        log_message "WARNING" "No packages specified"
    fi
}

# Install complete BlackArch suite with warnings
install_complete_suite() {
    echo -e "${RED}${BOLD}WARNING: Complete BlackArch Suite Installation${RESET}"
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo
    echo -e "${YELLOW}This will install ALL available BlackArch packages:${RESET}"
    echo -e "  ${RED}â€¢${RESET} 2000+ security tools and utilities"
    echo -e "  ${RED}â€¢${RESET} Requires 15+ GB of disk space"
    echo -e "  ${RED}â€¢${RESET} Installation may take several hours"
    echo -e "  ${RED}â€¢${RESET} May cause system conflicts"
    echo
    echo -e "${RED}${BOLD}This is NOT recommended for production systems!${RESET}"
    echo
    
    read -p "Type 'INSTALL ALL TOOLS' to proceed: " -r confirmation
    
    if [[ "$confirmation" == "INSTALL ALL TOOLS" ]]; then
        log_message "INFO" "Installing complete BlackArch suite..."
        
        # Get all available packages
        local all_packages
        all_packages=$(pacman -Slq blackarch)
        
        if [[ -n "$all_packages" ]]; then
            # Convert to array
            readarray -t package_array <<< "$all_packages"
            install_packages "${package_array[@]}"
        else
            log_message "ERROR" "Could not retrieve BlackArch package list"
        fi
    else
        log_message "INFO" "Complete suite installation cancelled"
    fi
}

# =============================================================================
# SYSTEM INFORMATION AND UTILITIES
# =============================================================================

# Show detailed system information
show_detailed_system_info() {
    echo -e "${CYAN}${BOLD}Detailed System Information${RESET}"
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo
    
    # Hardware Information
    echo -e "${YELLOW}${BOLD}Hardware:${RESET}"
    echo -e "  CPU: $(cat /proc/cpuinfo | grep 'model name' | head -1 | cut -d':' -f2 | xargs)"
    echo -e "  Cores: $(nproc)"
    echo -e "  Memory: $(free -h | grep '^Mem:' | awk '{print $2 " total, " $3 " used, " $7 " available"}')"
    echo -e "  Storage: $(df -h / | tail -1 | awk '{print $2 " total, " $3 " used, " $4 " available (" $5 " used)"}')"
    echo
    
    # System Information
    echo -e "${YELLOW}${BOLD}System:${RESET}"
    echo -e "  Distribution: $(get_system_info)"
    echo -e "  Kernel: $(uname -r)"
    echo -e "  Architecture: $(uname -m)"
    echo -e "  Uptime: $(uptime -p)"
    echo -e "  Load Average: $(uptime | awk -F'load average:' '{print $2}')"
    echo
    
    # Package Information
    echo -e "${YELLOW}${BOLD}Package Management:${RESET}"
    echo -e "  Total Packages: $(pacman -Q | wc -l)"
    if pacman -Sl blackarch &>/dev/null; then
        echo -e "  BlackArch Available: $(pacman -Sl blackarch | wc -l)"
        echo -e "  BlackArch Installed: $(pacman -Q | grep -c blackarch || echo "0")"
    else
        echo -e "  BlackArch: Not configured"
    fi
    echo
    
    # Network Information
    echo -e "${YELLOW}${BOLD}Network:${RESET}"
    echo -e "  Hostname: $(hostname)"
    echo -e "  IP Address: $(ip route get 1.1.1.1 | grep -oP 'src \K\S+' 2>/dev/null || echo "Not available")"
    echo -e "  DNS Servers: $(grep '^nameserver' /etc/resolv.conf | awk '{print $2}' | tr '\n' ' ')"
    echo
    
    # KYGOX Information
    echo -e "${YELLOW}${BOLD}KYGOX Status:${RESET}"
    echo -e "  Version: $SCRIPT_VERSION ($SCRIPT_CODENAME)"
    echo -e "  Cache Directory: $CACHE_DIR"
    echo -e "  Log Directory: $LOG_DIR"
    if [[ -f "$CACHE_DIR/blackarch_packages.json" ]]; then
        local db_timestamp
        db_timestamp=$(python3 -c "import json; print(json.load(open('$CACHE_DIR/blackarch_packages.json'))['metadata']['timestamp'])" 2>/dev/null || echo "0")
        echo -e "  Package DB: $(date -d "@$db_timestamp" 2>/dev/null || echo "Unknown")"
    else
        echo -e "  Package DB: Not available"
    fi
    echo
}

# System cleanup utilities
cleanup_system() {
    echo -e "${CYAN}${BOLD}System Cleanup${RESET}"
    echo -e "${WHITE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo
    
    log_message "INFO" "Starting system cleanup..."
    
    # Clean package cache
    log_message "INFO" "Cleaning package cache..."
    pacman -Scc --noconfirm
    
    # Remove orphaned packages
    local orphans
    orphans=$(pacman -Qtdq 2>/dev/null || true)
    if [[ -n "$orphans" ]]; then
        log_message "INFO" "Removing orphaned packages..."
        pacman -Rns --noconfirm $orphans
    else
        log_message "INFO" "No orphaned packages found"
    fi
    
    # Clean KYGOX cache
    if [[ -d "$CACHE_DIR" ]]; then
        log_message "INFO" "Cleaning KYGOX cache..."
        find "$CACHE_DIR" -type f -name "*.tmp" -delete 2>/dev/null || true
        find "$CACHE_DIR" -type f -mtime +7 -delete 2>/dev/null || true
    fi
    
    # Clean old logs
    if [[ -d "$LOG_DIR" ]]; then
        log_message "INFO" "Cleaning old logs..."
        find "$LOG_DIR" -type f -name "*.log" -mtime +30 -delete 2>/dev/null || true
    fi
    
    log_message "SUCCESS" "System cleanup completed"
}

# =============================================================================
# HELP AND DOCUMENTATION
# =============================================================================

show_help() {
    cat << 'HELP_TEXT'

KYGOX Enhanced Security Toolkit v0.2.0 "Phoenix"
==================================================

DESCRIPTION:
    KYGOX is an advanced security testing suite for Arch Linux systems that 
    provides seamless integration with BlackArch repositories, intelligent 
    package management, and comprehensive penetration testing tools.

USAGE:
    sudo ./kygox [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be installed without installing
    -f, --force            Force installation of packages
    -j, --jobs N           Set number of parallel installation jobs
    -q, --quiet            Disable interactive prompts
    --no-cleanup           Skip automatic cleanup after installation
    --update-db            Update package database and exit

EXAMPLES:
    sudo ./kygox                    # Interactive mode
    sudo ./kygox -v                 # Verbose interactive mode
    sudo ./kygox --dry-run          # Preview installations
    sudo ./kygox -j 4 -q            # 4 parallel jobs, no prompts

CATEGORIES:
    1. Information Gathering    - Network reconnaissance and OSINT tools
    2. Vulnerability Analysis   - Security assessment and scanning tools  
    3. Web Application Analysis - Web security testing frameworks
    4. Password Attacks         - Password cracking and analysis tools
    5. Wireless Attacks         - WiFi and wireless security tools
    6. Exploitation Tools       - Penetration testing frameworks

FEATURES:
    â€¢ Real-time BlackArch repository scraping
    â€¢ Intelligent package availability checking
    â€¢ Parallel installation processing
    â€¢ Comprehensive error handling and recovery
    â€¢ Detailed system information and monitoring
    â€¢ Advanced cleanup and maintenance utilities

REQUIREMENTS:
    â€¢ Arch Linux or Arch-based distribution
    â€¢ Root privileges (sudo)
    â€¢ Internet connection
    â€¢ 5GB+ free disk space

SUPPORT:
    â€¢ Repository: https://github.com/0xb0rn3/kygox
    â€¢ Issues: https://github.com/0xb0rn3/kygox/issues
    â€¢ Author: 0xb0rn3 (IG: theehiv3, X: 0xbv1)

HELP_TEXT
}

# =============================================================================
# COMMAND LINE ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            -j|--jobs)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    PARALLEL_JOBS="$2"
                    shift 2
                else
                    error_exit "Invalid jobs value: $2"
                fi
                ;;
            -q|--quiet)
                INTERACTIVE_MODE=false
                shift
                ;;
            --no-cleanup)
                CLEANUP_AFTER=false
                shift
                ;;
            --update-db)
                setup_blackarch_repo
                update_package_database
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

# =============================================================================
# CLEANUP AND ERROR HANDLING
# =============================================================================

cleanup_on_exit() {
    local exit_code="${1:-0}"
    
    log_message "INFO" "Performing cleanup operations..."
    
    # Kill any background processes
    jobs -p 2>/dev/null | xargs -r kill 2>/dev/null || true
    
    # Clean temporary files
    rm -f "$CACHE_DIR"/*.tmp 2>/dev/null || true
    
    # System cleanup if enabled
    if [[ "$CLEANUP_AFTER" == "true" && "$exit_code" -eq 0 ]]; then
        log_message "INFO" "Performing automatic cleanup..."
        pacman -Scc --noconfirm &>/dev/null || true
    fi
    
    log_message "INFO" "KYGOX session ended"
    exit "$exit_code"
}

# Signal handlers
trap 'cleanup_on_exit 130' INT TERM
trap 'cleanup_on_exit $?' EXIT

# =============================================================================
# MAIN EXECUTION FUNCTION
# =============================================================================

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Display banner
    display_banner
    
    # System validation and setup
    validate_system
    install_dependencies
    setup_blackarch_repo
    update_package_database
    
    # Show initial status
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}DRY RUN MODE - No packages will be installed${RESET}"
        echo
    fi
    
    # Main interactive loop
    if [[ "$INTERACTIVE_MODE" == "true" ]]; then
        while true; do
            show_main_menu
            read -p "Select option: " -r choice
            echo
            
            if ! handle_menu_selection "$choice"; then
                echo -e "${RED}Invalid selection. Please try again.${RESET}"
                sleep 1
            fi
            
            echo
        done
    else
        log_message "INFO" "Non-interactive mode - use menu options as command line arguments"
        show_main_menu
    fi
}

# Execute main function with all arguments
main "$@"
