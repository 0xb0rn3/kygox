#!/usr/bin/env bash

set -euo pipefail

# CONFIGURATION
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_CODENAME="Phantom"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$USER_HOME/.kygox"
readonly CACHE_DIR="/tmp/kygox_cache_$$"
readonly CONFIG_DIR="$USER_HOME/.config/kygox"
readonly STATE_FILE="$CONFIG_DIR/kygox_state.json"
readonly BACKUP_DIR="$CONFIG_DIR/backups"

# BlackArch Configuration
readonly BLACKARCH_KEYRING_VERSION="20251011"
readonly BLACKARCH_GPG_KEY="4345771566D76038C7FEB43863EC0ADBEA87E4E3"
readonly BLACKARCH_MIRROR_URL="https://blackarch.org/blackarch-mirrorlist"
readonly BLACKARCH_TOOLS_URL="https://www.blackarch.org/tools.html"
readonly BLACKARCH_REPO_URL="https://blackarch.org/strap.sh"

# Colors and UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Global State
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g AUTO_FIX=true
declare -g TOTAL_AVAILABLE_TOOLS=0
declare -g OLD_UMASK=""

# Enhanced Tool Categories with BlackArch groups
declare -A CATEGORIES=(
    ["1"]="information-gathering:Information Gathering:blackarch-scanner,blackarch-recon,blackarch-fingerprint"
    ["2"]="vulnerability-analysis:Vulnerability Analysis:blackarch-scanner,blackarch-fuzzer,blackarch-exploitation"
    ["3"]="web-applications:Web Application Analysis:blackarch-webapp,blackarch-proxy,blackarch-scanner"
    ["4"]="password-attacks:Password Attacks:blackarch-cracker,blackarch-password,blackarch-crypto"
    ["5"]="wireless-attacks:Wireless Attacks:blackarch-wireless,blackarch-bluetooth,blackarch-nfc"
    ["6"]="exploitation:Exploitation Tools:blackarch-exploitation,blackarch-backdoor,blackarch-binary"
    ["7"]="forensics:Digital Forensics:blackarch-forensic,blackarch-malware,blackarch-reversing"
    ["8"]="sniffing-spoofing:Sniffing & Spoofing:blackarch-sniffer,blackarch-spoof,blackarch-proxy"
    ["9"]="post-exploitation:Post Exploitation:blackarch-backdoor,blackarch-tunnel,blackarch-keylogger"
    ["10"]="social-engineering:Social Engineering:blackarch-social,blackarch-voip"
)

log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox.log"
    
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        echo "[$level] $message" >&2
    fi
}

error_exit() {
    local message="$1"
    local exit_code="${2:-1}"
    log_message "ERROR" "$message"
    echo -e "${RED}${BOLD}[ERROR]${RESET} $message" >&2
    cleanup_on_exit "$exit_code"
}

print_banner() {
    clear
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════╗
║                                                                          ║
║           ██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗                    ║
║           ██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝                    ║
║           █████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝                     ║
║           ██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗                     ║
║           ██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗                    ║
║           ╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝                    ║
║                                                                          ║
║              kygoX - Arch Security Arsenal Manager                       ║
║                        Version 1.0.0 Phantom                             ║
║                  By 0xb0rn3 | IG: theehiv3 | X: 0xbv1                    ║
║                                                                          ║
╚══════════════════════════════════════════════════════════════════════════╝
EOF
    echo
}

display_system_info() {
    echo -e "${CYAN}${BOLD}[*] System Information:${RESET}"
    echo -e "  ${WHITE}•${RESET} OS: $(get_os_info)"
    echo -e "  ${WHITE}•${RESET} Kernel: $(uname -r)"
    echo -e "  ${WHITE}•${RESET} Architecture: $(uname -m)"
    echo -e "  ${WHITE}•${RESET} User: $ORIGINAL_USER"
    echo -e "  ${WHITE}•${RESET} Python: $(get_python_version)"
    echo
}

get_os_info() {
    if [[ -f /etc/os-release ]]; then
        grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2
    else
        echo "Unknown Linux Distribution"
    fi
}

get_python_version() {
    if command -v python &>/dev/null; then
        python --version 2>&1 | cut -d' ' -f2
    elif command -v python3 &>/dev/null; then
        python3 --version 2>&1 | cut -d' ' -f2
    else
        echo "Not installed"
    fi
}

set_secure_umask() {
    OLD_UMASK=$(umask)
    umask 0022
    log_message "DEBUG" "Set umask to 0022 (old: $OLD_UMASK)"
}

reset_umask() {
    if [[ -n "$OLD_UMASK" ]]; then
        umask "$OLD_UMASK"
        log_message "DEBUG" "Reset umask to $OLD_UMASK"
    fi
}

check_internet() {
    log_message "INFO" "Checking internet connectivity..."
    
    local test_urls=(
        "https://blackarch.org/"
        "https://archlinux.org/"
        "https://google.com/"
    )
    
    for url in "${test_urls[@]}"; do
        if curl -s --connect-timeout 8 "$url" > /dev/null 2>&1; then
            log_message "INFO" "Internet connectivity confirmed via $url"
            return 0
        fi
    done
    
    log_message "ERROR" "No internet connectivity detected"
    return 1
}

check_pacman_gnupg() {
    log_message "INFO" "Initializing pacman GPG keyring..."
    
    if [[ ! -d /etc/pacman.d/gnupg ]]; then
        echo -e "${CYAN}[*] Initializing pacman keyring...${RESET}"
        pacman-key --init 2>&1 | tee -a "$LOG_DIR/kygox.log"
        pacman-key --populate archlinux 2>&1 | tee -a "$LOG_DIR/kygox.log"
    fi
    
    # Fix common GPG issues
    if ! pacman-key --list-keys &>/dev/null; then
        echo -e "${YELLOW}[!] GPG keyring issues detected, attempting fix...${RESET}"
        
        rm -rf /etc/pacman.d/gnupg
        pacman-key --init
        pacman-key --populate archlinux
        
        # Update archlinux-keyring if needed
        pacman -Sy --noconfirm archlinux-keyring 2>&1 | tee -a "$LOG_DIR/kygox.log"
    fi
    
    return 0
}

fetch_blackarch_keyring() {
    log_message "INFO" "Fetching BlackArch keyring v${BLACKARCH_KEYRING_VERSION}..."
    
    local keyring_urls=(
        "https://www.blackarch.org/keyring/blackarch-keyring-${BLACKARCH_KEYRING_VERSION}.tar.gz"
        "https://www.blackarch.org/keyring/blackarch-keyring-${BLACKARCH_KEYRING_VERSION}.tar.gz.sig"
    )
    
    for url in "${keyring_urls[@]}"; do
        local filename=$(basename "$url")
        
        if ! curl -s -L -o "$filename" "$url"; then
            log_message "ERROR" "Failed to download $filename"
            return 1
        fi
        
        log_message "INFO" "Downloaded $filename"
    done
    
    return 0
}

verify_blackarch_keyring() {
    log_message "INFO" "Verifying BlackArch keyring signature..."
    
    local keyservers=(
        "keyserver.ubuntu.com"
        "hkps://keyserver.ubuntu.com:443"
        "hkp://pgp.mit.edu:80"
        "keys.openpgp.org"
    )
    
    # Try to receive the key from multiple servers
    local key_imported=false
    for keyserver in "${keyservers[@]}"; do
        echo -e "${CYAN}[*] Trying keyserver: $keyserver${RESET}"
        
        if gpg --keyserver "$keyserver" --recv-keys "$BLACKARCH_GPG_KEY" > /dev/null 2>&1; then
            key_imported=true
            log_message "INFO" "Successfully imported key from $keyserver"
            break
        fi
    done
    
    if [[ "$key_imported" != "true" ]]; then
        log_message "WARN" "Could not import GPG key from keyservers"
        echo -e "${YELLOW}[!] Warning: Could not verify keyring signature${RESET}"
        echo -e "${YELLOW}[!] Continuing without verification (not recommended)${RESET}"
        return 0
    fi
    
    # Verify signature
    if gpg --keyserver-options no-auto-key-retrieve \
        --with-fingerprint "blackarch-keyring-${BLACKARCH_KEYRING_VERSION}.tar.gz.sig" \
        > /dev/null 2>&1; then
        log_message "INFO" "Keyring signature verified successfully"
        echo -e "${GREEN}[+] Keyring signature verified${RESET}"
        return 0
    else
        log_message "WARN" "Keyring signature verification failed"
        echo -e "${YELLOW}[!] Warning: Could not verify keyring signature${RESET}"
        return 0
    fi
}

install_blackarch_keyring() {
    log_message "INFO" "Installing BlackArch keyring..."
    
    local keyring_file="blackarch-keyring-${BLACKARCH_KEYRING_VERSION}.tar.gz"
    
    if [[ ! -f "$keyring_file" ]]; then
        log_message "ERROR" "Keyring file not found: $keyring_file"
        return 1
    fi
    
    # Extract and install keyring
    tar xfz "$keyring_file" --strip-components=1 \
        -C /usr/share/pacman/keyrings/ 2>&1 | tee -a "$LOG_DIR/kygox.log"
    
    # Populate keyring
    pacman-key --populate blackarch 2>&1 | tee -a "$LOG_DIR/kygox.log"
    
    log_message "INFO" "BlackArch keyring installed successfully"
    return 0
}

fetch_blackarch_mirrorlist() {
    log_message "INFO" "Fetching BlackArch mirror list..."
    
    local mirror_path="/etc/pacman.d"
    local mirror_file="blackarch-mirrorlist"
    
    if ! curl -s "$BLACKARCH_MIRROR_URL" -o "$mirror_path/$mirror_file"; then
        log_message "ERROR" "Failed to fetch mirror list"
        return 1
    fi
    
    log_message "INFO" "Mirror list updated successfully"
    return 0
}

update_pacman_conf() {
    log_message "INFO" "Updating pacman.conf for BlackArch..."
    
    # Remove existing BlackArch entries
    sed -i '/blackarch/{N;d}' /etc/pacman.conf 2>/dev/null || true
    
    # Add BlackArch repository
    cat >> "/etc/pacman.conf" << 'EOF'

[blackarch]
Include = /etc/pacman.d/blackarch-mirrorlist
EOF
    
    log_message "INFO" "pacman.conf updated successfully"
    return 0
}

setup_blackarch_repository() {
    echo -e "${CYAN}${BOLD}[*] Setting up BlackArch Repository${RESET}"
    echo
    
    # Check if already configured
    if grep -q "\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo -e "${GREEN}[+] BlackArch repository already configured${RESET}"
        
        # Still update database
        echo -e "${CYAN}[*] Updating package databases...${RESET}"
        if pacman -Syy --noconfirm 2>&1 | tee -a "$LOG_DIR/kygox.log"; then
            echo -e "${GREEN}[+] Package databases updated${RESET}"
        fi
        
        return 0
    fi
    
    # Create temporary directory
    local tmp_dir=$(mktemp -d /tmp/blackarch_strap.XXXXXXXX)
    trap "rm -rf '$tmp_dir'" EXIT
    cd "$tmp_dir" || error_exit "Could not enter temporary directory"
    
    # Setup steps
    local setup_failed=false
    
    set_secure_umask
    
    if ! check_internet; then
        error_exit "Internet connection required"
    fi
    
    echo -e "${CYAN}[*] Checking pacman GPG configuration...${RESET}"
    check_pacman_gnupg
    
    echo -e "${CYAN}[*] Downloading BlackArch keyring...${RESET}"
    if ! fetch_blackarch_keyring; then
        setup_failed=true
    fi
    
    if [[ "$setup_failed" != "true" ]]; then
        echo -e "${CYAN}[*] Verifying keyring...${RESET}"
        verify_blackarch_keyring
        
        echo -e "${CYAN}[*] Installing keyring...${RESET}"
        if ! install_blackarch_keyring; then
            setup_failed=true
        fi
    fi
    
    if [[ "$setup_failed" != "true" ]]; then
        echo -e "${CYAN}[*] Fetching mirror list...${RESET}"
        fetch_blackarch_mirrorlist
        
        echo -e "${CYAN}[*] Updating pacman configuration...${RESET}"
        update_pacman_conf
        
        echo -e "${CYAN}[*] Synchronizing package databases...${RESET}"
        if pacman -Syy --noconfirm 2>&1 | tee -a "$LOG_DIR/kygox.log"; then
            echo -e "${GREEN}[+] Package databases synchronized${RESET}"
        fi
        
        echo -e "${CYAN}[*] Installing BlackArch mirrorlist package...${RESET}"
        pacman -S --noconfirm --needed blackarch-mirrorlist 2>&1 | tee -a "$LOG_DIR/kygox.log"
        
        # Handle pacnew file
        if [[ -f /etc/pacman.d/blackarch-mirrorlist.pacnew ]]; then
            mv /etc/pacman.d/blackarch-mirrorlist.pacnew \
                /etc/pacman.d/blackarch-mirrorlist
        fi
    fi
    
    reset_umask
    cd - > /dev/null
    
    if [[ "$setup_failed" == "true" ]]; then
        error_exit "BlackArch repository setup failed"
    fi
    
    echo
    echo -e "${GREEN}${BOLD}[+] BlackArch repository configured successfully!${RESET}"
    return 0
}

get_blackarch_tools_count() {
    if [[ $TOTAL_AVAILABLE_TOOLS -eq 0 ]]; then
        log_message "INFO" "Counting available BlackArch tools..."
        
        if pacman -Sl blackarch &>/dev/null; then
            TOTAL_AVAILABLE_TOOLS=$(pacman -Sl blackarch 2>/dev/null | wc -l)
        else
            TOTAL_AVAILABLE_TOOLS=0
        fi
        
        log_message "INFO" "Found $TOTAL_AVAILABLE_TOOLS BlackArch tools"
    fi
    
    echo $TOTAL_AVAILABLE_TOOLS
}

get_blackarch_groups() {
    log_message "INFO" "Retrieving BlackArch groups..."
    
    pacman -Sg | grep "^blackarch-" | awk '{print $1}' | sort -u
}

get_tools_in_group() {
    local group="$1"
    
    pacman -Sg "$group" 2>/dev/null | awk '{print $2}' | sort -u
}

analyze_category() {
    local category_key="$1"
    
    if [[ ! "${CATEGORIES[$category_key]:-}" ]]; then
        echo "0"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$category_key]}"
    local category_name=$(echo "$cat_info" | cut -d':' -f2)
    local blackarch_groups=$(echo "$cat_info" | cut -d':' -f3)
    
    echo -e "${CYAN}${BOLD}[*] Analyzing $category_name${RESET}"
    echo
    
    local all_tools=()
    local installed_tools=()
    local available_tools=()
    
    # Get tools from each BlackArch group
    IFS=',' read -ra GROUPS <<< "$blackarch_groups"
    for group in "${GROUPS[@]}"; do
        echo -e "${CYAN}[*] Scanning group: $group${RESET}"
        
        while IFS= read -r tool; do
            if [[ -n "$tool" ]]; then
                all_tools+=("$tool")
                
                # Check if installed
                if pacman -Qi "$tool" &>/dev/null; then
                    installed_tools+=("$tool")
                else
                    available_tools+=("$tool")
                fi
            fi
        done < <(get_tools_in_group "$group")
    done
    
    # Remove duplicates
    all_tools=($(printf '%s\n' "${all_tools[@]}" | sort -u))
    installed_tools=($(printf '%s\n' "${installed_tools[@]}" | sort -u))
    available_tools=($(printf '%s\n' "${available_tools[@]}" | sort -u))
    
    echo
    echo -e "${GREEN}${BOLD}[+] Analysis Results:${RESET}"
    echo -e "  ${WHITE}•${RESET} Total tools: ${#all_tools[@]}"
    echo -e "  ${WHITE}•${RESET} Installed: ${GREEN}${#installed_tools[@]}${RESET}"
    echo -e "  ${WHITE}•${RESET} Available: ${CYAN}${#available_tools[@]}${RESET}"
    echo
    
    if [[ ${#available_tools[@]} -gt 0 ]]; then
        echo -e "${CYAN}Available tools (showing first 20):${RESET}"
        local count=0
        for tool in "${available_tools[@]}"; do
            if [[ $count -ge 20 ]]; then
                echo -e "  ${DIM}... and $((${#available_tools[@]} - 20)) more tools${RESET}"
                break
            fi
            echo -e "  ${CYAN}•${RESET} $tool"
            ((count++))
        done
    fi
    
    if [[ ${#installed_tools[@]} -gt 0 && ${#installed_tools[@]} -le 10 ]]; then
        echo
        echo -e "${GREEN}Installed tools:${RESET}"
        for tool in "${installed_tools[@]}"; do
            echo -e "  ${GREEN}✓${RESET} $tool"
        done
    fi
    
    # Return tool lists for installation
    printf '%s\n' "${available_tools[@]}"
}

install_single_package() {
    local package="$1"
    local max_retries=3
    local retry_count=0
    
    # Check if already installed
    if pacman -Qi "$package" &>/dev/null; then
        echo -e "${GREEN}[+] $package already installed${RESET}"
        return 0
    fi
    
    while [[ $retry_count -lt $max_retries ]]; do
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "${GREEN}[+] [DRY RUN] Would install: $package${RESET}"
            return 0
        fi
        
        echo -e "${CYAN}[*] Installing $package (attempt $((retry_count + 1))/$max_retries)...${RESET}"
        
        if pacman -S --noconfirm --needed "$package" 2>&1 | tee -a "$LOG_DIR/kygox.log"; then
            echo -e "${GREEN}[+] Successfully installed $package${RESET}"
            return 0
        else
            ((retry_count++))
            
            if [[ $retry_count -lt $max_retries && "$AUTO_FIX" == "true" ]]; then
                echo -e "${YELLOW}[!] Installation failed, attempting auto-fix...${RESET}"
                
                # Fix common issues
                rm -f /var/lib/pacman/db.lck
                pacman -Sy --noconfirm 2>&1 | tee -a "$LOG_DIR/kygox.log"
                
                if [[ $retry_count -gt 1 ]]; then
                    # More aggressive fixes
                    pacman -Sc --noconfirm 2>&1 | tee -a "$LOG_DIR/kygox.log"
                    pacman-key --refresh-keys 2>&1 | tee -a "$LOG_DIR/kygox.log"
                fi
                
                sleep 2
            fi
        fi
    done
    
    echo -e "${RED}[!] Failed to install $package after $max_retries attempts${RESET}"
    return 1
}

install_category() {
    local category_key="$1"
    
    if [[ ! "${CATEGORIES[$category_key]:-}" ]]; then
        echo -e "${RED}[!] Invalid category${RESET}"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$category_key]}"
    local category_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}[*] Installing $category_name${RESET}"
    echo
    
    # Get available tools
    local available_tools=()
    mapfile -t available_tools < <(analyze_category "$category_key" 2>/dev/null | tail -n +20)
    
    if [[ ${#available_tools[@]} -eq 0 ]]; then
        echo -e "${YELLOW}[!] No tools found for installation${RESET}"
        return 1
    fi
    
    echo
    echo -e "${CYAN}[*] Installing ${#available_tools[@]} tools...${RESET}"
    echo
    
    local installed_count=0
    local failed_count=0
    local failed_packages=()
    
    for tool in "${available_tools[@]}"; do
        if install_single_package "$tool"; then
            ((installed_count++))
        else
            ((failed_count++))
            failed_packages+=("$tool")
        fi
    done
    
    echo
    echo -e "${CYAN}${BOLD}[*] Installation Summary:${RESET}"
    echo -e "  ${GREEN}✓${RESET} Installed: $installed_count"
    echo -e "  ${RED}✗${RESET} Failed: $failed_count"
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        echo
        echo -e "${YELLOW}Failed packages:${RESET}"
        for pkg in "${failed_packages[@]}"; do
            echo -e "  • $pkg"
        done
    fi
}

show_main_menu() {
    echo -e "${CYAN}${BOLD}[*] kygoX Security Arsenal${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    local total_tools=$(get_blackarch_tools_count)
    if [[ $total_tools -gt 0 ]]; then
        echo -e "${GREEN}${BOLD}📊 BlackArch Arsenal: $total_tools tools available${RESET}"
    fi
    echo
    
    echo -e "${YELLOW}${BOLD}Tool Categories:${RESET}"
    for key in $(printf '%s\n' "${!CATEGORIES[@]}" | sort -n); do
        local cat_info="${CATEGORIES[$key]}"
        local cat_name=$(echo "$cat_info" | cut -d':' -f2)
        echo -e "  ${CYAN}$key${RESET}) $cat_name"
    done
    
    echo
    echo -e "${YELLOW}${BOLD}Special Options:${RESET}"
    echo -e "  ${CYAN}a${RESET}) Install ALL BlackArch Tools"
    echo -e "  ${CYAN}g${RESET}) Browse BlackArch Groups"
    echo -e "  ${CYAN}s${RESET}) System Status"
    echo -e "  ${CYAN}q${RESET}) Quit"
    echo
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
}

handle_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        [1-9]|10)
            analyze_category "$choice"
            echo
            read -p "Install this category? [Y/n]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                install_category "$choice"
            fi
            ;;
        a|A)
            echo -e "${RED}${BOLD}[!] WARNING: This will install ALL BlackArch tools (~2000+ packages)${RESET}"
            read -p "Type 'INSTALL ALL' to confirm: " -r confirmation
            if [[ "$confirmation" == "INSTALL ALL" ]]; then
                install_all_tools
            fi
            ;;
        g|G)
            browse_blackarch_groups
            ;;
        s|S)
            show_system_status
            ;;
        q|Q)
            exit 0
            ;;
        *)
            echo -e "${RED}[!] Invalid selection${RESET}"
            return 1
            ;;
    esac
}

browse_blackarch_groups() {
    echo -e "${CYAN}${BOLD}[*] BlackArch Groups${RESET}"
    echo
    
    local groups=()
    mapfile -t groups < <(get_blackarch_groups)
    
    echo -e "${GREEN}Found ${#groups[@]} BlackArch groups:${RESET}"
    echo
    
    for group in "${groups[@]}"; do
        local tool_count=$(get_tools_in_group "$group" | wc -l)
        echo -e "  ${CYAN}•${RESET} $group ${DIM}($tool_count tools)${RESET}"
    done
}

show_system_status() {
    echo -e "${CYAN}${BOLD}[*] System Status${RESET}"
    echo
    
    echo -e "${YELLOW}Package Statistics:${RESET}"
    echo -e "  • Total packages: $(pacman -Q | wc -l)"
    echo -e "  • BlackArch tools available: $(get_blackarch_tools_count)"
    echo -e "  • BlackArch tools installed: $(pacman -Qg blackarch 2>/dev/null | wc -l)"
    echo
    
    echo -e "${YELLOW}System Resources:${RESET}"
    echo -e "  • Memory: $(free -h | grep '^Mem:' | awk '{print $3 "/" $2}')"
    echo -e "  • Disk: $(df -h / | tail -1 | awk '{print $3 "/" $2 " (" $5 ")"}')"
    echo
}

install_all_tools() {
    echo -e "${CYAN}${BOLD}[*] Installing ALL BlackArch Tools${RESET}"
    echo
    
    # Get all BlackArch packages
    local all_packages=()
    mapfile -t all_packages < <(pacman -Sl blackarch 2>/dev/null | awk '{print $2}')
    
    if [[ ${#all_packages[@]} -eq 0 ]]; then
        echo -e "${RED}[!] No BlackArch packages found${RESET}"
        return 1
    fi
    
    echo -e "${CYAN}[*] Found ${#all_packages[@]} packages to install${RESET}"
    echo -e "${YELLOW}[!] This may take several hours...${RESET}"
    echo
    
    # Install in batches
    local batch_size=50
    local total_batches=$(( (${#all_packages[@]} + batch_size - 1) / batch_size ))
    local installed=0
    local failed=0
    
    for ((i=0; i<${#all_packages[@]}; i+=batch_size)); do
        local batch=("${all_packages[@]:i:batch_size}")
        local batch_num=$(( i / batch_size + 1 ))
        
        echo -e "${CYAN}[*] Batch $batch_num/$total_batches${RESET}"
        
        for pkg in "${batch[@]}"; do
            if install_single_package "$pkg"; then
                ((installed++))
            else
                ((failed++))
            fi
        done
        
        local progress=$(( (i + batch_size) * 100 / ${#all_packages[@]} ))
        echo -e "${GREEN}[+] Progress: ${progress}% (Installed: $installed, Failed: $failed)${RESET}"
        echo
    done
    
    echo -e "${GREEN}${BOLD}[+] Installation complete!${RESET}"
    echo -e "  • Successfully installed: $installed"
    echo -e "  • Failed: $failed"
}

init_state_management() {
    mkdir -p "$CONFIG_DIR" "$BACKUP_DIR" "$LOG_DIR"
    
    if [[ ! -f "$STATE_FILE" ]]; then
        cat > "$STATE_FILE" << 'EOF'
{
    "version": "1.0.0",
    "installation_date": "",
    "blackarch_configured": false,
    "installed_categories": [],
    "installed_packages": []
}
EOF
    fi
}

save_installation_state() {
    local category="$1"
    shift
    local packages=("$@")
    
    python3 << PYTHON_SCRIPT
import json
from datetime import datetime

try:
    with open("$STATE_FILE", "r") as f:
        state = json.load(f)
except:
    state = {
        "version": "1.0.0",
        "installation_date": "",
        "blackarch_configured": True,
        "installed_categories": [],
        "installed_packages": []
    }

if not state.get("installation_date"):
    state["installation_date"] = datetime.now().isoformat()

if "$category" not in state["installed_categories"]:
    state["installed_categories"].append("$category")

for pkg in ${packages[@]}:
    if pkg not in state["installed_packages"]:
        state["installed_packages"].append(pkg)

with open("$STATE_FILE", "w") as f:
    json.dump(state, f, indent=2)
PYTHON_SCRIPT
}

validate_system() {
    echo -e "${CYAN}[*] Validating system requirements...${RESET}"
    
    # Check root privileges
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    
    # Check for Arch-based system
    if ! command -v pacman &>/dev/null; then
        error_exit "This tool requires an Arch-based distribution with pacman"
    fi
    
    # Check internet connectivity
    if ! check_internet; then
        error_exit "Internet connectivity required"
    fi
    
    # Check disk space (at least 10GB recommended)
    local available_gb=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $available_gb -lt 10 ]]; then
        echo -e "${YELLOW}[!] Warning: Only ${available_gb}GB available${RESET}"
        echo -e "${YELLOW}[!] At least 10GB recommended for full installation${RESET}"
        read -p "Continue anyway? [y/N]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
    
    echo -e "${GREEN}[+] System validation complete${RESET}"
}

install_dependencies() {
    echo -e "${CYAN}[*] Checking dependencies...${RESET}"
    
    local required_packages=("curl" "wget" "git" "python" "base-devel")
    local missing_packages=()
    
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        echo -e "${CYAN}[*] Installing missing dependencies: ${missing_packages[*]}${RESET}"
        
        if pacman -Sy --noconfirm --needed "${missing_packages[@]}" 2>&1 | tee -a "$LOG_DIR/kygox.log"; then
            echo -e "${GREEN}[+] Dependencies installed${RESET}"
        else
            error_exit "Failed to install dependencies"
        fi
    else
        echo -e "${GREEN}[+] All dependencies satisfied${RESET}"
    fi
}

cleanup_on_exit() {
    local exit_code="${1:-0}"
    
    log_message "INFO" "Performing cleanup..."
    
    # Reset umask
    reset_umask
    
    # Kill background processes
    jobs -p 2>/dev/null | xargs -r kill 2>/dev/null || true
    
    # Clean temporary files
    rm -rf "$CACHE_DIR" 2>/dev/null || true
    
    log_message "INFO" "kygoX session ended"
    exit "$exit_code"
}

fix_common_issues() {
    echo -e "${CYAN}[*] Fixing common package management issues...${RESET}"
    
    # Remove lock files
    rm -f /var/lib/pacman/db.lck
    
    # Update package databases
    pacman -Sy --noconfirm 2>&1 | tee -a "$LOG_DIR/kygox.log"
    
    # Refresh keys if needed
    if ! pacman-key --list-keys &>/dev/null; then
        pacman-key --refresh-keys 2>&1 | tee -a "$LOG_DIR/kygox.log"
    fi
    
    echo -e "${GREEN}[+] Common issues fixed${RESET}"
}

show_help() {
    cat << 'HELP_TEXT'
kygoX Elite v1.0.0 Phantom - Arch Security Arsenal Manager

USAGE:
    sudo ./kygox [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be installed without installing
    -f, --force            Force installation
    --no-auto-fix          Disable automatic error fixing
    --setup                Setup BlackArch repository only
    --update               Update BlackArch mirrorlist and databases
    --fix                  Fix common package management issues
    --stats                Show system statistics

EXAMPLES:
    sudo ./kygox                    # Interactive mode
    sudo ./kygox -v                 # Verbose interactive mode
    sudo ./kygox --setup            # Setup BlackArch only
    sudo ./kygox --update           # Update repositories
    sudo ./kygox --fix              # Fix common issues

CATEGORIES:
    1. Information Gathering    - Scanners, recon, fingerprinting
    2. Vulnerability Analysis   - Scanners, fuzzers, exploitation
    3. Web Application Analysis - Web testing, proxies, scanners
    4. Password Attacks         - Crackers, password tools
    5. Wireless Attacks         - WiFi, Bluetooth, NFC tools
    6. Exploitation Tools       - Exploits, backdoors, binaries
    7. Digital Forensics        - Forensics, malware, reversing
    8. Sniffing & Spoofing      - Sniffers, spoofers, proxies
    9. Post Exploitation        - Backdoors, tunnels, keyloggers
    10. Social Engineering      - Social engineering, VoIP

SUPPORT:
    Repository: https://github.com/0xb0rn3/kygox
    Author: 0xb0rn3 (IG: theehiv3, X: 0xbv1)
    Email: q4n0@proton.me
HELP_TEXT
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --no-auto-fix)
                AUTO_FIX=false
                shift
                ;;
            --setup)
                init_state_management
                validate_system
                install_dependencies
                setup_blackarch_repository
                exit 0
                ;;
            --update)
                pacman -Syy --noconfirm
                fetch_blackarch_mirrorlist
                exit 0
                ;;
            --fix)
                fix_common_issues
                exit 0
                ;;
            --stats)
                show_system_status
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Initialize state management
    init_state_management
    
    # Create cache directory
    mkdir -p "$CACHE_DIR"
    
    # Display banner and system info
    print_banner
    display_system_info
    
    # System validation and setup
    validate_system
    install_dependencies
    setup_blackarch_repository
    
    # Show status
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}[!] DRY RUN MODE - No packages will be installed${RESET}"
        echo
    fi
    
    # Main interactive loop
    while true; do
        show_main_menu
        read -p "Select option: " -r choice
        echo
        
        if ! handle_menu_selection "$choice"; then
            echo -e "${RED}[!] Invalid selection. Please try again.${RESET}"
            sleep 1
        fi
        
        echo
        read -p "Press Enter to continue..." -r
    done
}

# Signal handlers
trap 'cleanup_on_exit 130' INT TERM
trap 'cleanup_on_exit $?' EXIT

# Execute main function with all arguments
main "$@"
