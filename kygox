#!/usr/bin/env bash
#
# kygoX - Arch Linux Security Testing Suite
# Version 0.2.0 Phoneix
# Author: 0xb0rn3 | Contact: IG: theehiv3 | X: 0xbv1 | Email: q4n0@proton.me
#
# Advanced security toolkit installer with cleanup and auto-update features
#

set -euo pipefail

# =============================================================================
# CONFIGURATION
# =============================================================================

readonly SCRIPT_VERSION="0.3.0"
readonly SCRIPT_CODENAME="Aurora"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$HOME/.kygox"
readonly CACHE_DIR="/tmp/kygox_cache"
readonly CONFIG_DIR="$HOME/.config/kygox"
readonly STATE_FILE="$CONFIG_DIR/kygox_state.json"
readonly BACKUP_DIR="$CONFIG_DIR/backups"

# BlackArch Repository Configuration (Original)
readonly BLACKARCH_STRAP_URL="https://blackarch.org/strap.sh"
readonly BLACKARCH_KEYRING_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst"
readonly BLACKARCH_KEYRING_SIG_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst.sig"
readonly BLACKARCH_MIRROR_URL="https://blackarch.org/blackarch-mirrorlist"
readonly BLACKARCH_GPG_KEY="4345771566D76038C7FEB43863EC0ADBEA87E4E3"
readonly BLACKARCH_MIRROR_FILE="blackarch-mirrorlist"

# Auto-updater Configuration
readonly UPDATE_INTERVAL_DAYS=3
readonly UPDATER_BINARY="/usr/local/bin/kygox-updater"
readonly SYSTEMD_SERVICE_FILE="/etc/systemd/system/kygox-updater.service"
readonly SYSTEMD_TIMER_FILE="/etc/systemd/system/kygox-updater.timer"

# Colors and UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Global State
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g AUTO_FIX=true
declare -g TOTAL_AVAILABLE_TOOLS=0
declare -g OLD_UMASK=""

# Package Categories with keywords for dynamic detection
declare -A CATEGORIES=(
    ["1"]="information-gathering:Information Gathering:nmap scan recon enum discover finger whois dns"
    ["2"]="vulnerability-analysis:Vulnerability Analysis:vuln cve exploit nikto openvas lynis audit"
    ["3"]="web-applications:Web Application Analysis:web http burp zap dir url spider crawl"
    ["4"]="password-attacks:Password Attacks:pass hash crack brute john hydra medusa wordlist"
    ["5"]="wireless-attacks:Wireless Attacks:wifi wireless air bluetooth rfid 802.11"
    ["6"]="exploitation:Exploitation Tools:exploit shell payload metasploit framework beef"
    ["7"]="forensics:Digital Forensics:forensic recover carve timeline memory disk volatility"
    ["8"]="sniffing-spoofing:Sniffing & Spoofing:sniff capture spoof mitm proxy wireshark"
)

# =============================================================================
# STATE MANAGEMENT SYSTEM
# =============================================================================

# Initialize state management
init_state_management() {
    mkdir -p "$CONFIG_DIR" "$BACKUP_DIR"
    
    if [[ ! -f "$STATE_FILE" ]]; then
        cat > "$STATE_FILE" << 'EOF'
{
    "version": "0.3.0",
    "installation_date": "",
    "blackarch_configured": false,
    "installed_categories": [],
    "installed_packages": [],
    "backup_files": {},
    "auto_updater_enabled": false,
    "last_update": "",
    "installation_mode": ""
}
EOF
    fi
}

# Save installation state
save_installation_state() {
    local category="$1"
    local packages=("${@:2}")
    local timestamp=$(date -Iseconds)
    
    # Create Python script to update JSON state
    cat > "$CACHE_DIR/update_state.py" << PYTHON_SCRIPT
#!/usr/bin/env python3
import json
import sys
from datetime import datetime

def update_state(state_file, category, packages, mode="category"):
    try:
        with open(state_file, 'r') as f:
            state = json.load(f)
    except:
        state = {
            "version": "0.3.0",
            "installation_date": "",
            "blackarch_configured": False,
            "installed_categories": [],
            "installed_packages": [],
            "backup_files": {},
            "auto_updater_enabled": False,
            "last_update": "",
            "installation_mode": ""
        }
    
    # Update state
    state["installation_date"] = "$timestamp" if not state.get("installation_date") else state["installation_date"]
    state["blackarch_configured"] = True
    state["installation_mode"] = mode
    state["last_update"] = "$timestamp"
    
    if category not in state["installed_categories"]:
        state["installed_categories"].append(category)
    
    for pkg in packages:
        if pkg not in state["installed_packages"]:
            state["installed_packages"].append(pkg)
    
    with open(state_file, 'w') as f:
        json.dump(state, f, indent=2)

if __name__ == "__main__":
    category = sys.argv[1]
    packages = sys.argv[2:]
    update_state("$STATE_FILE", category, packages)
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/update_state.py"
    python3 "$CACHE_DIR/update_state.py" "$category" "${packages[@]}"
}

# Get installation state
get_installation_state() {
    if [[ -f "$STATE_FILE" ]]; then
        python3 -c "
import json
with open('$STATE_FILE', 'r') as f:
    state = json.load(f)
    print(json.dumps(state))
"
    else
        echo '{}'
    fi
}

# =============================================================================
# BACKUP AND RESTORE SYSTEM
# =============================================================================

# Create system backup before modifications
create_system_backup() {
    local backup_id="backup_$(date +%Y%m%d_%H%M%S)"
    local backup_path="$BACKUP_DIR/$backup_id"
    
    mkdir -p "$backup_path"
    
    echo -e "${CYAN}Creating system backup...${RESET}"
    
    # Backup critical system files
    local files_to_backup=(
        "/etc/pacman.conf"
        "/etc/pacman.d/mirrorlist"
        "/etc/pacman.d/blackarch-mirrorlist"
        "/var/lib/pacman/local"
    )
    
    for file in "${files_to_backup[@]}"; do
        if [[ -f "$file" || -d "$file" ]]; then
            cp -r "$file" "$backup_path/" 2>/dev/null || true
        fi
    done
    
    # Save installed package list
    pacman -Qe > "$backup_path/explicitly_installed_packages.txt"
    pacman -Q > "$backup_path/all_installed_packages.txt"
    
    # Update state with backup info
    python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
except:
    state = {}

if 'backup_files' not in state:
    state['backup_files'] = {}

state['backup_files']['$backup_id'] = {
    'path': '$backup_path',
    'created': '$(date -Iseconds)',
    'description': 'Pre-installation system backup'
}

with open('$STATE_FILE', 'w') as f:
    json.dump(state, f, indent=2)
"
    
    echo -e "${GREEN}‚úì${RESET} System backup created: $backup_id"
    echo "$backup_id"
}

# =============================================================================
# SMART CLEANUP SYSTEM
# =============================================================================

# Show cleanup menu
show_cleanup_menu() {
    echo -e "${CYAN}${BOLD}kygoX Smart Cleanup System${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo
    echo -e "  ${CYAN}1${RESET}) Remove BlackArch packages only"
    echo -e "  ${CYAN}2${RESET}) Remove BlackArch repository configuration"
    echo -e "  ${CYAN}3${RESET}) Complete system restoration (packages + config)"
    echo -e "  ${CYAN}4${RESET}) Remove specific category packages"
    echo -e "  ${CYAN}5${RESET}) Show cleanup preview (dry run)"
    echo -e "  ${CYAN}6${RESET}) Clean package cache and orphans"
    echo -e "  ${CYAN}0${RESET}) Back to main menu"
    echo
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
}

# Create comprehensive cleanup tool
create_cleanup_tool() {
    cat > "$CACHE_DIR/cleanup_manager.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Cleanup Manager
Intelligent system cleanup with backup restoration capabilities
"""

import json
import subprocess
import sys
import os
import shutil
from pathlib import Path

class CleanupManager:
    def __init__(self, state_file, backup_dir):
        self.state_file = Path(state_file)
        self.backup_dir = Path(backup_dir)
        self.state = self.load_state()
        
    def load_state(self):
        try:
            with open(self.state_file, 'r') as f:
                return json.load(f)
        except:
            return {}
    
    def save_state(self):
        with open(self.state_file, 'w') as f:
            json.dump(self.state, f, indent=2)
    
    def get_blackarch_packages(self):
        """Get all installed BlackArch packages"""
        try:
            result = subprocess.run(
                ['pacman', '-Q'], 
                capture_output=True, 
                text=True, 
                check=True
            )
            
            blackarch_packages = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    package = line.split()[0]
                    # Check if package is from BlackArch
                    info_result = subprocess.run(
                        ['pacman', '-Si', package],
                        capture_output=True,
                        text=True
                    )
                    if 'blackarch' in info_result.stdout.lower():
                        blackarch_packages.append(package)
            
            return blackarch_packages
        except:
            return []
    
    def get_category_packages(self, category):
        """Get packages from specific category"""
        installed_packages = self.state.get('installed_packages', [])
        if category == 'all':
            return installed_packages
        
        # For category-specific cleanup, we'd need to track which packages
        # belong to which category during installation
        return [pkg for pkg in installed_packages if pkg in self.get_blackarch_packages()]
    
    def remove_packages(self, packages, dry_run=False):
        """Remove specified packages"""
        if not packages:
            return True, "No packages to remove"
        
        if dry_run:
            return True, f"Would remove {len(packages)} packages: {', '.join(packages[:5])}{'...' if len(packages) > 5 else ''}"
        
        try:
            cmd = ['pacman', '-Rns', '--noconfirm'] + packages
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Update state
                for pkg in packages:
                    if pkg in self.state.get('installed_packages', []):
                        self.state['installed_packages'].remove(pkg)
                self.save_state()
                return True, f"Successfully removed {len(packages)} packages"
            else:
                return False, f"Failed to remove packages: {result.stderr}"
        except Exception as e:
            return False, f"Error removing packages: {str(e)}"
    
    def restore_pacman_config(self, dry_run=False):
        """Restore original pacman configuration"""
        config_files = [
            '/etc/pacman.conf',
            '/etc/pacman.d/blackarch-mirrorlist'
        ]
        
        if dry_run:
            return True, "Would restore pacman configuration and remove BlackArch repository"
        
        try:
            # Remove BlackArch section from pacman.conf
            with open('/etc/pacman.conf', 'r') as f:
                lines = f.readlines()
            
            # Create backup
            shutil.copy('/etc/pacman.conf', '/etc/pacman.conf.kygox.bak')
            
            # Remove BlackArch configuration
            new_lines = []
            skip_section = False
            
            for line in lines:
                if line.strip() == '[blackarch]':
                    skip_section = True
                    continue
                elif line.startswith('[') and line.strip() != '[blackarch]':
                    skip_section = False
                
                if not skip_section:
                    new_lines.append(line)
            
            with open('/etc/pacman.conf', 'w') as f:
                f.writelines(new_lines)
            
            # Remove BlackArch mirrorlist
            if os.path.exists('/etc/pacman.d/blackarch-mirrorlist'):
                os.remove('/etc/pacman.d/blackarch-mirrorlist')
            
            # Update state
            self.state['blackarch_configured'] = False
            self.save_state()
            
            return True, "BlackArch repository configuration removed"
        except Exception as e:
            return False, f"Error restoring configuration: {str(e)}"
    
    def clean_cache_and_orphans(self, dry_run=False):
        """Clean package cache and orphaned packages"""
        if dry_run:
            return True, "Would clean package cache and remove orphaned packages"
        
        try:
            # Clean package cache
            subprocess.run(['pacman', '-Scc', '--noconfirm'], capture_output=True)
            
            # Remove orphaned packages
            result = subprocess.run(['pacman', '-Qtdq'], capture_output=True, text=True)
            if result.stdout.strip():
                orphans = result.stdout.strip().split('\n')
                subprocess.run(['pacman', '-Rns', '--noconfirm'] + orphans, capture_output=True)
                return True, f"Cleaned cache and removed {len(orphans)} orphaned packages"
            else:
                return True, "Cleaned cache, no orphaned packages found"
        except Exception as e:
            return False, f"Error cleaning system: {str(e)}"
    
    def full_cleanup(self, dry_run=False):
        """Perform complete system cleanup"""
        results = []
        
        # Remove BlackArch packages
        blackarch_packages = self.get_blackarch_packages()
        success, msg = self.remove_packages(blackarch_packages, dry_run)
        results.append(f"Package removal: {msg}")
        
        if not success and not dry_run:
            return False, "; ".join(results)
        
        # Restore configuration
        success, msg = self.restore_pacman_config(dry_run)
        results.append(f"Config restoration: {msg}")
        
        if not success and not dry_run:
            return False, "; ".join(results)
        
        # Clean cache
        success, msg = self.clean_cache_and_orphans(dry_run)
        results.append(f"Cache cleanup: {msg}")
        
        return True, "; ".join(results)

def main():
    if len(sys.argv) < 2:
        print("Usage: cleanup_manager.py <action> [options]")
        sys.exit(1)
    
    action = sys.argv[1]
    state_file = sys.argv[2] if len(sys.argv) > 2 else ""
    backup_dir = sys.argv[3] if len(sys.argv) > 3 else ""
    
    manager = CleanupManager(state_file, backup_dir)
    
    if action == "remove_blackarch_packages":
        dry_run = len(sys.argv) > 4 and sys.argv[4] == "--dry-run"
        packages = manager.get_blackarch_packages()
        success, msg = manager.remove_packages(packages, dry_run)
        print(msg)
        sys.exit(0 if success else 1)
    
    elif action == "remove_category":
        category = sys.argv[4] if len(sys.argv) > 4 else "all"
        dry_run = len(sys.argv) > 5 and sys.argv[5] == "--dry-run"
        packages = manager.get_category_packages(category)
        success, msg = manager.remove_packages(packages, dry_run)
        print(msg)
        sys.exit(0 if success else 1)
    
    elif action == "restore_config":
        dry_run = len(sys.argv) > 4 and sys.argv[4] == "--dry-run"
        success, msg = manager.restore_pacman_config(dry_run)
        print(msg)
        sys.exit(0 if success else 1)
    
    elif action == "full_cleanup":
        dry_run = len(sys.argv) > 4 and sys.argv[4] == "--dry-run"
        success, msg = manager.full_cleanup(dry_run)
        print(msg)
        sys.exit(0 if success else 1)
    
    elif action == "clean_cache":
        dry_run = len(sys.argv) > 4 and sys.argv[4] == "--dry-run"
        success, msg = manager.clean_cache_and_orphans(dry_run)
        print(msg)
        sys.exit(0 if success else 1)
    
    elif action == "list_packages":
        packages = manager.get_blackarch_packages()
        for pkg in packages:
            print(pkg)

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/cleanup_manager.py"
}

# Handle cleanup operations
handle_cleanup_operation() {
    local choice="$1"
    
    case "$choice" in
        1)
            echo -e "${YELLOW}Removing BlackArch packages only...${RESET}"
            if run_with_ui "python3 $CACHE_DIR/cleanup_manager.py remove_blackarch_packages $STATE_FILE $BACKUP_DIR" "Removing BlackArch packages" "progress"; then
                echo -e "${GREEN}‚úì${RESET} BlackArch packages removed successfully"
            else
                echo -e "${RED}‚úó${RESET} Failed to remove BlackArch packages"
            fi
            ;;
        2)
            echo -e "${YELLOW}Removing BlackArch repository configuration...${RESET}"
            if run_with_ui "python3 $CACHE_DIR/cleanup_manager.py restore_config $STATE_FILE $BACKUP_DIR" "Restoring configuration" "spinner"; then
                echo -e "${GREEN}‚úì${RESET} BlackArch repository configuration removed"
            else
                echo -e "${RED}‚úó${RESET} Failed to restore configuration"
            fi
            ;;
        3)
            echo -e "${RED}${BOLD}WARNING: This will completely remove all BlackArch components${RESET}"
            read -p "Type 'CONFIRM' to proceed: " -r confirmation
            if [[ "$confirmation" == "CONFIRM" ]]; then
                if run_with_ui "python3 $CACHE_DIR/cleanup_manager.py full_cleanup $STATE_FILE $BACKUP_DIR" "Performing complete cleanup" "wave"; then
                    echo -e "${GREEN}‚úì${RESET} Complete system restoration completed"
                else
                    echo -e "${RED}‚úó${RESET} System restoration failed"
                fi
            else
                echo -e "${YELLOW}Operation cancelled${RESET}"
            fi
            ;;
        4)
            echo -e "${CYAN}Available categories for removal:${RESET}"
            local state=$(get_installation_state)
            echo "$state" | python3 -c "
import json, sys
state = json.load(sys.stdin)
categories = state.get('installed_categories', [])
if categories:
    for i, cat in enumerate(categories, 1):
        print(f'  {i}) {cat}')
else:
    print('  No categories installed')
"
            ;;
        5)
            echo -e "${CYAN}Cleanup Preview (Dry Run):${RESET}"
            python3 "$CACHE_DIR/cleanup_manager.py" full_cleanup "$STATE_FILE" "$BACKUP_DIR" --dry-run
            ;;
        6)
            if run_with_ui "python3 $CACHE_DIR/cleanup_manager.py clean_cache $STATE_FILE $BACKUP_DIR" "Cleaning cache and orphans" "dots"; then
                echo -e "${GREEN}‚úì${RESET} Cache and orphans cleaned"
            else
                echo -e "${RED}‚úó${RESET} Cache cleanup failed"
            fi
            ;;
        0)
            return 0
            ;;
        *)
            echo -e "${RED}‚úó${RESET} Invalid selection"
            return 1
            ;;
    esac
}

# =============================================================================
# AUTO-UPDATER SYSTEM (C Implementation)
# =============================================================================

# Create the C-based auto-updater
create_auto_updater() {
    cat > "$CACHE_DIR/kygox-updater.c" << 'C_CODE'
/*
 * kygoX Auto-Updater
 * A low-level C implementation for automated system updates
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>
#include <json-c/json.h>
#include <sys/stat.h>

#define CONFIG_FILE "/home/%s/.config/kygox/kygox_state.json"
#define LOG_FILE "/var/log/kygox-updater.log"
#define MAX_PATH 1024
#define MAX_CMD 2048

typedef struct {
    char **installed_categories;
    char **installed_packages;
    char *installation_mode;
    int category_count;
    int package_count;
    int blackarch_configured;
} kygox_state_t;

void log_message(const char *level, const char *message) {
    FILE *log = fopen(LOG_FILE, "a");
    if (log) {
        time_t now = time(NULL);
        char *time_str = ctime(&now);
        time_str[strlen(time_str)-1] = '\0'; // Remove newline
        fprintf(log, "[%s] [%s] %s\n", time_str, level, message);
        fclose(log);
    }
}

int run_command(const char *command) {
    log_message("DEBUG", command);
    int status = system(command);
    return WIFEXITED(status) && WEXITSTATUS(status) == 0;
}

int load_kygox_state(const char *username, kygox_state_t *state) {
    char config_path[MAX_PATH];
    snprintf(config_path, sizeof(config_path), CONFIG_FILE, username);
    
    FILE *file = fopen(config_path, "r");
    if (!file) {
        log_message("ERROR", "Cannot open state file");
        return 0;
    }
    
    fseek(file, 0, SEEK_END);
    long length = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char *data = malloc(length + 1);
    fread(data, 1, length, file);
    data[length] = '\0';
    fclose(file);
    
    json_object *root = json_tokener_parse(data);
    free(data);
    
    if (!root) {
        log_message("ERROR", "Invalid JSON in state file");
        return 0;
    }
    
    // Parse blackarch_configured
    json_object *blackarch_obj;
    if (json_object_object_get_ex(root, "blackarch_configured", &blackarch_obj)) {
        state->blackarch_configured = json_object_get_boolean(blackarch_obj);
    }
    
    // Parse installation_mode
    json_object *mode_obj;
    if (json_object_object_get_ex(root, "installation_mode", &mode_obj)) {
        const char *mode = json_object_get_string(mode_obj);
        state->installation_mode = strdup(mode ? mode : "");
    }
    
    // Parse installed_categories
    json_object *categories_obj;
    if (json_object_object_get_ex(root, "installed_categories", &categories_obj)) {
        int array_len = json_object_array_length(categories_obj);
        state->installed_categories = malloc(array_len * sizeof(char*));
        state->category_count = array_len;
        
        for (int i = 0; i < array_len; i++) {
            json_object *category = json_object_array_get_idx(categories_obj, i);
            state->installed_categories[i] = strdup(json_object_get_string(category));
        }
    }
    
    // Parse installed_packages
    json_object *packages_obj;
    if (json_object_object_get_ex(root, "installed_packages", &packages_obj)) {
        int array_len = json_object_array_length(packages_obj);
        state->installed_packages = malloc(array_len * sizeof(char*));
        state->package_count = array_len;
        
        for (int i = 0; i < array_len; i++) {
            json_object *package = json_object_array_get_idx(packages_obj, i);
            state->installed_packages[i] = strdup(json_object_get_string(package));
        }
    }
    
    json_object_put(root);
    return 1;
}

int update_system() {
    log_message("INFO", "Starting system update");
    
    // Update pacman databases
    if (!run_command("pacman -Sy --noconfirm")) {
        log_message("ERROR", "Failed to update databases");
        return 0;
    }
    
    // Update BlackArch mirrorlist
    if (!run_command("curl -s https://blackarch.org/blackarch-mirrorlist -o /etc/pacman.d/blackarch-mirrorlist")) {
        log_message("WARNING", "Failed to update BlackArch mirrorlist");
    }
    
    // Perform system upgrade
    if (!run_command("pacman -Su --noconfirm")) {
        log_message("ERROR", "Failed to upgrade system");
        return 0;
    }
    
    log_message("INFO", "System update completed");
    return 1;
}

int get_available_blackarch_tools(char ***tools, int *count) {
    FILE *pipe = popen("pacman -Sl blackarch 2>/dev/null | awk '{print $2}'", "r");
    if (!pipe) {
        log_message("ERROR", "Failed to get BlackArch tools list");
        return 0;
    }
    
    char **tool_list = NULL;
    char line[256];
    int tool_count = 0;
    
    while (fgets(line, sizeof(line), pipe)) {
        // Remove newline
        line[strcspn(line, "\n")] = 0;
        
        tool_list = realloc(tool_list, (tool_count + 1) * sizeof(char*));
        tool_list[tool_count] = strdup(line);
        tool_count++;
    }
    
    pclose(pipe);
    
    *tools = tool_list;
    *count = tool_count;
    return 1;
}

int install_missing_tools(kygox_state_t *state) {
    if (!state->blackarch_configured) {
        log_message("INFO", "BlackArch not configured, skipping tool updates");
        return 1;
    }
    
    log_message("INFO", "Checking for missing tools");
    
    char **available_tools;
    int available_count;
    
    if (!get_available_blackarch_tools(&available_tools, &available_count)) {
        return 0;
    }
    
    // Check installation mode
    if (strcmp(state->installation_mode, "full") == 0 || 
        strcmp(state->installation_mode, "all") == 0) {
        
        log_message("INFO", "Full installation mode - checking all tools");
        
        // Install all missing BlackArch tools
        char command[MAX_CMD];
        snprintf(command, sizeof(command), 
                "pacman -S --noconfirm --needed $(pacman -Sl blackarch | awk '{print $2}' | tr '\n' ' ') 2>/dev/null || true");
        
        if (run_command(command)) {
            log_message("INFO", "All available tools installation completed");
        } else {
            log_message("WARNING", "Some tools failed to install");
        }
    } else {
        // Category-based installation
        log_message("INFO", "Category-based installation mode");
        
        // For each installed category, install new tools
        for (int i = 0; i < state->category_count; i++) {
            char category_command[MAX_CMD];
            snprintf(category_command, sizeof(category_command),
                    "python3 /tmp/kygox_cache/tool_analyzer.py analyze_category '%s' | grep '^PACKAGE:' | cut -d':' -f2 | xargs pacman -S --noconfirm --needed 2>/dev/null || true",
                    state->installed_categories[i]);
            
            if (run_command(category_command)) {
                log_message("INFO", "Updated tools for category");
            }
        }
    }
    
    // Clean up
    for (int i = 0; i < available_count; i++) {
        free(available_tools[i]);
    }
    free(available_tools);
    
    return 1;
}

void free_state(kygox_state_t *state) {
    if (state->installed_categories) {
        for (int i = 0; i < state->category_count; i++) {
            free(state->installed_categories[i]);
        }
        free(state->installed_categories);
    }
    
    if (state->installed_packages) {
        for (int i = 0; i < state->package_count; i++) {
            free(state->installed_packages[i]);
        }
        free(state->installed_packages);
    }
    
    if (state->installation_mode) {
        free(state->installation_mode);
    }
}

int main(int argc, char *argv[]) {
    // Check if running as root
    if (getuid() != 0) {
        fprintf(stderr, "kygox-updater must run as root\n");
        return 1;
    }
    
    log_message("INFO", "kygox-updater started");
    
    // Get the original user who installed kygoX
    const char *original_user = getenv("SUDO_USER");
    if (!original_user) {
        original_user = "root";
    }
    
    kygox_state_t state = {0};
    
    if (!load_kygox_state(original_user, &state)) {
        log_message("ERROR", "Failed to load kygoX state");
        return 1;
    }
    
    // Perform updates
    if (!update_system()) {
        log_message("ERROR", "System update failed");
        free_state(&state);
        return 1;
    }
    
    if (!install_missing_tools(&state)) {
        log_message("ERROR", "Tool update failed");
        free_state(&state);
        return 1;
    }
    
    log_message("INFO", "kygox-updater completed successfully");
    free_state(&state);
    return 0;
}
C_CODE

    # Compile the C updater
    if command -v gcc &>/dev/null; then
        if run_with_ui "gcc -o $CACHE_DIR/kygox-updater $CACHE_DIR/kygox-updater.c -ljson-c" "Compiling auto-updater" "spinner"; then
            echo -e "${GREEN}‚úì${RESET} Auto-updater compiled successfully"
        else
            echo -e "${YELLOW}‚ö†${RESET} Failed to compile C updater, using shell fallback"
            create_shell_updater
        fi
    else
        echo -e "${YELLOW}‚ö†${RESET} GCC not found, using shell fallback"
        create_shell_updater
    fi
}

# Fallback shell-based updater
create_shell_updater() {
    cat > "$CACHE_DIR/kygox-updater" << 'SHELL_UPDATER'
#!/bin/bash
#
# kygoX Shell-based Auto-Updater
# Fallback implementation when C compiler is not available
#

set -euo pipefail

readonly LOG_FILE="/var/log/kygox-updater.log"
readonly CONFIG_DIR="/home/${SUDO_USER:-root}/.config/kygox"
readonly STATE_FILE="$CONFIG_DIR/kygox_state.json"

log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
}

update_system() {
    log_message "INFO" "Starting system update"
    
    # Update pacman databases
    if ! pacman -Sy --noconfirm &>/dev/null; then
        log_message "ERROR" "Failed to update databases"
        return 1
    fi
    
    # Update BlackArch mirrorlist
    if ! curl -s "https://blackarch.org/blackarch-mirrorlist" -o "/etc/pacman.d/blackarch-mirrorlist"; then
        log_message "WARNING" "Failed to update BlackArch mirrorlist"
    fi
    
    # Perform system upgrade
    if ! pacman -Su --noconfirm &>/dev/null; then
        log_message "ERROR" "Failed to upgrade system"
        return 1
    fi
    
    log_message "INFO" "System update completed"
    return 0
}

install_missing_tools() {
    if [[ ! -f "$STATE_FILE" ]]; then
        log_message "ERROR" "State file not found"
        return 1
    fi
    
    local blackarch_configured
    blackarch_configured=$(python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
    print(state.get('blackarch_configured', False))
except:
    print(False)
")
    
    if [[ "$blackarch_configured" != "True" ]]; then
        log_message "INFO" "BlackArch not configured, skipping tool updates"
        return 0
    fi
    
    local installation_mode
    installation_mode=$(python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
    print(state.get('installation_mode', ''))
except:
    print('')
")
    
    log_message "INFO" "Checking for missing tools (mode: $installation_mode)"
    
    if [[ "$installation_mode" == "full" || "$installation_mode" == "all" ]]; then
        log_message "INFO" "Full installation mode - updating all tools"
        
        # Get all BlackArch packages and install missing ones
        local available_tools
        available_tools=$(pacman -Sl blackarch 2>/dev/null | awk '{print $2}' | tr '\n' ' ')
        
        if [[ -n "$available_tools" ]]; then
            pacman -S --noconfirm --needed $available_tools &>/dev/null || true
            log_message "INFO" "All available tools installation completed"
        fi
    else
        log_message "INFO" "Category-based installation mode"
        
        # Get installed categories and update tools for each
        python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
    categories = state.get('installed_categories', [])
    for category in categories:
        print(category)
except:
    pass
" | while read -r category; do
            if [[ -n "$category" ]]; then
                log_message "INFO" "Updating tools for category: $category"
                # Note: This would need the tool analyzer to work properly
                # For now, just log the attempt
            fi
        done
    fi
    
    return 0
}

main() {
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        echo "kygox-updater must run as root" >&2
        exit 1
    fi
    
    log_message "INFO" "kygox-updater (shell) started"
    
    if ! update_system; then
        log_message "ERROR" "System update failed"
        exit 1
    fi
    
    if ! install_missing_tools; then
        log_message "ERROR" "Tool update failed"
        exit 1
    fi
    
    log_message "INFO" "kygox-updater completed successfully"
    exit 0
}

main "$@"
SHELL_UPDATER

    chmod +x "$CACHE_DIR/kygox-updater"
}

# Install auto-updater system
install_auto_updater() {
    echo -e "${CYAN}Installing kygoX Auto-Updater...${RESET}"
    
    # Create the updater
    create_auto_updater
    
    # Install the binary
    if [[ -f "$CACHE_DIR/kygox-updater" ]]; then
        cp "$CACHE_DIR/kygox-updater" "$UPDATER_BINARY"
        chmod +x "$UPDATER_BINARY"
    fi
    
    # Create systemd service
    cat > "$SYSTEMD_SERVICE_FILE" << EOF
[Unit]
Description=kygoX Auto-Updater Service
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$UPDATER_BINARY
User=root
Environment=SUDO_USER=$ORIGINAL_USER

[Install]
WantedBy=multi-user.target
EOF
    
    # Create systemd timer
    cat > "$SYSTEMD_TIMER_FILE" << EOF
[Unit]
Description=kygoX Auto-Updater Timer
Requires=kygox-updater.service

[Timer]
OnCalendar=daily
RandomizedDelaySec=3600
Persistent=true

[Install]
WantedBy=timers.target
EOF
    
    # Enable and start the timer
    systemctl daemon-reload
    systemctl enable kygox-updater.timer
    systemctl start kygox-updater.timer
    
    # Update state
    python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
except:
    state = {}

state['auto_updater_enabled'] = True

with open('$STATE_FILE', 'w') as f:
    json.dump(state, f, indent=2)
"
    
    echo -e "${GREEN}‚úì${RESET} Auto-updater installed and enabled"
    echo -e "${CYAN}  ‚Ä¢ Updates every $UPDATE_INTERVAL_DAYS days${RESET}"
    echo -e "${CYAN}  ‚Ä¢ Logs: /var/log/kygox-updater.log${RESET}"
    echo -e "${CYAN}  ‚Ä¢ Control: systemctl [start|stop|status] kygox-updater.timer${RESET}"
}

# Remove auto-updater
remove_auto_updater() {
    echo -e "${YELLOW}Removing kygoX Auto-Updater...${RESET}"
    
    # Stop and disable systemd services
    systemctl stop kygox-updater.timer 2>/dev/null || true
    systemctl disable kygox-updater.timer 2>/dev/null || true
    
    # Remove files
    rm -f "$UPDATER_BINARY"
    rm -f "$SYSTEMD_SERVICE_FILE"
    rm -f "$SYSTEMD_TIMER_FILE"
    
    systemctl daemon-reload
    
    # Update state
    python3 -c "
import json
try:
    with open('$STATE_FILE', 'r') as f:
        state = json.load(f)
    state['auto_updater_enabled'] = False
    with open('$STATE_FILE', 'w') as f:
        json.dump(state, f, indent=2)
except:
    pass
"
    
    echo -e "${GREEN}‚úì${RESET} Auto-updater removed"
}

# =============================================================================
# ANIMATED UI SYSTEM (Previous Implementation)
# =============================================================================

# Create Python UI loader system
create_ui_loader() {
    cat > "$CACHE_DIR/ui_loader.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Animated UI Loader System
Provides clean animated interfaces for all system operations
"""

import sys
import time
import threading
import subprocess
import signal
from itertools import cycle

class AnimatedLoader:
    def __init__(self):
        self.running = False
        self.thread = None
        
    def spinner_animation(self, message, spinner_chars="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"):
        """Display animated spinner with message"""
        spinner = cycle(spinner_chars)
        while self.running:
            sys.stdout.write(f'\r\033[96m{next(spinner)}\033[0m {message}')
            sys.stdout.flush()
            time.sleep(0.1)
    
    def progress_bar(self, message, duration=10, width=40):
        """Display animated progress bar"""
        for i in range(width + 1):
            if not self.running:
                break
            percent = int((i / width) * 100)
            filled = '‚ñà' * i
            empty = '‚ñë' * (width - i)
            sys.stdout.write(f'\r\033[94m[{filled}{empty}]\033[0m {percent}% {message}')
            sys.stdout.flush()
            time.sleep(duration / width)
    
    def dots_animation(self, message, max_dots=3):
        """Display animated dots"""
        while self.running:
            for dots in range(max_dots + 1):
                if not self.running:
                    break
                dots_str = '.' * dots + ' ' * (max_dots - dots)
                sys.stdout.write(f'\r\033[93m{message}{dots_str}\033[0m')
                sys.stdout.flush()
                time.sleep(0.5)
    
    def wave_animation(self, message):
        """Display wave animation"""
        wave_chars = "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ"
        wave = cycle(wave_chars)
        while self.running:
            wave_display = ''.join([next(wave) for _ in range(8)])
            sys.stdout.write(f'\r\033[95m{wave_display}\033[0m {message} \033[95m{wave_display}\033[0m')
            sys.stdout.flush()
            time.sleep(0.1)
    
    def start_animation(self, animation_type, message, duration=None):
        """Start specific animation type"""
        self.running = True
        
        if animation_type == "spinner":
            self.thread = threading.Thread(target=self.spinner_animation, args=(message,))
        elif animation_type == "progress":
            self.thread = threading.Thread(target=self.progress_bar, args=(message, duration or 10))
        elif animation_type == "dots":
            self.thread = threading.Thread(target=self.dots_animation, args=(message,))
        elif animation_type == "wave":
            self.thread = threading.Thread(target=self.wave_animation, args=(message,))
        else:
            self.thread = threading.Thread(target=self.spinner_animation, args=(message,))
        
        self.thread.daemon = True
        self.thread.start()
    
    def stop_animation(self, success_message=None, error_message=None):
        """Stop animation and show result"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1)
        
        # Clear line
        sys.stdout.write('\r' + ' ' * 80 + '\r')
        
        if success_message:
            print(f'\033[92m‚úì\033[0m {success_message}')
        elif error_message:
            print(f'\033[91m‚úó\033[0m {error_message}')
        
        sys.stdout.flush()

class UIManager:
    def __init__(self):
        self.loader = AnimatedLoader()
        
    def run_with_loader(self, command, animation_type="spinner", message="Processing", 
                       success_msg=None, error_msg=None, timeout=300):
        """Run command with animated loader"""
        
        # Start animation
        self.loader.start_animation(animation_type, message)
        
        try:
            # Run command silently
            if isinstance(command, str):
                result = subprocess.run(command, shell=True, capture_output=True, 
                                      text=True, timeout=timeout)
            else:
                result = subprocess.run(command, capture_output=True, 
                                      text=True, timeout=timeout)
            
            # Stop animation with result
            if result.returncode == 0:
                self.loader.stop_animation(success_message=success_msg or f"{message} completed")
                return True
            else:
                self.loader.stop_animation(error_message=error_msg or f"{message} failed")
                return False
                
        except subprocess.TimeoutExpired:
            self.loader.stop_animation(error_message=f"{message} timed out")
            return False
        except Exception as e:
            self.loader.stop_animation(error_message=f"{message} error: {str(e)}")
            return False

def main():
    if len(sys.argv) < 2:
        print("Usage: ui_loader.py <action> [args]")
        sys.exit(1)
    
    action = sys.argv[1]
    manager = UIManager()
    
    if action == "run_command":
        if len(sys.argv) < 4:
            print("Usage: ui_loader.py run_command <command> <message> [animation_type]")
            sys.exit(1)
        
        command = sys.argv[2]
        message = sys.argv[3]
        animation_type = sys.argv[4] if len(sys.argv) > 4 else "spinner"
        
        success = manager.run_with_loader(command, animation_type, message)
        sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/ui_loader.py"
}

# Run command with animated UI
run_with_ui() {
    local command="$1"
    local message="$2"
    local animation_type="${3:-spinner}"
    local success_msg="${4:-}"
    local error_msg="${5:-}"
    
    if [[ -f "$CACHE_DIR/ui_loader.py" ]]; then
        if python3 "$CACHE_DIR/ui_loader.py" run_command "$command" "$message" "$animation_type"; then
            [[ -n "$success_msg" ]] && echo -e "${GREEN}‚úì${RESET} $success_msg"
            return 0
        else
            [[ -n "$error_msg" ]] && echo -e "${RED}‚úó${RESET} $error_msg"
            return 1
        fi
    else
        # Fallback to direct execution
        eval "$command" &>/dev/null
        return $?
    fi
}

# Multi-step operation with progress tracking
run_multi_step_ui() {
    local steps=("$@")
    local current=0
    local total=${#steps[@]}
    
    for step in "${steps[@]}"; do
        ((current++))
        local progress=$((current * 100 / total))
        
        IFS='|' read -r command message animation success_msg error_msg <<< "$step"
        
        echo -e "${CYAN}Step $current/$total (${progress}%):${RESET}"
        
        if run_with_ui "$command" "$message" "$animation" "$success_msg" "$error_msg"; then
            continue
        else
            echo -e "${RED}Multi-step operation failed at step $current${RESET}"
            return 1
        fi
    done
    
    echo -e "${GREEN}${BOLD}All steps completed successfully!${RESET}"
    return 0
}

# =============================================================================
# ENHANCED MAIN MENU WITH CLEANUP AND UPDATER OPTIONS
# =============================================================================

show_enhanced_main_menu() {
    echo -e "${CYAN}${BOLD}kygoX Security Toolkit Selection${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    
    # Show total available tools
    local total_tools=$(get_total_blackarch_tools)
    if [[ $total_tools -gt 0 ]]; then
        echo -e "${GREEN}${BOLD}üìä BlackArch Arsenal: $total_tools tools available${RESET}"
    else
        echo -e "${YELLOW}${BOLD}üìä Scanning BlackArch repository...${RESET}"
    fi
    echo
    
    echo -e "${YELLOW}${BOLD}Tool Categories:${RESET}"
    for key in $(printf '%s\n' "${!CATEGORIES[@]}" | sort -n); do
        local cat_info="${CATEGORIES[$key]}"
        local cat_name=$(echo "$cat_info" | cut -d':' -f2)
        
        echo -e "  ${CYAN}$key${RESET}) $cat_name ${DIM}(analyzing...)${RESET}"
    done
    
    echo
    echo -e "${YELLOW}${BOLD}Special Options:${RESET}"
    echo -e "  ${CYAN}9${RESET}) Custom Package Selection"
    echo -e "  ${CYAN}a${RESET}) Install ALL BlackArch Tools (Full Arsenal)"
    echo
    echo -e "${YELLOW}${BOLD}System Management:${RESET}"
    echo -e "  ${CYAN}c${RESET}) Smart Cleanup System"
    echo -e "  ${CYAN}u${RESET}) Auto-Updater Management"
    echo -e "  ${CYAN}s${RESET}) System Status & Information"
    echo -e "  ${CYAN}q${RESET}) Quit"
    echo
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
}

# Handle enhanced menu selections
handle_enhanced_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        [1-8])
            show_category_analysis "$choice"
            echo
            read -p "Proceed with installation of this category? [Y/n]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                install_category_dynamic "$choice"
                save_installation_state "$(echo "${CATEGORIES[$choice]}" | cut -d':' -f2)" "${packages[@]}"
            fi
            ;;
        9)
            custom_package_selection
            ;;
        a|A)
            install_all_blackarch_tools
            ;;
        c|C)
            cleanup_management_menu
            ;;
        u|U)
            updater_management_menu
            ;;
        s|S)
            show_enhanced_system_info
            ;;
        q|Q)
            exit 0
            ;;
        *)
            echo -e "${RED}‚úó${RESET} Invalid selection: $choice"
            return 1
            ;;
    esac
}

# Install all BlackArch tools
install_all_blackarch_tools() {
    echo -e "${RED}${BOLD}WARNING: This will install ALL BlackArch tools (~2000+ packages)${RESET}"
    echo -e "${YELLOW}This may take several hours and require significant disk space (20GB+)${RESET}"
    echo
    read -p "Type 'INSTALL_ALL' to confirm: " -r confirmation
    
    if [[ "$confirmation" == "INSTALL_ALL" ]]; then
        echo -e "${CYAN}${BOLD}Installing complete BlackArch arsenal...${RESET}"
        
        # Create backup first
        create_system_backup
        
        if run_with_ui "pacman -S --noconfirm --needed \$(pacman -Sl blackarch | awk '{print \$2}')" "Installing all BlackArch tools" "wave"; then
            save_installation_state "all" "$(pacman -Sl blackarch | awk '{print $2}')"
            echo -e "${GREEN}‚úì${RESET} Complete BlackArch arsenal installed!"
        else
            echo -e "${RED}‚úó${RESET} Installation failed"
        fi
    else
        echo -e "${YELLOW}Installation cancelled${RESET}"
    fi
}

# Cleanup management menu
cleanup_management_menu() {
    while true; do
        create_cleanup_tool
        show_cleanup_menu
        read -p "Select cleanup option: " -r choice
        echo
        
        if [[ "$choice" == "0" ]]; then
            break
        fi
        
        handle_cleanup_operation "$choice"
        echo
        read -p "Press Enter to continue..." -r
    done
}

# Updater management menu
updater_management_menu() {
    echo -e "${CYAN}${BOLD}kygoX Auto-Updater Management${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    
    # Check current status
    local updater_status="Disabled"
    if systemctl is-active kygox-updater.timer &>/dev/null; then
        updater_status="Active"
    fi
    
    echo -e "${YELLOW}Current Status: ${GREEN}$updater_status${RESET}"
    echo
    echo -e "  ${CYAN}1${RESET}) Enable Auto-Updater"
    echo -e "  ${CYAN}2${RESET}) Disable Auto-Updater"
    echo -e "  ${CYAN}3${RESET}) Run Update Now"
    echo -e "  ${CYAN}4${RESET}) View Update Logs"
    echo -e "  ${CYAN}5${RESET}) Update Schedule Status"
    echo -e "  ${CYAN}0${RESET}) Back to main menu"
    echo
    
    read -p "Select option: " -r choice
    echo
    
    case "$choice" in
        1)
            install_auto_updater
            ;;
        2)
            remove_auto_updater
            ;;
        3)
            echo -e "${CYAN}Running manual update...${RESET}"
            if [[ -x "$UPDATER_BINARY" ]]; then
                "$UPDATER_BINARY"
            else
                echo -e "${RED}‚úó${RESET} Auto-updater not installed"
            fi
            ;;
        4)
            if [[ -f "/var/log/kygox-updater.log" ]]; then
                echo -e "${CYAN}Last 20 log entries:${RESET}"
                tail -20 /var/log/kygox-updater.log
            else
                echo -e "${YELLOW}No update logs found${RESET}"
            fi
            ;;
        5)
            echo -e "${CYAN}Update Schedule Status:${RESET}"
            systemctl status kygox-updater.timer --no-pager || echo "Timer not active"
            ;;
        0)
            return 0
            ;;
        *)
            echo -e "${RED}‚úó${RESET} Invalid selection"
            ;;
    esac
    
    echo
    read -p "Press Enter to continue..." -r
}

# Enhanced system information
show_enhanced_system_info() {
    echo -e "${CYAN}${BOLD}Enhanced System Information & kygoX Status${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    
    # Get installation state
    local state=$(get_installation_state)
    
    echo -e "${YELLOW}${BOLD}kygoX Installation Status:${RESET}"
    echo "$state" | python3 -c "
import json, sys
state = json.load(sys.stdin)
print(f\"  Version: {state.get('version', 'Unknown')}\")
print(f\"  Installation Date: {state.get('installation_date', 'Unknown')}\")
print(f\"  BlackArch Configured: {state.get('blackarch_configured', False)}\")
print(f\"  Installation Mode: {state.get('installation_mode', 'Unknown')}\")
print(f\"  Auto-Updater: {state.get('auto_updater_enabled', False)}\")
print(f\"  Last Update: {state.get('last_update', 'Never')}\")

categories = state.get('installed_categories', [])
packages = state.get('installed_packages', [])
print(f\"  Installed Categories: {len(categories)}\")
print(f\"  Installed Packages: {len(packages)}\")

if categories:
    print(\"  Categories: \" + \", \".join(categories))
"
    
    echo
    echo -e "${YELLOW}${BOLD}System Resources:${RESET}"
    echo -e "  CPU: $(cat /proc/cpuinfo | grep 'model name' | head -1 | cut -d':' -f2 | xargs)"
    echo -e "  Cores: $(nproc)"
    echo -e "  Memory: $(free -h | grep '^Mem:' | awk '{print $2 " total, " $3 " used, " $7 " available"}')"
    echo -e "  Storage: $(df -h / | tail -1 | awk '{print $2 " total, " $4 " available (" $5 " used)"}')"
    echo
    
    echo -e "${YELLOW}${BOLD}Package Statistics:${RESET}"
    echo -e "  Total Installed Packages: $(pacman -Q | wc -l)"
    echo -e "  BlackArch Tools Available: $(get_total_blackarch_tools)"
    echo -e "  BlackArch Tools Installed: $(pacman -Q | grep -c blackarch || echo "0")"
    echo
    
    if [[ -d "$CONFIG_DIR" ]]; then
        echo -e "${YELLOW}${BOLD}kygoX File Locations:${RESET}"
        echo -e "  Config Directory: $CONFIG_DIR"
        echo -e "  State File: $STATE_FILE"
        echo -e "  Backup Directory: $BACKUP_DIR"
        echo -e "  Log Directory: $LOG_DIR"
        echo
    fi
}

# =============================================================================
# EXISTING CORE FUNCTIONS (Previous Implementation)
# =============================================================================

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Logging with timestamps (only to file, not console)
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Log to file only
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox.log"
}

# Error handling
error_exit() {
    local exit_code="${2:-1}"
    log_message "ERROR" "$1"
    echo -e "${RED}${BOLD}Error:${RESET} $1" >&2
    cleanup_on_exit "$exit_code"
}

# Banner display with tool count
display_banner() {
    clear
    cat << 'EOF'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                              ‚ïë
‚ïë  ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó                               ‚ïë
‚ïë  ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù                               ‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù                                ‚ïë
‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó   ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó                                ‚ïë
‚ïë  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó                               ‚ïë
‚ïë  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù                               ‚ïë
‚ïë                                                                              ‚ïë
‚ïë             kygoX - Arch Linux Security Testing Suite                       ‚ïë
‚ïë                      Version 0.3.0 Aurora                                   ‚ïë
‚ïë                   By 0xb0rn3 | IG: theehiv3 | X: 0xbv1                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF

    echo
    echo -e "${CYAN}${BOLD}System Dashboard:${RESET}"
    echo -e "  ${WHITE}‚Ä¢${RESET} OS: $(get_system_info)"
    echo -e "  ${WHITE}‚Ä¢${RESET} Kernel: $(uname -r)"
    echo -e "  ${WHITE}‚Ä¢${RESET} User: $ORIGINAL_USER"
    echo -e "  ${WHITE}‚Ä¢${RESET} Python: $(get_python_version)"
    
    # Get and display tool count
    local tool_count=$(get_total_blackarch_tools)
    if [[ $tool_count -gt 0 ]]; then
        echo -e "  ${WHITE}‚Ä¢${RESET} Available BlackArch Tools: ${GREEN}${BOLD}$tool_count${RESET}"
    else
        echo -e "  ${WHITE}‚Ä¢${RESET} Available BlackArch Tools: ${YELLOW}Checking...${RESET}"
    fi
    echo
}

# System info functions
get_system_info() {
    if [[ -f /etc/os-release ]]; then
        grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2
    else
        echo "Unknown Linux Distribution"
    fi
}

get_python_version() {
    if command -v python3 &>/dev/null; then
        python3 --version | cut -d' ' -f2
    else
        echo "Not installed"
    fi
}

# =============================================================================
# BLACKARCH REPOSITORY SETUP
# =============================================================================

# Set secure umask
set_secure_umask() {
    OLD_UMASK=$(umask)
    umask 0022
}

# Reset umask
reset_secure_umask() {
    if [[ -n "$OLD_UMASK" ]]; then
        umask "$OLD_UMASK"
    fi
}

# Check internet connectivity
check_blackarch_connectivity() {
    log_message "DEBUG" "Testing connectivity to BlackArch repository..."
    
    if ! curl -s --connect-timeout 8 "https://blackarch.org/" > /dev/null 2>&1; then
        return 1
    fi
    
    return 0
}

# Configure GPG for BlackArch
configure_gpg_for_blackarch() {
    log_message "DEBUG" "Configuring GPG for BlackArch repository..."
    
    local gpg_conf='/etc/pacman.d/gnupg/gpg.conf'
    
    if [[ -f "$gpg_conf" ]] && ! grep -q 'allow-weak-key-signatures' "$gpg_conf"; then
        echo 'allow-weak-key-signatures' >> "$gpg_conf"
    fi
    
    return 0
}

# Create temporary directory
make_blackarch_tmp_dir() {
    local tmp_dir
    tmp_dir=$(mktemp -d /tmp/blackarch_strap.XXXXXXXX)
    
    if [[ ! -d "$tmp_dir" ]]; then
        error_exit "Could not create temporary directory"
    fi
    
    trap "rm -rf '$tmp_dir'" EXIT
    cd "$tmp_dir" || error_exit "Could not enter temporary directory"
    
    log_message "DEBUG" "Created temporary directory: $tmp_dir"
}

# Download BlackArch keyring
fetch_blackarch_keyring() {
    log_message "DEBUG" "Downloading BlackArch keyring..."
    
    if ! curl -s -O "$BLACKARCH_KEYRING_URL"; then
        return 1
    fi
    
    if ! curl -s -O "$BLACKARCH_KEYRING_SIG_URL"; then
        return 1
    fi
    
    return 0
}

# Verify BlackArch keyring signature
verify_blackarch_keyring() {
    log_message "DEBUG" "Verifying BlackArch keyring signature..."
    
    local keyservers=(
        "keyserver.ubuntu.com"
        "hkps://keyserver.ubuntu.com:443"
        "hkp://pgp.mit.edu:80"
    )
    
    local key_imported=false
    
    for keyserver in "${keyservers[@]}"; do
        if gpg --keyserver "$keyserver" --recv-keys "$BLACKARCH_GPG_KEY" > /dev/null 2>&1; then
            key_imported=true
            break
        fi
    done
    
    if [[ "$key_imported" != "true" ]]; then
        return 1
    fi
    
    if ! gpg --keyserver-options no-auto-key-retrieve \
        --with-fingerprint blackarch-keyring.pkg.tar.zst.sig > /dev/null 2>&1; then
        return 1
    fi
    
    return 0
}

# Clean up signature files
cleanup_signature_files() {
    rm -f *.pkg.tar.zst.sig 2>/dev/null || true
}

# Initialize pacman GPG
initialize_pacman_gpg() {
    if ! pacman-key --init > /dev/null 2>&1; then
        return 1
    fi
    return 0
}

# Install BlackArch keyring
install_blackarch_keyring() {
    local keyring_pkg
    keyring_pkg=$(find . -name "blackarch-keyring*.pkg.tar.zst" -type f | head -1)
    
    if [[ -z "$keyring_pkg" ]]; then
        return 1
    fi
    
    if ! pacman --config /dev/null --noconfirm -U "$keyring_pkg" > /dev/null 2>&1; then
        return 1
    fi
    
    pacman-key --populate > /dev/null 2>&1 || true
    return 0
}

# Download BlackArch mirror list
fetch_blackarch_mirrors() {
    local mirror_path="/etc/pacman.d"
    local mirror_file="$mirror_path/$BLACKARCH_MIRROR_FILE"
    
    if ! curl -s "$BLACKARCH_MIRROR_URL" -o "$mirror_file"; then
        return 1
    fi
    
    return 0
}

# Update pacman.conf
update_pacman_conf_for_blackarch() {
    sed -i '/blackarch/{N;d}' /etc/pacman.conf 2>/dev/null || true
    
    cat >> "/etc/pacman.conf" << EOF
[blackarch]
Include = /etc/pacman.d/$BLACKARCH_MIRROR_FILE
EOF
    
    return 0
}

# Synchronize package databases
synchronize_blackarch_databases() {
    if pacman -Syy > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Install BlackArch officials meta-package
install_blackarch_officials() {
    if pacman -S --noconfirm --needed blackarch-officials > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Main BlackArch setup with animated UI
setup_blackarch_repository() {
    echo -e "${CYAN}${BOLD}Setting up BlackArch Repository${RESET}"
    echo
    
    # Check if already configured
    if grep -q "\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo -e "${GREEN}‚úì${RESET} BlackArch repository already configured"
        get_total_blackarch_tools > /dev/null
        return 0
    fi
    
    # Create backup before setup
    create_system_backup
    
    # Multi-step setup with UI loaders
    local setup_steps=(
        "check_blackarch_connectivity|Testing internet connectivity|spinner|Connection verified|Connection failed"
        "set_secure_umask && make_blackarch_tmp_dir|Preparing workspace|dots|Workspace ready|Workspace setup failed"
        "configure_gpg_for_blackarch|Configuring GPG settings|spinner|GPG configured|GPG configuration failed"
        "fetch_blackarch_keyring|Downloading BlackArch keyring|progress|Keyring downloaded|Keyring download failed"
        "verify_blackarch_keyring|Verifying keyring signatures|wave|Keyring verified|Keyring verification failed"
        "cleanup_signature_files && initialize_pacman_gpg|Initializing package manager|spinner|Package manager ready|Initialization failed"
        "install_blackarch_keyring|Installing BlackArch keyring|progress|Keyring installed|Keyring installation failed"
        "fetch_blackarch_mirrors|Configuring repository mirrors|dots|Mirrors configured|Mirror configuration failed"
        "update_pacman_conf_for_blackarch|Updating system configuration|spinner|Configuration updated|Configuration failed"
        "synchronize_blackarch_databases|Synchronizing package databases|progress|Databases synchronized|Synchronization failed"
        "install_blackarch_officials|Installing BlackArch meta-package|wave|Meta-package installed|Meta-package installation failed"
    )
    
    if run_multi_step_ui "${setup_steps[@]}"; then
        reset_secure_umask
        get_total_blackarch_tools > /dev/null
        echo
        echo -e "${GREEN}${BOLD}BlackArch repository setup completed successfully!${RESET}"
        return 0
    else
        reset_secure_umask
        error_exit "BlackArch repository setup failed"
        return 1
    fi
}

# =============================================================================
# DYNAMIC TOOL ANALYSIS SYSTEM
# =============================================================================

# Get total available BlackArch tools
get_total_blackarch_tools() {
    if [[ $TOTAL_AVAILABLE_TOOLS -eq 0 ]]; then
        log_message "DEBUG" "Calculating total available BlackArch tools..."
        
        if pacman -Sl blackarch &>/dev/null; then
            TOTAL_AVAILABLE_TOOLS=$(pacman -Sl blackarch 2>/dev/null | wc -l)
        else
            TOTAL_AVAILABLE_TOOLS=0
        fi
        
        log_message "DEBUG" "Found $TOTAL_AVAILABLE_TOOLS total BlackArch tools"
    fi
    
    echo $TOTAL_AVAILABLE_TOOLS
}

# Create Python tool analyzer
create_tool_analyzer() {
    cat > "$CACHE_DIR/tool_analyzer.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Tool Analyzer
Analyzes available BlackArch tools and categorizes them dynamically
"""

import sys
import subprocess
import re
from collections import defaultdict

class ToolAnalyzer:
    def __init__(self, repo_name="blackarch"):
        self.repo_name = repo_name
        self.categories = {}
        
    def get_available_packages(self):
        """Get all available packages from BlackArch repository"""
        try:
            result = subprocess.run(
                ['pacman', '-Sl', self.repo_name],
                capture_output=True,
                text=True,
                check=True
            )
            packages = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        packages.append(parts[1])
            return packages
        except subprocess.CalledProcessError:
            return []
    
    def analyze_category(self, category_keywords):
        """Analyze tools available for a specific category"""
        packages = self.get_available_packages()
        if not packages:
            return []
        
        keywords = category_keywords.split()
        matching_packages = []
        
        for package in packages:
            package_lower = package.lower()
            if any(keyword in package_lower for keyword in keywords):
                matching_packages.append(package)
        
        return matching_packages

def main():
    if len(sys.argv) < 2:
        print("Usage: tool_analyzer.py <action> [args]", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    analyzer = ToolAnalyzer()
    
    if action == "count_total":
        packages = analyzer.get_available_packages()
        print(len(packages))
    
    elif action == "analyze_category":
        if len(sys.argv) < 3:
            print("Usage: tool_analyzer.py analyze_category <keywords>", file=sys.stderr)
            sys.exit(1)
        
        keywords = sys.argv[2]
        matching_packages = analyzer.analyze_category(keywords)
        
        print(f"CATEGORY_COUNT:{len(matching_packages)}")
        for package in matching_packages[:20]:  # Show first 20
            print(f"PACKAGE:{package}")
        
        if len(matching_packages) > 20:
            print(f"MORE:{len(matching_packages) - 20}")

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/tool_analyzer.py"
}

# Analyze category tools with UI
analyze_category_tools() {
    local category_key="$1"
    
    if [[ ! "${CATEGORIES[$category_key]:-}" ]]; then
        echo "0"
        return
    fi
    
    local cat_info="${CATEGORIES[$category_key]}"
    local keywords=$(echo "$cat_info" | cut -d':' -f3)
    
    if [[ -f "$CACHE_DIR/tool_analyzer.py" ]]; then
        python3 "$CACHE_DIR/tool_analyzer.py" analyze_category "$keywords" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# =============================================================================
# SYSTEM VALIDATION
# =============================================================================

validate_system() {
    echo -e "${CYAN}Validating system requirements...${RESET}"
    
    # Check root privileges
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    
    # Validate original user
    if [[ -z "$ORIGINAL_USER" || "$ORIGINAL_USER" == "root" ]]; then
        error_exit "Cannot determine original user. Please run with 'sudo $0'"
    fi
    
    # Check for Arch-based system
    if ! command -v pacman &>/dev/null; then
        if command -v apt &>/dev/null; then
            error_exit "Debian-based system detected. Use KRILIN instead: https://github.com/0xb0rn3/krilin"
        else
            error_exit "This tool requires an Arch-based distribution with pacman"
        fi
    fi
    
    # Check internet connectivity with UI
    if ! run_with_ui "ping -c 1 -W 3 archlinux.org" "Checking internet connectivity" "spinner" "Internet connection verified" "Internet connection required"; then
        error_exit "Internet connectivity required for package downloads"
    fi
    
    # Check disk space
    local available_space
    available_space=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $available_space -lt 5 ]]; then
        echo -e "${YELLOW}‚ö†${RESET} Only ${available_space}GB available. Some installations may fail."
    fi
    
    echo -e "${GREEN}‚úì${RESET} System validation completed"
}

# Install dependencies with UI
install_dependencies() {
    echo -e "${CYAN}Installing required dependencies...${RESET}"
    
    local required_packages=("curl" "wget" "python" "python-pip" "base-devel" "gcc" "json-c")
    local missing_packages=()
    
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        local install_steps=(
            "pacman -Sy --noconfirm|Updating package databases|progress|Package databases updated|Database update failed"
            "pacman -S --noconfirm --needed ${missing_packages[*]}|Installing dependencies|wave|Dependencies installed|Dependency installation failed"
        )
        
        if run_multi_step_ui "${install_steps[@]}"; then
            echo -e "${GREEN}‚úì${RESET} Dependencies installed successfully"
        else
            error_exit "Failed to install required dependencies"
        fi
    else
        echo -e "${GREEN}‚úì${RESET} All dependencies already satisfied"
    fi
}

# Check package availability
check_package_availability() {
    local package="$1"
    
    # Check if already installed
    if pacman -Qi "$package" &>/dev/null; then
        echo "installed"
        return 0
    fi
    
    # Check if available in any repository
    if pacman -Si "$package" &>/dev/null 2>&1; then
        echo "available"
        return 0
    fi
    
    echo "unavailable"
    return 1
}

# =============================================================================
# PACKAGE INSTALLATION ENGINE
# =============================================================================

install_single_package() {
    local package="$1"
    local max_retries=3
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "${GREEN}‚úì${RESET} [DRY RUN] Would install: $package"
            return 0
        fi
        
        # Install with UI loader
        if run_with_ui "pacman -S --noconfirm --needed $package" "Installing $package" "progress" "Installed $package" "Failed to install $package"; then
            return 0
        else
            ((retry_count++))
            
            # Auto-fix if enabled
            if [[ "$AUTO_FIX" == "true" && $retry_count -lt $max_retries ]]; then
                echo -e "${YELLOW}‚ö†${RESET} Attempting auto-fix (attempt $retry_count)..."
                
                # Apply fixes with UI
                run_with_ui "rm -f /var/lib/pacman/db.lck" "Removing lock files" "spinner"
                run_with_ui "pacman -Sy --noconfirm" "Updating databases" "dots"
                
                if [[ $retry_count -gt 1 ]]; then
                    run_with_ui "pacman -Scc --noconfirm" "Clearing cache" "spinner"
                fi
                
                sleep 2
            fi
        fi
    done
    
    echo -e "${RED}‚úó${RESET} Failed to install $package after $max_retries attempts"
    return 1
}

install_packages() {
    local packages=("$@")
    local total_packages=${#packages[@]}
    local installed_count=0
    local failed_count=0
    local skipped_count=0
    
    if [[ $total_packages -eq 0 ]]; then
        echo -e "${YELLOW}‚ö†${RESET} No packages specified for installation"
        return 0
    fi
    
    echo -e "${CYAN}${BOLD}Installing $total_packages packages...${RESET}"
    echo
    
    # Process packages with progress tracking
    local current=0
    for package in "${packages[@]}"; do
        ((current++))
        local progress=$((current * 100 / total_packages))
        
        echo -e "${CYAN}Package $current/$total_packages (${progress}%):${RESET}"
        
        local status
        status=$(check_package_availability "$package")
        
        case "$status" in
            "installed")
                echo -e "${GREEN}‚úì${RESET} $package already installed"
                ((skipped_count++))
                ;;
            "available")
                if install_single_package "$package"; then
                    ((installed_count++))
                else
                    ((failed_count++))
                fi
                ;;
            "unavailable")
                echo -e "${RED}‚úó${RESET} $package not available in repositories"
                ((failed_count++))
                ;;
        esac
    done
    
    # Report results
    echo
    echo -e "${CYAN}${BOLD}Installation Summary:${RESET}"
    echo -e "  ${GREEN}‚úì${RESET} Installed: $installed_count"
    echo -e "  ${YELLOW}‚ö†${RESET} Skipped: $skipped_count"
    echo -e "  ${RED}‚úó${RESET} Failed: $failed_count"
}

# =============================================================================
# USER INTERFACE FUNCTIONS
# =============================================================================

show_category_analysis() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        echo -e "${RED}‚úó${RESET} Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}Analyzing $cat_name Tools${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    
    # Show animated analysis
    if run_with_ui "python3 $CACHE_DIR/tool_analyzer.py analyze_category '$(echo "$cat_info" | cut -d':' -f3)'" "Scanning BlackArch repository for $cat_name tools" "wave" "Analysis completed" "Analysis failed"; then
        
        # Get and display results
        local analysis_result
        analysis_result=$(analyze_category_tools "$key")
        
        local tool_count=0
        local available_tools=()
        
        # Parse analysis results
        while IFS= read -r line; do
            if [[ "$line" =~ ^CATEGORY_COUNT:([0-9]+)$ ]]; then
                tool_count=${BASH_REMATCH[1]}
            elif [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
                available_tools+=("${BASH_REMATCH[1]}")
            fi
        done <<< "$analysis_result"
        
        echo
        echo -e "${GREEN}${BOLD}Found $tool_count tools in $cat_name category${RESET}"
        
        if [[ ${#available_tools[@]} -gt 0 ]]; then
            echo
            echo -e "${CYAN}Available tools (showing first 20):${RESET}"
            local count=0
            for tool in "${available_tools[@]}"; do
                if [[ $count -ge 20 ]]; then
                    echo -e "  ${DIM}... and $((tool_count - 20)) more tools${RESET}"
                    break
                fi
                
                # Check installation status
                local status
                status=$(check_package_availability "$tool")
                case "$status" in
                    "installed") echo -e "  ${GREEN}‚úì${RESET} $tool ${DIM}(installed)${RESET}" ;;
                    "available") echo -e "  ${CYAN}‚Ä¢${RESET} $tool" ;;
                    "unavailable") echo -e "  ${RED}‚úó${RESET} $tool ${DIM}(unavailable)${RESET}" ;;
                esac
                ((count++))
            done
        else
            echo -e "${YELLOW}No tools found matching this category${RESET}"
        fi
    fi
    
    echo
}

install_category_dynamic() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        echo -e "${RED}‚úó${RESET} Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}Installing $cat_name Tools${RESET}"
    
    # Get dynamic package list with UI
    local packages=()
    if run_with_ui "python3 $CACHE_DIR/tool_analyzer.py analyze_category '$(echo "$cat_info" | cut -d':' -f3)'" "Preparing package list" "dots"; then
        local analysis_result
        analysis_result=$(analyze_category_tools "$key")
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
                packages+=("${BASH_REMATCH[1]}")
            fi
        done <<< "$analysis_result"
    fi
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        echo -e "${YELLOW}‚ö†${RESET} No packages found for $cat_name"
        return 1
    fi
    
    install_packages "${packages[@]}"
}

custom_package_selection() {
    echo -e "${CYAN}${BOLD}Custom Package Selection${RESET}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo
    echo -e "${YELLOW}Enter package names separated by spaces.${RESET}"
    echo -e "${DIM}Example: nmap nikto sqlmap burpsuite metasploit${RESET}"
    echo
    
    read -p "Packages to install: " -r packages_input
    
    if [[ -n "$packages_input" ]]; then
        read -ra selected_packages <<< "$packages_input"
        
        echo -e "\n${CYAN}Selected packages:${RESET}"
        for package in "${selected_packages[@]}"; do
            local status
            status=$(check_package_availability "$package")
            case "$status" in
                "installed") echo -e "  ${GREEN}‚úì${RESET} $package (already installed)" ;;
                "available") echo -e "  ${CYAN}‚Ñπ${RESET} $package (available)" ;;
                "unavailable") echo -e "  ${RED}‚úó${RESET} $package (not found)" ;;
            esac
        done
        
        echo
        read -p "Proceed with installation? [Y/n]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_packages "${selected_packages[@]}"
            save_installation_state "custom" "${selected_packages[@]}"
        fi
    else
        echo -e "${YELLOW}‚ö†${RESET} No packages specified"
    fi
}

# =============================================================================
# COMMAND LINE ARGUMENT PARSING
# =============================================================================

show_help() {
    cat << 'HELP_TEXT'
kygoX v0.3.0 Aurora - Arch Linux Security Testing Suite

USAGE:
    sudo ./kygox [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be installed without installing
    -f, --force            Force installation of packages
    --no-auto-fix          Disable automatic error fixing
    --update-db            Update BlackArch database and exit
    --cleanup              Enter cleanup mode directly
    --install-updater      Install auto-updater and exit
    --remove-updater       Remove auto-updater and exit

EXAMPLES:
    sudo ./kygox                    # Interactive mode with animated UI
    sudo ./kygox -v                 # Verbose interactive mode
    sudo ./kygox --dry-run          # Preview installations
    sudo ./kygox --cleanup          # System cleanup mode
    sudo ./kygox --install-updater  # Install auto-updater

NEW FEATURES (v0.3.0):
    ‚Ä¢ Smart cleanup system with backup restoration
    ‚Ä¢ C-based auto-updater for system maintenance
    ‚Ä¢ Enhanced state management and tracking
    ‚Ä¢ Complete system restoration capabilities
    ‚Ä¢ Automated tool updates based on installation mode

CATEGORIES:
    1. Information Gathering    - Network reconnaissance and OSINT tools
    2. Vulnerability Analysis   - Security assessment and scanning tools  
    3. Web Application Analysis - Web security testing frameworks
    4. Password Attacks         - Password cracking and analysis tools
    5. Wireless Attacks         - WiFi and wireless security tools
    6. Exploitation Tools       - Penetration testing frameworks
    7. Digital Forensics        - Forensics and data recovery tools
    8. Sniffing & Spoofing      - Network monitoring and manipulation

SUPPORT:
    Repository: https://github.com/0xb0rn3/kygox
    Author: 0xb0rn3 (IG: theehiv3, X: 0xbv1)
HELP_TEXT
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --no-auto-fix)
                AUTO_FIX=false
                shift
                ;;
            --update-db)
                setup_blackarch_repository
                get_total_blackarch_tools
                echo "BlackArch repository updated. Total tools available: $TOTAL_AVAILABLE_TOOLS"
                exit 0
                ;;
            --cleanup)
                init_state_management
                create_cleanup_tool
                cleanup_management_menu
                exit 0
                ;;
            --install-updater)
                install_auto_updater
                exit 0
                ;;
            --remove-updater)
                remove_auto_updater
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

# =============================================================================
# CLEANUP AND MAIN EXECUTION
# =============================================================================

cleanup_on_exit() {
    local exit_code="${1:-0}"
    
    log_message "INFO" "Performing cleanup operations..."
    
    # Reset umask if needed
    reset_secure_umask
    
    # Kill any background processes
    jobs -p 2>/dev/null | xargs -r kill 2>/dev/null || true
    
    # Clean temporary files
    rm -rf "$CACHE_DIR" 2>/dev/null || true
    
    log_message "INFO" "kygoX session ended"
    exit "$exit_code"
}

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Initialize state management
    init_state_management
    
    # Create cache directory
    mkdir -p "$CACHE_DIR"
    
    # Display banner with tool count
    display_banner
    
    # System validation and setup
    validate_system
    install_dependencies
    setup_blackarch_repository
    
    # Create analysis tools
    create_ui_loader
    create_tool_analyzer
    create_cleanup_tool
    
    # Show status
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}DRY RUN MODE - No packages will be installed${RESET}"
        echo
    fi
    
    # Main interactive loop
    while true; do
        show_enhanced_main_menu
        read -p "Select option: " -r choice
        echo
        
        if ! handle_enhanced_menu_selection "$choice"; then
            echo -e "${RED}Invalid selection. Please try again.${RESET}"
            sleep 1
        fi
        
        echo
        read -p "Press Enter to continue..." -r
    done
}

# Signal handlers
trap 'cleanup_on_exit 130' INT TERM
trap 'cleanup_on_exit $?' EXIT

# Execute main function with all arguments
main "$@"
