#!/usr/bin/env bash
#
# kygoX - Arch Linux Security Testing Suite
# Version 0.2.0 Phoenix
# Author: 0xb0rn3 | Contact: IG: theehiv3 | X: 0xbv1 | Email: q4n0@proton.me
#
# Advanced security toolkit installer with animated UI interface
#

set -euo pipefail

# =============================================================================
# CONFIGURATION
# =============================================================================

readonly SCRIPT_VERSION="0.2.0"
readonly SCRIPT_CODENAME="Phoenix"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$HOME/.kygox"
readonly CACHE_DIR="/tmp/kygox_cache"

# BlackArch Repository Configuration (Original)
readonly BLACKARCH_STRAP_URL="https://blackarch.org/strap.sh"
readonly BLACKARCH_KEYRING_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst"
readonly BLACKARCH_KEYRING_SIG_URL="https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst.sig"
readonly BLACKARCH_MIRROR_URL="https://blackarch.org/blackarch-mirrorlist"
readonly BLACKARCH_GPG_KEY="4345771566D76038C7FEB43863EC0ADBEA87E4E3"
readonly BLACKARCH_MIRROR_FILE="blackarch-mirrorlist"

# Colors and UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Global State
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_INSTALL=false
declare -g AUTO_FIX=true
declare -g TOTAL_AVAILABLE_TOOLS=0
declare -g OLD_UMASK=""

# Package Categories with keywords for dynamic detection
declare -A CATEGORIES=(
    ["1"]="information-gathering:Information Gathering:nmap scan recon enum discover finger whois dns"
    ["2"]="vulnerability-analysis:Vulnerability Analysis:vuln cve exploit nikto openvas lynis audit"
    ["3"]="web-applications:Web Application Analysis:web http burp zap dir url spider crawl"
    ["4"]="password-attacks:Password Attacks:pass hash crack brute john hydra medusa wordlist"
    ["5"]="wireless-attacks:Wireless Attacks:wifi wireless air bluetooth rfid 802.11"
    ["6"]="exploitation:Exploitation Tools:exploit shell payload metasploit framework beef"
    ["7"]="forensics:Digital Forensics:forensic recover carve timeline memory disk volatility"
    ["8"]="sniffing-spoofing:Sniffing & Spoofing:sniff capture spoof mitm proxy wireshark"
)

# =============================================================================
# ANIMATED UI SYSTEM
# =============================================================================

# Create Python UI loader system
create_ui_loader() {
    cat > "$CACHE_DIR/ui_loader.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Animated UI Loader System
Provides clean animated interfaces for all system operations
"""

import sys
import time
import threading
import subprocess
import signal
from itertools import cycle

class AnimatedLoader:
    def __init__(self):
        self.running = False
        self.thread = None
        
    def spinner_animation(self, message, spinner_chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"):
        """Display animated spinner with message"""
        spinner = cycle(spinner_chars)
        while self.running:
            sys.stdout.write(f'\r\033[96m{next(spinner)}\033[0m {message}')
            sys.stdout.flush()
            time.sleep(0.1)
    
    def progress_bar(self, message, duration=10, width=40):
        """Display animated progress bar"""
        for i in range(width + 1):
            if not self.running:
                break
            percent = int((i / width) * 100)
            filled = '█' * i
            empty = '░' * (width - i)
            sys.stdout.write(f'\r\033[94m[{filled}{empty}]\033[0m {percent}% {message}')
            sys.stdout.flush()
            time.sleep(duration / width)
    
    def dots_animation(self, message, max_dots=3):
        """Display animated dots"""
        while self.running:
            for dots in range(max_dots + 1):
                if not self.running:
                    break
                dots_str = '.' * dots + ' ' * (max_dots - dots)
                sys.stdout.write(f'\r\033[93m{message}{dots_str}\033[0m')
                sys.stdout.flush()
                time.sleep(0.5)
    
    def wave_animation(self, message):
        """Display wave animation"""
        wave_chars = "▁▂▃▄▅▆▇█▇▆▅▄▃▂"
        wave = cycle(wave_chars)
        while self.running:
            wave_display = ''.join([next(wave) for _ in range(8)])
            sys.stdout.write(f'\r\033[95m{wave_display}\033[0m {message} \033[95m{wave_display}\033[0m')
            sys.stdout.flush()
            time.sleep(0.1)
    
    def start_animation(self, animation_type, message, duration=None):
        """Start specific animation type"""
        self.running = True
        
        if animation_type == "spinner":
            self.thread = threading.Thread(target=self.spinner_animation, args=(message,))
        elif animation_type == "progress":
            self.thread = threading.Thread(target=self.progress_bar, args=(message, duration or 10))
        elif animation_type == "dots":
            self.thread = threading.Thread(target=self.dots_animation, args=(message,))
        elif animation_type == "wave":
            self.thread = threading.Thread(target=self.wave_animation, args=(message,))
        else:
            self.thread = threading.Thread(target=self.spinner_animation, args=(message,))
        
        self.thread.daemon = True
        self.thread.start()
    
    def stop_animation(self, success_message=None, error_message=None):
        """Stop animation and show result"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1)
        
        # Clear line
        sys.stdout.write('\r' + ' ' * 80 + '\r')
        
        if success_message:
            print(f'\033[92m✓\033[0m {success_message}')
        elif error_message:
            print(f'\033[91m✗\033[0m {error_message}')
        
        sys.stdout.flush()

class UIManager:
    def __init__(self):
        self.loader = AnimatedLoader()
        
    def run_with_loader(self, command, animation_type="spinner", message="Processing", 
                       success_msg=None, error_msg=None, timeout=300):
        """Run command with animated loader"""
        
        # Start animation
        self.loader.start_animation(animation_type, message)
        
        try:
            # Run command silently
            if isinstance(command, str):
                result = subprocess.run(command, shell=True, capture_output=True, 
                                      text=True, timeout=timeout)
            else:
                result = subprocess.run(command, capture_output=True, 
                                      text=True, timeout=timeout)
            
            # Stop animation with result
            if result.returncode == 0:
                self.loader.stop_animation(success_message=success_msg or f"{message} completed")
                return True
            else:
                self.loader.stop_animation(error_message=error_msg or f"{message} failed")
                return False
                
        except subprocess.TimeoutExpired:
            self.loader.stop_animation(error_message=f"{message} timed out")
            return False
        except Exception as e:
            self.loader.stop_animation(error_message=f"{message} error: {str(e)}")
            return False
    
    def run_multi_step(self, steps):
        """Run multiple steps with individual loaders"""
        results = []
        
        for step in steps:
            command = step.get('command')
            animation = step.get('animation', 'spinner')
            message = step.get('message', 'Processing')
            success_msg = step.get('success_msg')
            error_msg = step.get('error_msg')
            timeout = step.get('timeout', 300)
            
            result = self.run_with_loader(command, animation, message, 
                                        success_msg, error_msg, timeout)
            results.append(result)
            
            if not result and step.get('critical', False):
                break
        
        return results

def main():
    if len(sys.argv) < 2:
        print("Usage: ui_loader.py <action> [args]")
        sys.exit(1)
    
    action = sys.argv[1]
    manager = UIManager()
    
    if action == "run_command":
        if len(sys.argv) < 4:
            print("Usage: ui_loader.py run_command <command> <message> [animation_type]")
            sys.exit(1)
        
        command = sys.argv[2]
        message = sys.argv[3]
        animation_type = sys.argv[4] if len(sys.argv) > 4 else "spinner"
        
        success = manager.run_with_loader(command, animation_type, message)
        sys.exit(0 if success else 1)
    
    elif action == "test_animations":
        # Test all animation types
        animations = [
            ("spinner", "Testing spinner animation"),
            ("progress", "Testing progress animation"),
            ("dots", "Testing dots animation"),
            ("wave", "Testing wave animation")
        ]
        
        for anim_type, message in animations:
            manager.loader.start_animation(anim_type, message)
            time.sleep(3)
            manager.loader.stop_animation(f"{anim_type.title()} animation complete")
            time.sleep(1)

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/ui_loader.py"
}

# Run command with animated UI
run_with_ui() {
    local command="$1"
    local message="$2"
    local animation_type="${3:-spinner}"
    local success_msg="${4:-}"
    local error_msg="${5:-}"
    
    if [[ -f "$CACHE_DIR/ui_loader.py" ]]; then
        if python3 "$CACHE_DIR/ui_loader.py" run_command "$command" "$message" "$animation_type"; then
            [[ -n "$success_msg" ]] && echo -e "${GREEN}✓${RESET} $success_msg"
            return 0
        else
            [[ -n "$error_msg" ]] && echo -e "${RED}✗${RESET} $error_msg"
            return 1
        fi
    else
        # Fallback to direct execution
        eval "$command" &>/dev/null
        return $?
    fi
}

# Multi-step operation with progress tracking
run_multi_step_ui() {
    local steps=("$@")
    local current=0
    local total=${#steps[@]}
    
    for step in "${steps[@]}"; do
        ((current++))
        local progress=$((current * 100 / total))
        
        IFS='|' read -r command message animation success_msg error_msg <<< "$step"
        
        echo -e "${CYAN}Step $current/$total (${progress}%):${RESET}"
        
        if run_with_ui "$command" "$message" "$animation" "$success_msg" "$error_msg"; then
            continue
        else
            echo -e "${RED}Multi-step operation failed at step $current${RESET}"
            return 1
        fi
    done
    
    echo -e "${GREEN}${BOLD}All steps completed successfully!${RESET}"
    return 0
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Logging with timestamps (only to file, not console)
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Log to file only
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox.log"
}

# Error handling
error_exit() {
    local exit_code="${2:-1}"
    log_message "ERROR" "$1"
    echo -e "${RED}${BOLD}Error:${RESET} $1" >&2
    cleanup_on_exit "$exit_code"
}

# Banner display with tool count
display_banner() {
    clear
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║  ██╗  ██╗██╗   ██╗ ██████╗  ██████╗ ██╗  ██╗                               ║
║  ██║ ██╔╝╚██╗ ██╔╝██╔════╝ ██╔═══██╗╚██╗██╔╝                               ║
║  █████╔╝  ╚████╔╝ ██║  ███╗██║   ██║ ╚███╔╝                                ║
║  ██╔═██╗   ╚██╔╝  ██║   ██║██║   ██║ ██╔██╗                                ║
║  ██║  ██╗   ██║   ╚██████╔╝╚██████╔╝██╔╝ ██╗                               ║
║  ╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝                               ║
║                                                                              ║
║             kygoX - Arch Linux Security Testing Suite                       ║
║                      Version 0.2.0 Phoenix                                  ║
║                   By 0xb0rn3 | IG: theehiv3 | X: 0xbv1                     ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
EOF

    echo
    echo -e "${CYAN}${BOLD}System Dashboard:${RESET}"
    echo -e "  ${WHITE}•${RESET} OS: $(get_system_info)"
    echo -e "  ${WHITE}•${RESET} Kernel: $(uname -r)"
    echo -e "  ${WHITE}•${RESET} User: $ORIGINAL_USER"
    echo -e "  ${WHITE}•${RESET} Python: $(get_python_version)"
    
    # Get and display tool count
    local tool_count=$(get_total_blackarch_tools)
    if [[ $tool_count -gt 0 ]]; then
        echo -e "  ${WHITE}•${RESET} Available BlackArch Tools: ${GREEN}${BOLD}$tool_count${RESET}"
    else
        echo -e "  ${WHITE}•${RESET} Available BlackArch Tools: ${YELLOW}Checking...${RESET}"
    fi
    echo
}

# System info functions
get_system_info() {
    if [[ -f /etc/os-release ]]; then
        grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2
    else
        echo "Unknown Linux Distribution"
    fi
}

get_python_version() {
    if command -v python3 &>/dev/null; then
        python3 --version | cut -d' ' -f2
    else
        echo "Not installed"
    fi
}

# =============================================================================
# BLACKARCH REPOSITORY SETUP (Original strap.sh with UI)
# =============================================================================

# Set secure umask
set_secure_umask() {
    OLD_UMASK=$(umask)
    umask 0022
}

# Reset umask
reset_secure_umask() {
    if [[ -n "$OLD_UMASK" ]]; then
        umask "$OLD_UMASK"
    fi
}

# Check internet connectivity
check_blackarch_connectivity() {
    log_message "DEBUG" "Testing connectivity to BlackArch repository..."
    
    if ! curl -s --connect-timeout 8 "https://blackarch.org/" > /dev/null 2>&1; then
        return 1
    fi
    
    return 0
}

# Add necessary GPG options
configure_gpg_for_blackarch() {
    log_message "DEBUG" "Configuring GPG for BlackArch repository..."
    
    local gpg_conf='/etc/pacman.d/gnupg/gpg.conf'
    
    if [[ -f "$gpg_conf" ]] && ! grep -q 'allow-weak-key-signatures' "$gpg_conf"; then
        echo 'allow-weak-key-signatures' >> "$gpg_conf"
    fi
    
    return 0
}

# Create temporary directory
make_blackarch_tmp_dir() {
    local tmp_dir
    tmp_dir=$(mktemp -d /tmp/blackarch_strap.XXXXXXXX)
    
    if [[ ! -d "$tmp_dir" ]]; then
        error_exit "Could not create temporary directory"
    fi
    
    trap "rm -rf '$tmp_dir'" EXIT
    cd "$tmp_dir" || error_exit "Could not enter temporary directory"
    
    log_message "DEBUG" "Created temporary directory: $tmp_dir"
}

# Download BlackArch keyring
fetch_blackarch_keyring() {
    log_message "DEBUG" "Downloading BlackArch keyring..."
    
    if ! curl -s -O "$BLACKARCH_KEYRING_URL"; then
        return 1
    fi
    
    if ! curl -s -O "$BLACKARCH_KEYRING_SIG_URL"; then
        return 1
    fi
    
    return 0
}

# Verify BlackArch keyring signature
verify_blackarch_keyring() {
    log_message "DEBUG" "Verifying BlackArch keyring signature..."
    
    local keyservers=(
        "keyserver.ubuntu.com"
        "hkps://keyserver.ubuntu.com:443"
        "hkp://pgp.mit.edu:80"
    )
    
    local key_imported=false
    
    for keyserver in "${keyservers[@]}"; do
        if gpg --keyserver "$keyserver" --recv-keys "$BLACKARCH_GPG_KEY" > /dev/null 2>&1; then
            key_imported=true
            break
        fi
    done
    
    if [[ "$key_imported" != "true" ]]; then
        return 1
    fi
    
    if ! gpg --keyserver-options no-auto-key-retrieve \
        --with-fingerprint blackarch-keyring.pkg.tar.zst.sig > /dev/null 2>&1; then
        return 1
    fi
    
    return 0
}

# Clean up signature files
cleanup_signature_files() {
    rm -f *.pkg.tar.zst.sig 2>/dev/null || true
}

# Initialize pacman GPG
initialize_pacman_gpg() {
    if ! pacman-key --init > /dev/null 2>&1; then
        return 1
    fi
    return 0
}

# Install BlackArch keyring
install_blackarch_keyring() {
    local keyring_pkg
    keyring_pkg=$(find . -name "blackarch-keyring*.pkg.tar.zst" -type f | head -1)
    
    if [[ -z "$keyring_pkg" ]]; then
        return 1
    fi
    
    if ! pacman --config /dev/null --noconfirm -U "$keyring_pkg" > /dev/null 2>&1; then
        return 1
    fi
    
    pacman-key --populate > /dev/null 2>&1 || true
    return 0
}

# Download BlackArch mirror list
fetch_blackarch_mirrors() {
    local mirror_path="/etc/pacman.d"
    local mirror_file="$mirror_path/$BLACKARCH_MIRROR_FILE"
    
    if ! curl -s "$BLACKARCH_MIRROR_URL" -o "$mirror_file"; then
        return 1
    fi
    
    return 0
}

# Update pacman.conf
update_pacman_conf_for_blackarch() {
    sed -i '/blackarch/{N;d}' /etc/pacman.conf 2>/dev/null || true
    
    cat >> "/etc/pacman.conf" << EOF
[blackarch]
Include = /etc/pacman.d/$BLACKARCH_MIRROR_FILE
EOF
    
    return 0
}

# Synchronize package databases
synchronize_blackarch_databases() {
    if pacman -Syy > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Install BlackArch officials meta-package
install_blackarch_officials() {
    if pacman -S --noconfirm --needed blackarch-officials > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Main BlackArch setup with animated UI
setup_blackarch_repository() {
    echo -e "${CYAN}${BOLD}Setting up BlackArch Repository${RESET}"
    echo
    
    # Check if already configured
    if grep -q "\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo -e "${GREEN}✓${RESET} BlackArch repository already configured"
        get_total_blackarch_tools > /dev/null
        return 0
    fi
    
    # Multi-step setup with UI loaders
    local setup_steps=(
        "check_blackarch_connectivity|Testing internet connectivity|spinner|Connection verified|Connection failed"
        "set_secure_umask && make_blackarch_tmp_dir|Preparing workspace|dots|Workspace ready|Workspace setup failed"
        "configure_gpg_for_blackarch|Configuring GPG settings|spinner|GPG configured|GPG configuration failed"
        "fetch_blackarch_keyring|Downloading BlackArch keyring|progress|Keyring downloaded|Keyring download failed"
        "verify_blackarch_keyring|Verifying keyring signatures|wave|Keyring verified|Keyring verification failed"
        "cleanup_signature_files && initialize_pacman_gpg|Initializing package manager|spinner|Package manager ready|Initialization failed"
        "install_blackarch_keyring|Installing BlackArch keyring|progress|Keyring installed|Keyring installation failed"
        "fetch_blackarch_mirrors|Configuring repository mirrors|dots|Mirrors configured|Mirror configuration failed"
        "update_pacman_conf_for_blackarch|Updating system configuration|spinner|Configuration updated|Configuration failed"
        "synchronize_blackarch_databases|Synchronizing package databases|progress|Databases synchronized|Synchronization failed"
        "install_blackarch_officials|Installing BlackArch meta-package|wave|Meta-package installed|Meta-package installation failed"
    )
    
    if run_multi_step_ui "${setup_steps[@]}"; then
        reset_secure_umask
        get_total_blackarch_tools > /dev/null
        echo
        echo -e "${GREEN}${BOLD}BlackArch repository setup completed successfully!${RESET}"
        return 0
    else
        reset_secure_umask
        error_exit "BlackArch repository setup failed"
        return 1
    fi
}

# =============================================================================
# DYNAMIC TOOL ANALYSIS SYSTEM
# =============================================================================

# Get total available BlackArch tools
get_total_blackarch_tools() {
    if [[ $TOTAL_AVAILABLE_TOOLS -eq 0 ]]; then
        log_message "DEBUG" "Calculating total available BlackArch tools..."
        
        if pacman -Sl blackarch &>/dev/null; then
            TOTAL_AVAILABLE_TOOLS=$(pacman -Sl blackarch 2>/dev/null | wc -l)
        else
            TOTAL_AVAILABLE_TOOLS=0
        fi
        
        log_message "DEBUG" "Found $TOTAL_AVAILABLE_TOOLS total BlackArch tools"
    fi
    
    echo $TOTAL_AVAILABLE_TOOLS
}

# Create Python tool analyzer
create_tool_analyzer() {
    cat > "$CACHE_DIR/tool_analyzer.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Tool Analyzer
Analyzes available BlackArch tools and categorizes them dynamically
"""

import sys
import subprocess
import re
from collections import defaultdict

class ToolAnalyzer:
    def __init__(self, repo_name="blackarch"):
        self.repo_name = repo_name
        self.categories = {}
        
    def get_available_packages(self):
        """Get all available packages from BlackArch repository"""
        try:
            result = subprocess.run(
                ['pacman', '-Sl', self.repo_name],
                capture_output=True,
                text=True,
                check=True
            )
            packages = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        packages.append(parts[1])
            return packages
        except subprocess.CalledProcessError:
            return []
    
    def analyze_category(self, category_keywords):
        """Analyze tools available for a specific category"""
        packages = self.get_available_packages()
        if not packages:
            return []
        
        keywords = category_keywords.split()
        matching_packages = []
        
        for package in packages:
            package_lower = package.lower()
            if any(keyword in package_lower for keyword in keywords):
                matching_packages.append(package)
        
        return matching_packages

def main():
    if len(sys.argv) < 2:
        print("Usage: tool_analyzer.py <action> [args]", file=sys.stderr)
        sys.exit(1)
    
    action = sys.argv[1]
    analyzer = ToolAnalyzer()
    
    if action == "count_total":
        packages = analyzer.get_available_packages()
        print(len(packages))
    
    elif action == "analyze_category":
        if len(sys.argv) < 3:
            print("Usage: tool_analyzer.py analyze_category <keywords>", file=sys.stderr)
            sys.exit(1)
        
        keywords = sys.argv[2]
        matching_packages = analyzer.analyze_category(keywords)
        
        print(f"CATEGORY_COUNT:{len(matching_packages)}")
        for package in matching_packages[:20]:  # Show first 20
            print(f"PACKAGE:{package}")
        
        if len(matching_packages) > 20:
            print(f"MORE:{len(matching_packages) - 20}")

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/tool_analyzer.py"
}

# Analyze category tools with UI
analyze_category_tools() {
    local category_key="$1"
    
    if [[ ! "${CATEGORIES[$category_key]:-}" ]]; then
        echo "0"
        return
    fi
    
    local cat_info="${CATEGORIES[$category_key]}"
    local keywords=$(echo "$cat_info" | cut -d':' -f3)
    
    if [[ -f "$CACHE_DIR/tool_analyzer.py" ]]; then
        python3 "$CACHE_DIR/tool_analyzer.py" analyze_category "$keywords" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# =============================================================================
# SYSTEM VALIDATION
# =============================================================================

validate_system() {
    echo -e "${CYAN}Validating system requirements...${RESET}"
    
    # Check root privileges
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    
    # Validate original user
    if [[ -z "$ORIGINAL_USER" || "$ORIGINAL_USER" == "root" ]]; then
        error_exit "Cannot determine original user. Please run with 'sudo $0'"
    fi
    
    # Check for Arch-based system
    if ! command -v pacman &>/dev/null; then
        if command -v apt &>/dev/null; then
            error_exit "Debian-based system detected. Use KRILIN instead: https://github.com/0xb0rn3/krilin"
        else
            error_exit "This tool requires an Arch-based distribution with pacman"
        fi
    fi
    
    # Check internet connectivity with UI
    if ! run_with_ui "ping -c 1 -W 3 archlinux.org" "Checking internet connectivity" "spinner" "Internet connection verified" "Internet connection required"; then
        error_exit "Internet connectivity required for package downloads"
    fi
    
    # Check disk space
    local available_space
    available_space=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
    if [[ $available_space -lt 5 ]]; then
        echo -e "${YELLOW}⚠${RESET} Only ${available_space}GB available. Some installations may fail."
    fi
    
    echo -e "${GREEN}✓${RESET} System validation completed"
}

# Install dependencies with UI
install_dependencies() {
    echo -e "${CYAN}Installing required dependencies...${RESET}"
    
    local required_packages=("curl" "wget" "python" "python-pip" "base-devel")
    local missing_packages=()
    
    for package in "${required_packages[@]}"; do
        if ! pacman -Qi "$package" &>/dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        local install_steps=(
            "pacman -Sy --noconfirm|Updating package databases|progress|Package databases updated|Database update failed"
            "pacman -S --noconfirm --needed ${missing_packages[*]}|Installing dependencies|wave|Dependencies installed|Dependency installation failed"
        )
        
        if run_multi_step_ui "${install_steps[@]}"; then
            echo -e "${GREEN}✓${RESET} Dependencies installed successfully"
        else
            error_exit "Failed to install required dependencies"
        fi
    else
        echo -e "${GREEN}✓${RESET} All dependencies already satisfied"
    fi
}

# Check package availability
check_package_availability() {
    local package="$1"
    
    # Check if already installed
    if pacman -Qi "$package" &>/dev/null; then
        echo "installed"
        return 0
    fi
    
    # Check if available in any repository
    if pacman -Si "$package" &>/dev/null 2>&1; then
        echo "available"
        return 0
    fi
    
    echo "unavailable"
    return 1
}

# =============================================================================
# ERROR HANDLING SYSTEM
# =============================================================================

create_error_handler() {
    cat > "$CACHE_DIR/error_handler.py" << 'PYTHON_SCRIPT'
#!/usr/bin/env python3
"""
kygoX Error Handler and System Monitor
Monitors installation processes and handles errors intelligently
"""

import sys
import subprocess
import time
import signal
import os
from pathlib import Path

class InstallationMonitor:
    def __init__(self, log_file):
        self.log_file = Path(log_file)
        self.errors = []
        self.warnings = []
        self.running = True
        
    def monitor_installation(self, package_name, timeout=300):
        """Monitor package installation and detect errors"""
        start_time = time.time()
        
        while self.running and (time.time() - start_time) < timeout:
            if self.log_file.exists():
                try:
                    with open(self.log_file, 'r') as f:
                        lines = f.readlines()
                        
                    # Check last few lines for errors
                    recent_lines = lines[-10:] if len(lines) > 10 else lines
                    
                    for line in recent_lines:
                        line = line.strip().lower()
                        
                        # Critical errors that should stop installation
                        if any(error in line for error in [
                            'error: failed to commit transaction',
                            'error: target not found',
                            'error: failed retrieving file',
                            'conflicting files',
                            'could not resolve host',
                            'connection timed out',
                            'failed to synchronize',
                            'unable to lock database'
                        ]):
                            self.errors.append(line)
                            return False
                        
                        # Success indicators
                        if any(success in line for success in [
                            f'successfully installed {package_name}',
                            'installation completed',
                            'success',
                            'nothing to do'
                        ]):
                            return True
                            
                except IOError:
                    pass
            
            time.sleep(1)
        
        return None  # Timeout or process still running
    
    def auto_fix_common_issues(self):
        """Attempt to automatically fix common issues"""
        fixes_applied = []
        
        # Kill any hanging pacman processes
        try:
            subprocess.run(['pkill', '-f', 'pacman'], check=False, capture_output=True)
            fixes_applied.append("Killed hanging pacman processes")
        except:
            pass
        
        # Remove lock files
        lock_files = ['/var/lib/pacman/db.lck']
        for lock_file in lock_files:
            if os.path.exists(lock_file):
                try:
                    os.remove(lock_file)
                    fixes_applied.append(f"Removed lock file: {lock_file}")
                except:
                    pass
        
        # Update package database
        try:
            subprocess.run(['pacman', '-Sy'], check=True, capture_output=True)
            fixes_applied.append("Updated package database")
        except subprocess.CalledProcessError:
            pass
        
        return fixes_applied

def main():
    if len(sys.argv) < 3:
        print("Usage: error_handler.py <package_name> <log_file>", file=sys.stderr)
        sys.exit(1)
    
    package_name = sys.argv[1]
    log_file = sys.argv[2]
    
    monitor = InstallationMonitor(log_file)
    result = monitor.monitor_installation(package_name)
    
    if result is True:
        print("SUCCESS")
    elif result is False:
        print("ERROR")
        auto_fixes = monitor.auto_fix_common_issues()
        if auto_fixes:
            print("AUTO_FIXES_APPLIED:", ";".join(auto_fixes))
    else:
        print("TIMEOUT")
    
    sys.exit(0 if result is True else 1)

if __name__ == "__main__":
    main()
PYTHON_SCRIPT

    chmod +x "$CACHE_DIR/error_handler.py"
}

# =============================================================================
# PACKAGE INSTALLATION ENGINE
# =============================================================================

install_single_package() {
    local package="$1"
    local max_retries=3
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "${GREEN}✓${RESET} [DRY RUN] Would install: $package"
            return 0
        fi
        
        # Install with UI loader
        if run_with_ui "pacman -S --noconfirm --needed $package" "Installing $package" "progress" "Installed $package" "Failed to install $package"; then
            return 0
        else
            ((retry_count++))
            
            # Auto-fix if enabled
            if [[ "$AUTO_FIX" == "true" && $retry_count -lt $max_retries ]]; then
                echo -e "${YELLOW}⚠${RESET} Attempting auto-fix (attempt $retry_count)..."
                
                # Apply fixes with UI
                run_with_ui "rm -f /var/lib/pacman/db.lck" "Removing lock files" "spinner"
                run_with_ui "pacman -Sy --noconfirm" "Updating databases" "dots"
                
                if [[ $retry_count -gt 1 ]]; then
                    run_with_ui "pacman -Scc --noconfirm" "Clearing cache" "spinner"
                fi
                
                sleep 2
            fi
        fi
    done
    
    echo -e "${RED}✗${RESET} Failed to install $package after $max_retries attempts"
    return 1
}

install_packages() {
    local packages=("$@")
    local total_packages=${#packages[@]}
    local installed_count=0
    local failed_count=0
    local skipped_count=0
    
    if [[ $total_packages -eq 0 ]]; then
        echo -e "${YELLOW}⚠${RESET} No packages specified for installation"
        return 0
    fi
    
    echo -e "${CYAN}${BOLD}Installing $total_packages packages...${RESET}"
    echo
    
    # Process packages with progress tracking
    local current=0
    for package in "${packages[@]}"; do
        ((current++))
        local progress=$((current * 100 / total_packages))
        
        echo -e "${CYAN}Package $current/$total_packages (${progress}%):${RESET}"
        
        local status
        status=$(check_package_availability "$package")
        
        case "$status" in
            "installed")
                echo -e "${GREEN}✓${RESET} $package already installed"
                ((skipped_count++))
                ;;
            "available")
                if install_single_package "$package"; then
                    ((installed_count++))
                else
                    ((failed_count++))
                fi
                ;;
            "unavailable")
                echo -e "${RED}✗${RESET} $package not available in repositories"
                ((failed_count++))
                ;;
        esac
    done
    
    # Report results
    echo
    echo -e "${CYAN}${BOLD}Installation Summary:${RESET}"
    echo -e "  ${GREEN}✓${RESET} Installed: $installed_count"
    echo -e "  ${YELLOW}⚠${RESET} Skipped: $skipped_count"
    echo -e "  ${RED}✗${RESET} Failed: $failed_count"
}

# =============================================================================
# USER INTERFACE WITH ANIMATED ANALYSIS
# =============================================================================

show_main_menu() {
    echo -e "${CYAN}${BOLD}kygoX Security Toolkit Selection${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    
    # Show total available tools
    local total_tools=$(get_total_blackarch_tools)
    if [[ $total_tools -gt 0 ]]; then
        echo -e "${GREEN}${BOLD}📊 BlackArch Arsenal: $total_tools tools available${RESET}"
    else
        echo -e "${YELLOW}${BOLD}📊 Scanning BlackArch repository...${RESET}"
    fi
    echo
    
    for key in $(printf '%s\n' "${!CATEGORIES[@]}" | sort -n); do
        local cat_info="${CATEGORIES[$key]}"
        local cat_name=$(echo "$cat_info" | cut -d':' -f2)
        
        echo -e "  ${CYAN}$key${RESET}) $cat_name ${DIM}(analyzing...)${RESET}"
    done
    
    echo
    echo -e "${YELLOW}${BOLD}Special Options:${RESET}"
    echo -e "  ${CYAN}9${RESET}) Custom Package Selection"
    echo -e "  ${CYAN}0${RESET}) System Information & Repository Status"
    echo -e "  ${CYAN}q${RESET}) Quit"
    echo
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
}

show_category_analysis() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        echo -e "${RED}✗${RESET} Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}Analyzing $cat_name Tools${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    
    # Show animated analysis
    if run_with_ui "python3 $CACHE_DIR/tool_analyzer.py analyze_category '$(echo "$cat_info" | cut -d':' -f3)'" "Scanning BlackArch repository for $cat_name tools" "wave" "Analysis completed" "Analysis failed"; then
        
        # Get and display results
        local analysis_result
        analysis_result=$(analyze_category_tools "$key")
        
        local tool_count=0
        local available_tools=()
        
        # Parse analysis results
        while IFS= read -r line; do
            if [[ "$line" =~ ^CATEGORY_COUNT:([0-9]+)$ ]]; then
                tool_count=${BASH_REMATCH[1]}
            elif [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
                available_tools+=("${BASH_REMATCH[1]}")
            fi
        done <<< "$analysis_result"
        
        echo
        echo -e "${GREEN}${BOLD}Found $tool_count tools in $cat_name category${RESET}"
        
        if [[ ${#available_tools[@]} -gt 0 ]]; then
            echo
            echo -e "${CYAN}Available tools (showing first 20):${RESET}"
            local count=0
            for tool in "${available_tools[@]}"; do
                if [[ $count -ge 20 ]]; then
                    echo -e "  ${DIM}... and $((tool_count - 20)) more tools${RESET}"
                    break
                fi
                
                # Check installation status
                local status
                status=$(check_package_availability "$tool")
                case "$status" in
                    "installed") echo -e "  ${GREEN}✓${RESET} $tool ${DIM}(installed)${RESET}" ;;
                    "available") echo -e "  ${CYAN}•${RESET} $tool" ;;
                    "unavailable") echo -e "  ${RED}✗${RESET} $tool ${DIM}(unavailable)${RESET}" ;;
                esac
                ((count++))
            done
        else
            echo -e "${YELLOW}No tools found matching this category${RESET}"
        fi
    fi
    
    echo
}

handle_menu_selection() {
    local choice="$1"
    
    case "$choice" in
        [1-8])
            show_category_analysis "$choice"
            echo
            read -p "Proceed with installation of this category? [Y/n]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                install_category_dynamic "$choice"
            fi
            ;;
        9)
            custom_package_selection
            ;;
        0)
            show_system_info
            ;;
        q|Q)
            exit 0
            ;;
        *)
            echo -e "${RED}✗${RESET} Invalid selection: $choice"
            return 1
            ;;
    esac
}

install_category_dynamic() {
    local key="$1"
    
    if [[ ! "${CATEGORIES[$key]:-}" ]]; then
        echo -e "${RED}✗${RESET} Invalid category: $key"
        return 1
    fi
    
    local cat_info="${CATEGORIES[$key]}"
    local cat_name=$(echo "$cat_info" | cut -d':' -f2)
    
    echo -e "${CYAN}${BOLD}Installing $cat_name Tools${RESET}"
    
    # Get dynamic package list with UI
    local packages=()
    if run_with_ui "python3 $CACHE_DIR/tool_analyzer.py analyze_category '$(echo "$cat_info" | cut -d':' -f3)'" "Preparing package list" "dots"; then
        local analysis_result
        analysis_result=$(analyze_category_tools "$key")
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^PACKAGE:(.+)$ ]]; then
                packages+=("${BASH_REMATCH[1]}")
            fi
        done <<< "$analysis_result"
    fi
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        echo -e "${YELLOW}⚠${RESET} No packages found for $cat_name"
        return 1
    fi
    
    install_packages "${packages[@]}"
}

custom_package_selection() {
    echo -e "${CYAN}${BOLD}Custom Package Selection${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    echo -e "${YELLOW}Enter package names separated by spaces.${RESET}"
    echo -e "${DIM}Example: nmap nikto sqlmap burpsuite metasploit${RESET}"
    echo
    
    read -p "Packages to install: " -r packages_input
    
    if [[ -n "$packages_input" ]]; then
        read -ra selected_packages <<< "$packages_input"
        
        echo -e "\n${CYAN}Selected packages:${RESET}"
        for package in "${selected_packages[@]}"; do
            local status
            status=$(check_package_availability "$package")
            case "$status" in
                "installed") echo -e "  ${GREEN}✓${RESET} $package (already installed)" ;;
                "available") echo -e "  ${CYAN}ℹ${RESET} $package (available)" ;;
                "unavailable") echo -e "  ${RED}✗${RESET} $package (not found)" ;;
            esac
        done
        
        echo
        read -p "Proceed with installation? [Y/n]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_packages "${selected_packages[@]}"
        fi
    else
        echo -e "${YELLOW}⚠${RESET} No packages specified"
    fi
}

show_system_info() {
    echo -e "${CYAN}${BOLD}System Information & BlackArch Status${RESET}"
    echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    echo -e "${YELLOW}${BOLD}Hardware:${RESET}"
    echo -e "  CPU: $(cat /proc/cpuinfo | grep 'model name' | head -1 | cut -d':' -f2 | xargs)"
    echo -e "  Cores: $(nproc)"
    echo -e "  Memory: $(free -h | grep '^Mem:' | awk '{print $2 " total, " $3 " used"}')"
    echo -e "  Storage: $(df -h / | tail -1 | awk '{print $2 " total, " $4 " available"}')"
    echo
    
    echo -e "${YELLOW}${BOLD}System:${RESET}"
    echo -e "  Distribution: $(get_system_info)"
    echo -e "  Kernel: $(uname -r)"
    echo -e "  Architecture: $(uname -m)"
    echo -e "  Uptime: $(uptime -p)"
    echo
    
    echo -e "${YELLOW}${BOLD}BlackArch Repository Status:${RESET}"
    echo -e "  Total Installed Packages: $(pacman -Q | wc -l)"
    
    local total_blackarch_tools=$(get_total_blackarch_tools)
    if [[ $total_blackarch_tools -gt 0 ]]; then
        echo -e "  BlackArch Tools Available: ${GREEN}$total_blackarch_tools${RESET}"
        echo -e "  BlackArch Tools Installed: $(pacman -Q | grep -c blackarch || echo "0")"
    else
        echo -e "  BlackArch Repository: ${RED}Not configured${RESET}"
    fi
    echo
    
    echo -e "${YELLOW}${BOLD}kygoX Status:${RESET}"
    echo -e "  Version: $SCRIPT_VERSION ($SCRIPT_CODENAME)"
    echo -e "  Cache Directory: $CACHE_DIR"
    echo -e "  Log Directory: $LOG_DIR"
    echo
}

# =============================================================================
# COMMAND LINE ARGUMENT PARSING
# =============================================================================

show_help() {
    cat << 'HELP_TEXT'
kygoX v0.2.0 Phoenix - Arch Linux Security Testing Suite

USAGE:
    sudo ./kygox [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be installed without installing
    -f, --force            Force installation of packages
    --no-auto-fix          Disable automatic error fixing
    --update-db            Update BlackArch database and exit

EXAMPLES:
    sudo ./kygox                    # Interactive mode with animated UI
    sudo ./kygox -v                 # Verbose interactive mode
    sudo ./kygox --dry-run          # Preview installations

FEATURES:
    • Animated UI with progress indicators
    • Real-time BlackArch repository scanning
    • Category-specific tool discovery
    • Intelligent error handling and recovery
    • Complete BlackArch integration
    • Clean interface hiding technical details

CATEGORIES:
    1. Information Gathering    - Network reconnaissance and OSINT tools
    2. Vulnerability Analysis   - Security assessment and scanning tools  
    3. Web Application Analysis - Web security testing frameworks
    4. Password Attacks         - Password cracking and analysis tools
    5. Wireless Attacks         - WiFi and wireless security tools
    6. Exploitation Tools       - Penetration testing frameworks
    7. Digital Forensics        - Forensics and data recovery tools
    8. Sniffing & Spoofing      - Network monitoring and manipulation

SUPPORT:
    Repository: https://github.com/0xb0rn3/kygox
    Author: 0xb0rn3 (IG: theehiv3, X: 0xbv1)
HELP_TEXT
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --no-auto-fix)
                AUTO_FIX=false
                shift
                ;;
            --update-db)
                setup_blackarch_repository
                get_total_blackarch_tools
                echo "BlackArch repository updated. Total tools available: $TOTAL_AVAILABLE_TOOLS"
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

# =============================================================================
# CLEANUP AND MAIN EXECUTION
# =============================================================================

cleanup_on_exit() {
    local exit_code="${1:-0}"
    
    log_message "INFO" "Performing cleanup operations..."
    
    # Reset umask if needed
    reset_secure_umask
    
    # Kill any background processes
    jobs -p 2>/dev/null | xargs -r kill 2>/dev/null || true
    
    # Clean temporary files
    rm -rf "$CACHE_DIR" 2>/dev/null || true
    
    log_message "INFO" "kygoX session ended"
    exit "$exit_code"
}

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Create cache directory
    mkdir -p "$CACHE_DIR"
    
    # Display banner with tool count
    display_banner
    
    # System validation and setup
    validate_system
    install_dependencies
    setup_blackarch_repository
    
    # Create analysis tools
    create_ui_loader
    create_tool_analyzer
    create_error_handler
    
    # Show status
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}DRY RUN MODE - No packages will be installed${RESET}"
        echo
    fi
    
    # Main interactive loop
    while true; do
        show_main_menu
        read -p "Select option: " -r choice
        echo
        
        if ! handle_menu_selection "$choice"; then
            echo -e "${RED}Invalid selection. Please try again.${RESET}"
            sleep 1
        fi
        
        echo
        read -p "Press Enter to continue..." -r
    done
}

# Signal handlers
trap 'cleanup_on_exit 130' INT TERM
trap 'cleanup_on_exit $?' EXIT

# Execute main function with all arguments
main "$@"
