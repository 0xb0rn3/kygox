#!/usr/bin/env python3

import subprocess
import sys
import os
import json
import tempfile
from pathlib import Path
from typing import Set, List, Dict, Tuple
from datetime import datetime

LOG_FILE = Path.home() / ".kygox" / "uninstall.log"
BACKUP_FILE = Path.home() / ".kygox" / f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
STATE_FILE = Path.home() / ".kygox" / "state.json"

RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
BOLD = '\033[1m'
RESET = '\033[0m'


def log(msg: str, level: str = "INFO"):
    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open(LOG_FILE, 'a') as f:
        f.write(f"[{timestamp}] [{level}] {msg}\n")


def run_cmd(cmd: List[str], capture: bool = True, check: bool = False) -> Tuple[bool, str]:
    try:
        if capture:
            result = subprocess.run(cmd, capture_output=True, text=True, check=check)
            return (result.returncode == 0, result.stdout.strip())
        else:
            result = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=check)
            return (result.returncode == 0, "")
    except subprocess.CalledProcessError as e:
        log(f"{' '.join(cmd)} failed: {e}", "ERROR")
        return (False, str(e))
    except Exception as e:
        log(f"{' '.join(cmd)} exception: {e}", "ERROR")
        return (False, str(e))


def check_root():
    if os.geteuid() != 0:
        print(f"{RED}{BOLD}ROOT REQUIRED{RESET}")
        print(f"sudo python3 {sys.argv[0]}")
        sys.exit(1)


def check_pacman():
    success, _ = run_cmd(['which', 'pacman'])
    if not success:
        print(f"{RED}pacman not found - Arch-based system required{RESET}")
        sys.exit(1)


def get_repo_packages() -> Set[str]:
    print(f"{CYAN}Querying BlackArch repository...{RESET}")
    
    success, output = run_cmd(['pacman', '-Sl', 'blackarch'])
    if not success:
        log("Failed to query blackarch repository", "ERROR")
        return set()
    
    packages = set()
    for line in output.split('\n'):
        if line:
            parts = line.split()
            if len(parts) >= 2:
                packages.add(parts[1])
    
    count = len(packages)
    print(f"Repository: {count} packages")
    log(f"Repository contains {count} packages")
    return packages


def get_installed_packages() -> Set[str]:
    print(f"{CYAN}Scanning system...{RESET}")
    
    success, output = run_cmd(['pacman', '-Qq'])
    if not success:
        log("Failed to query installed packages", "ERROR")
        return set()
    
    packages = set(output.split('\n')) - {''}
    count = len(packages)
    print(f"Installed: {count} packages")
    log(f"System has {count} packages")
    return packages


def calculate_intersection(repo: Set[str], installed: Set[str]) -> Set[str]:
    print(f"{CYAN}Calculating intersection...{RESET}")
    
    matched = repo & installed
    count = len(matched)
    
    print(f"\nRepository:  {len(repo):>5}")
    print(f"Installed:   {len(installed):>5}")
    print(f"{RED}Targets:     {count:>5}{RESET}")
    
    if count > 0 and len(repo) > 0:
        rate = (count / len(repo)) * 100
        print(f"Match:       {rate:>5.1f}%")
    
    log(f"Intersection: {count} packages", "INFO")
    return matched


def save_backup(packages: Set[str]):
    backup_data = {
        'timestamp': datetime.now().isoformat(),
        'count': len(packages),
        'packages': sorted(list(packages))
    }
    
    BACKUP_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(BACKUP_FILE, 'w') as f:
        json.dump(backup_data, f, indent=2)
    
    print(f"Backup: {BACKUP_FILE}")
    log(f"Backup saved: {BACKUP_FILE}")


def get_package_dependencies(packages: Set[str]) -> Set[str]:
    print(f"{CYAN}Analyzing dependencies...{RESET}")
    
    deps = set()
    for pkg in packages:
        success, output = run_cmd(['pactree', '-r', '-u', pkg])
        if success:
            for line in output.split('\n'):
                dep = line.strip()
                if dep and dep != pkg:
                    deps.add(dep)
    
    orphaned = deps - packages
    if orphaned:
        print(f"Dependencies: {len(orphaned)} orphaned packages found")
        log(f"Orphaned dependencies: {len(orphaned)}", "INFO")
        return packages | orphaned
    
    return packages


def confirm_removal(packages: Set[str], force: bool) -> bool:
    if force:
        return True
    
    print(f"\n{RED}{BOLD}REMOVE {len(packages)} PACKAGES{RESET}")
    
    sample = sorted(list(packages))[:30]
    print(f"\n{YELLOW}Sample ({min(30, len(packages))}/{len(packages)}):{RESET}")
    for pkg in sample:
        print(f"  {pkg}")
    if len(packages) > 30:
        print(f"  ... {len(packages) - 30} more")
    
    print(f"\n{CYAN}Confirm [REMOVE ALL]:{RESET} ", end='')
    response = input().strip()
    
    return response == "REMOVE ALL"


def remove_packages_bulk(packages: Set[str], dry_run: bool) -> Dict[str, int]:
    print(f"\n{CYAN}Removing packages...{RESET}")
    
    if dry_run:
        print(f"{YELLOW}DRY RUN{RESET}")
        return {'removed': len(packages), 'failed': 0}
    
    stats = {'removed': 0, 'failed': 0}
    packages_list = sorted(list(packages))
    
    try:
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.txt') as tmp:
            tmp_path = tmp.name
            tmp.write('\n'.join(packages_list))
        
        with open(tmp_path, 'r') as f:
            process = subprocess.Popen(
                ['pacman', '-Rns', '--noconfirm', '-'],
                stdin=f,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = process.communicate()
        
        if process.returncode == 0:
            print(f"{GREEN}Transaction complete{RESET}")
            stats['removed'] = len(packages)
            log("Bulk removal successful", "INFO")
        else:
            print(f"{YELLOW}Primary removal failed, attempting force...{RESET}")
            log(f"Primary removal failed: {stderr}", "WARN")
            
            with open(tmp_path, 'r') as f:
                process = subprocess.Popen(
                    ['pacman', '-Rdd', '--noconfirm', '-'],
                    stdin=f,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                print(f"{GREEN}Force removal complete{RESET}")
                stats['removed'] = len(packages)
                log("Force removal successful", "INFO")
            else:
                print(f"{RED}Force removal failed{RESET}")
                stats['failed'] = len(packages)
                log(f"Force removal failed: {stderr}", "ERROR")
        
        os.unlink(tmp_path)
        
    except Exception as e:
        print(f"{RED}Removal error: {e}{RESET}")
        log(f"Exception during removal: {e}", "ERROR")
        stats['failed'] = len(packages)
    
    return stats


def remove_packages_individual(packages: Set[str], dry_run: bool) -> Dict[str, int]:
    print(f"\n{CYAN}Removing packages individually...{RESET}")
    
    if dry_run:
        print(f"{YELLOW}DRY RUN{RESET}")
        return {'removed': len(packages), 'failed': 0}
    
    stats = {'removed': 0, 'failed': 0}
    total = len(packages)
    
    for idx, pkg in enumerate(sorted(packages), 1):
        print(f"[{idx}/{total}] {pkg}...", end=' ')
        
        success, _ = run_cmd(['pacman', '-Rns', '--noconfirm', pkg], capture=False)
        if success:
            print(f"{GREEN}OK{RESET}")
            stats['removed'] += 1
        else:
            success, _ = run_cmd(['pacman', '-Rdd', '--noconfirm', pkg], capture=False)
            if success:
                print(f"{YELLOW}FORCED{RESET}")
                stats['removed'] += 1
            else:
                print(f"{RED}FAILED{RESET}")
                stats['failed'] += 1
                log(f"Failed to remove {pkg}", "ERROR")
    
    return stats


def clean_orphans():
    print(f"\n{CYAN}Cleaning orphans...{RESET}")
    
    success, output = run_cmd(['pacman', '-Qdtq'])
    if not success or not output:
        print("No orphans")
        return
    
    orphans = output.split('\n')
    print(f"Found {len(orphans)} orphans")
    
    run_cmd(['pacman', '-Rns', '--noconfirm'] + orphans, capture=False)
    print(f"{GREEN}Orphans removed{RESET}")


def remove_repository_config():
    print(f"\n{CYAN}Removing repository configuration...{RESET}")
    
    try:
        with open('/etc/pacman.conf', 'r') as f:
            lines = f.readlines()
        
        with open('/etc/pacman.conf', 'w') as f:
            skip = False
            for line in lines:
                if '[blackarch]' in line:
                    skip = True
                    continue
                if skip and line.strip().startswith('['):
                    skip = False
                if not skip:
                    f.write(line)
        
        print(f"pacman.conf: {GREEN}cleaned{RESET}")
        log("Removed BlackArch from pacman.conf", "INFO")
    except Exception as e:
        print(f"pacman.conf: {RED}error{RESET}")
        log(f"Failed to modify pacman.conf: {e}", "ERROR")
    
    mirrorlist = Path('/etc/pacman.d/blackarch-mirrorlist')
    if mirrorlist.exists():
        mirrorlist.unlink()
        print(f"mirrorlist: {GREEN}removed{RESET}")
    
    success, _ = run_cmd(['pacman', '-Qi', 'blackarch-keyring'])
    if success:
        run_cmd(['pacman', '-Rns', '--noconfirm', 'blackarch-keyring'], capture=False)
        print(f"keyring: {GREEN}removed{RESET}")


def sync_databases():
    print(f"\n{CYAN}Syncing databases...{RESET}")
    run_cmd(['pacman', '-Sy', '--noconfirm'], capture=False)


def clear_state():
    if STATE_FILE.exists():
        STATE_FILE.unlink()
        print(f"State file: {GREEN}cleared{RESET}")


def main():
    print(f"{BOLD}kygox-uninstall{RESET}")
    print("=" * 60)
    
    check_root()
    check_pacman()
    
    dry_run = '--dry-run' in sys.argv or '-n' in sys.argv
    keep_repo = '--keep-repo' in sys.argv
    force = '--force' in sys.argv or '-f' in sys.argv
    individual = '--individual' in sys.argv or '-i' in sys.argv
    clean_orphans_flag = '--clean-orphans' in sys.argv
    include_deps = '--deps' in sys.argv
    
    if dry_run:
        print(f"{YELLOW}DRY RUN MODE{RESET}\n")
    
    repo_pkgs = get_repo_packages()
    if not repo_pkgs:
        print(f"{RED}Repository query failed{RESET}")
        sys.exit(1)
    
    installed_pkgs = get_installed_packages()
    if not installed_pkgs:
        print(f"{RED}System query failed{RESET}")
        sys.exit(1)
    
    matched = calculate_intersection(repo_pkgs, installed_pkgs)
    
    if not matched:
        print(f"\n{GREEN}{BOLD}SYSTEM CLEAN{RESET}")
        
        if not keep_repo and not dry_run:
            print(f"\n{CYAN}Remove repository? [y/N]:{RESET} ", end='')
            if input().strip().lower() == 'y':
                remove_repository_config()
                sync_databases()
        
        sys.exit(0)
    
    if include_deps:
        matched = get_package_dependencies(matched)
    
    save_backup(matched)
    
    if not confirm_removal(matched, force):
        print(f"\n{YELLOW}CANCELLED{RESET}")
        sys.exit(0)
    
    if individual:
        stats = remove_packages_individual(matched, dry_run)
    else:
        stats = remove_packages_bulk(matched, dry_run)
    
    print(f"\n{BOLD}SUMMARY{RESET}")
    print(f"Removed: {GREEN}{stats['removed']}{RESET}")
    print(f"Failed:  {RED}{stats['failed']}{RESET}")
    
    if stats['failed'] > 0:
        print(f"\n{YELLOW}Log: {LOG_FILE}{RESET}")
    
    if not dry_run:
        if clean_orphans_flag:
            clean_orphans()
        
        if not keep_repo:
            remove_repository_config()
            sync_databases()
        
        clear_state()
    
    print(f"\n{GREEN}{BOLD}COMPLETE{RESET}")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{YELLOW}INTERRUPTED{RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{RED}FATAL: {e}{RESET}")
        log(f"FATAL: {e}", "ERROR")
        sys.exit(1)
