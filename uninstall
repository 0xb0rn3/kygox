#!/usr/bin/env bash

set -euo pipefail

# CONFIGURATION
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_CODENAME="Purge"
readonly AUTHOR="0xb0rn3"
readonly REPO_URL="https://github.com/0xb0rn3/kygox"

# System Configuration
readonly ORIGINAL_USER="${SUDO_USER:-$(whoami)}"
readonly USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="$USER_HOME/.kygox"
readonly CONFIG_DIR="$USER_HOME/.config/kygox"
readonly BACKUP_DIR="$CONFIG_DIR/backups/uninstall_$(date +%Y%m%d_%H%M%S)"

# Colors and UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# Global State
declare -g VERBOSE_MODE=false
declare -g DRY_RUN=false
declare -g FORCE_REMOVE=false
declare -g KEEP_CONFIG=false
declare -g LOADER_PID=""
declare -A REMOVAL_STATS=(
    ["scanned"]=0
    ["found"]=0
    ["removed"]=0
    ["failed"]=0
)

# ============================================================================
# ANIMATED LOADERS
# ============================================================================

show_purge_loader() {
    local message="$1"
    local duration="${2:-5}"
    local pid="$$"
    
    (
        local frames=(
            "ğŸ—‘ï¸ "
            "ğŸ—‘ï¸."
            "ğŸ—‘ï¸.."
            "ğŸ—‘ï¸..."
            "â™»ï¸..."
            "â™»ï¸.."
            "â™»ï¸."
            "â™»ï¸ "
        )
        
        local start_time=$(date +%s)
        local i=0
        
        tput civis
        
        while kill -0 $pid 2>/dev/null; do
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            
            if [[ $elapsed -ge $duration ]]; then
                break
            fi
            
            local frame="${frames[$((i % ${#frames[@]}))]}"
            local progress=$((elapsed * 100 / duration))
            
            local bar_width=40
            local filled=$((progress * bar_width / 100))
            local empty=$((bar_width - filled))
            
            printf "\r${RED}${BOLD}$frame ${message}${RESET} "
            printf "${RED}["
            printf "%${filled}s" | tr ' ' 'â–ˆ'
            printf "%${empty}s" | tr ' ' 'â–‘'
            printf "]${RESET} ${YELLOW}${progress}%%${RESET}"
            
            ((i++))
            sleep 0.1
        done
        
        printf "\r${GREEN}${BOLD}âœ“ ${message}${RESET}%*s\n" $(($(tput cols) - ${#message} - 3)) ""
        tput cnorm
    ) &
    
    LOADER_PID=$!
}

show_scan_loader() {
    local message="$1"
    local duration="${2:-5}"
    local pid="$$"
    
    (
        local start_time=$(date +%s)
        local i=0
        
        tput civis
        
        while kill -0 $pid 2>/dev/null; do
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            
            if [[ $elapsed -ge $duration ]]; then
                break
            fi
            
            local progress=$((elapsed * 100 / duration))
            local bar_width=50
            local pos=$((i % bar_width))
            
            printf "\r${CYAN}${BOLD}ğŸ” ${message}${RESET} ${DIM}["
            for ((j=0; j<bar_width; j++)); do
                if [[ $j -eq $pos ]]; then
                    printf "${GREEN}${BOLD}â—†${RESET}${DIM}"
                else
                    printf "â”€"
                fi
            done
            printf "]${RESET} ${YELLOW}${progress}%%${RESET}"
            
            ((i++))
            sleep 0.05
        done
        
        printf "\r${GREEN}${BOLD}âœ“ ${message}${RESET}%*s\n" $(($(tput cols) - ${#message} - 3)) ""
        tput cnorm
    ) &
    
    LOADER_PID=$!
}

stop_loader() {
    if [[ -n "$LOADER_PID" ]] && kill -0 $LOADER_PID 2>/dev/null; then
        kill $LOADER_PID 2>/dev/null || true
        wait $LOADER_PID 2>/dev/null || true
    fi
    LOADER_PID=""
    tput cnorm
}

# ============================================================================
# CORE FUNCTIONS
# ============================================================================

log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$LOG_DIR/kygox_uninstall.log"
    
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        echo "[$level] $message" >&2
    fi
}

error_exit() {
    local message="$1"
    local exit_code="${2:-1}"
    stop_loader
    log_message "ERROR" "$message"
    echo -e "${RED}${BOLD}[ERROR]${RESET} $message" >&2
    exit "$exit_code"
}

print_banner() {
    clear
    cat << 'EOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                        â•‘
â•‘        â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—                   â•‘
â•‘        â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•                   â•‘
â•‘        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•”â•                    â•‘
â•‘        â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—                    â•‘
â•‘        â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—                   â•‘
â•‘        â•šâ•â•  â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•                   â•‘
â•‘                                                                        â•‘
â•‘                   ğŸ—‘ï¸  UNINSTALLER v1.0.0 Purge  â™»ï¸                     â•‘
â•‘                 By 0xb0rn3 | Complete Removal Tool                    â•‘
â•‘                                                                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo
}

check_root() {
    echo -e "${CYAN}[*] Checking privileges...${RESET}"
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run with sudo privileges"
    fi
    echo -e "${GREEN}[âœ“] Running with root privileges${RESET}"
    echo
}

create_backup() {
    log_message "INFO" "Creating backup before uninstallation..."
    
    mkdir -p "$BACKUP_DIR"
    
    # Backup pacman.conf
    if [[ -f /etc/pacman.conf ]]; then
        cp /etc/pacman.conf "$BACKUP_DIR/pacman.conf.backup"
        log_message "INFO" "Backed up pacman.conf"
    fi
    
    # Backup BlackArch mirrorlist
    if [[ -f /etc/pacman.d/blackarch-mirrorlist ]]; then
        cp /etc/pacman.d/blackarch-mirrorlist "$BACKUP_DIR/blackarch-mirrorlist.backup"
        log_message "INFO" "Backed up BlackArch mirrorlist"
    fi
    
    # Save list of installed BlackArch packages
    if command -v pacman &>/dev/null; then
        pacman -Qm | grep -i blackarch > "$BACKUP_DIR/blackarch_packages.txt" 2>/dev/null || true
        log_message "INFO" "Saved list of installed packages"
    fi
    
    echo -e "${GREEN}[+] Backup created at: $BACKUP_DIR${RESET}"
}

get_all_blackarch_packages() {
    log_message "INFO" "Scanning for BlackArch packages..."
    
    echo -e "${CYAN}[*] Querying BlackArch repository...${RESET}"
    
    # Check if BlackArch repository is configured
    if ! grep -q "^\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo -e "${YELLOW}[!] BlackArch repository not found in pacman.conf${RESET}"
        return 0
    fi
    
    # Get all packages from BlackArch repository
    if pacman -Sl blackarch &>/dev/null; then
        echo -e "${GREEN}[âœ“] BlackArch repository accessible${RESET}"
        pacman -Sl blackarch 2>/dev/null | awk '{print $2}' | sort -u
    else
        echo -e "${YELLOW}[!] Cannot access BlackArch repository${RESET}"
        return 0
    fi
}

get_installed_blackarch_packages() {
    log_message "INFO" "Identifying installed BlackArch packages..."
    
    echo -e "${CYAN}[*] Scanning installed packages...${RESET}"
    
    local installed_ba_packages=()
    
    # Method 1: Get packages directly from blackarch group
    echo -ne "${DIM}Method 1: Checking blackarch groups...${RESET}\r"
    while IFS= read -r pkg; do
        if [[ -n "$pkg" ]]; then
            installed_ba_packages+=("$pkg")
        fi
    done < <(pacman -Qg 2>/dev/null | grep "^blackarch" | awk '{print $2}' | sort -u)
    
    # Method 2: Get packages installed from blackarch repo
    echo -ne "${DIM}Method 2: Checking package origins...    ${RESET}\r"
    while IFS= read -r pkg; do
        # Check if package is from blackarch repository
        local repo=$(pacman -Qi "$pkg" 2>/dev/null | grep "^Repository" | awk '{print $3}')
        if [[ "$repo" == "blackarch" ]]; then
            # Only add if not already in list
            if ! printf '%s\n' "${installed_ba_packages[@]}" | grep -q "^${pkg}$"; then
                installed_ba_packages+=("$pkg")
            fi
        fi
    done < <(pacman -Qq 2>/dev/null)
    
    # Remove duplicates and sort
    installed_ba_packages=($(printf '%s\n' "${installed_ba_packages[@]}" | sort -u))
    
    echo -e "${GREEN}[âœ“] Package scan complete - Found ${#installed_ba_packages[@]} packages${RESET}"
    
    # Output the list
    printf '%s\n' "${installed_ba_packages[@]}"
}

scan_system() {
    echo -e "${CYAN}${BOLD}[*] Scanning System for BlackArch Packages${RESET}"
    echo
    
    # First, verify BlackArch repository is configured
    echo -e "${CYAN}[*] Step 1/3: Verifying BlackArch repository...${RESET}"
    
    if grep -q "^\[blackarch\]" /etc/pacman.conf 2>/dev/null; then
        echo -e "${GREEN}[âœ“] BlackArch repository found in pacman.conf${RESET}"
    else
        echo -e "${RED}[âœ—] BlackArch repository NOT found in pacman.conf${RESET}"
        echo -e "${YELLOW}[!] If you have BlackArch configured, the script cannot detect it${RESET}"
        REMOVAL_STATS["scanned"]=0
        REMOVAL_STATS["found"]=0
        return 1
    fi
    
    # Check if we can access the repository
    echo -e "${CYAN}[*] Step 2/3: Checking repository accessibility...${RESET}"
    
    local all_packages=()
    local repo_accessible=false
    
    if timeout 5 pacman -Sl blackarch &>/dev/null; then
        echo -e "${GREEN}[âœ“] Repository is accessible${RESET}"
        repo_accessible=true
        all_packages=($(timeout 10 pacman -Sl blackarch 2>/dev/null | awk '{print $2}' | head -100))
        REMOVAL_STATS["scanned"]=${#all_packages[@]}
    else
        echo -e "${YELLOW}[!] Cannot access repository (timeout or unavailable)${RESET}"
        REMOVAL_STATS["scanned"]=0
    fi
    
    echo
    echo -e "${CYAN}[*] Step 3/3: Identifying installed packages...${RESET}"
    
    # Get installed BlackArch packages
    local installed_packages=()
    
    # Quick method: Check blackarch groups
    echo -e "${DIM}  â†’ Checking blackarch groups...${RESET}"
    local group_count=0
    while IFS= read -r pkg; do
        if [[ -n "$pkg" ]]; then
            installed_packages+=("$pkg")
            ((group_count++))
        fi
    done < <(timeout 10 pacman -Qg 2>/dev/null | grep "^blackarch" | awk '{print $2}' | sort -u)
    
    echo -e "${DIM}  â†’ Found ${group_count} packages in blackarch groups${RESET}"
    
    # Additional method: Check installed packages from blackarch repo
    echo -e "${DIM}  â†’ Verifying package repositories...${RESET}"
    local verified=0
    
    # Only check first 50 packages to avoid hanging
    local check_count=0
    while IFS= read -r pkg && [[ $check_count -lt 50 ]]; do
        ((check_count++))
        local repo=$(timeout 2 pacman -Qi "$pkg" 2>/dev/null | grep "^Repository" | awk '{print $3}')
        if [[ "$repo" == "blackarch" ]]; then
            if ! printf '%s\n' "${installed_packages[@]}" | grep -q "^${pkg}$"; then
                installed_packages+=("$pkg")
                ((verified++))
            fi
        fi
    done < <(pacman -Qq 2>/dev/null)
    
    echo -e "${DIM}  â†’ Verified ${verified} additional packages${RESET}"
    
    # Remove duplicates and sort
    if [[ ${#installed_packages[@]} -gt 0 ]]; then
        installed_packages=($(printf '%s\n' "${installed_packages[@]}" | sort -u))
    fi
    
    REMOVAL_STATS["found"]=${#installed_packages[@]}
    
    echo
    echo -e "${GREEN}${BOLD}[+] Scan Results:${RESET}"
    echo -e "  ${WHITE}â€¢${RESET} BlackArch packages in repository: ${REMOVAL_STATS[scanned]}"
    echo -e "  ${WHITE}â€¢${RESET} BlackArch packages on your system: ${RED}${REMOVAL_STATS[found]}${RESET}"
    echo
    
    if [[ ${REMOVAL_STATS[found]} -eq 0 ]]; then
        echo -e "${GREEN}[+] No BlackArch packages found installed.${RESET}"
        echo
        echo -e "${YELLOW}Debug Information:${RESET}"
        echo -e "  ${WHITE}â€¢${RESET} Repository configured: $(grep -q "^\[blackarch\]" /etc/pacman.conf && echo "Yes" || echo "No")"
        echo -e "  ${WHITE}â€¢${RESET} BlackArch groups found: $(timeout 5 pacman -Qg 2>/dev/null | grep -c "^blackarch" || echo "0")"
        echo -e "  ${WHITE}â€¢${RESET} Total installed packages: $(pacman -Qq 2>/dev/null | wc -l)"
        echo
        return 1
    fi
    
    # Display some installed packages
    echo -e "${YELLOW}Installed BlackArch packages (showing first 20):${RESET}"
    local count=0
    for pkg in "${installed_packages[@]}"; do
        if [[ $count -ge 20 ]]; then
            echo -e "  ${DIM}... and $((${#installed_packages[@]} - 20)) more packages${RESET}"
            break
        fi
        echo -e "  ${RED}â€¢${RESET} $pkg"
        ((count++))
    done
    echo
    
    # Return the list for removal
    printf '%s\n' "${installed_packages[@]}"
}

remove_package() {
    local package="$1"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}[DRY RUN] Would remove: $package${RESET}"
        return 0
    fi
    
    log_message "INFO" "Removing package: $package"
    
    if pacman -Rns --noconfirm "$package" >> "$LOG_DIR/kygox_uninstall.log" 2>&1; then
        echo -e "${GREEN}[+] Removed: $package${RESET}"
        ((REMOVAL_STATS["removed"]++))
        return 0
    elif pacman -Rn --noconfirm "$package" >> "$LOG_DIR/kygox_uninstall.log" 2>&1; then
        echo -e "${GREEN}[+] Removed (without dependencies): $package${RESET}"
        ((REMOVAL_STATS["removed"]++))
        return 0
    elif pacman -R --noconfirm "$package" >> "$LOG_DIR/kygox_uninstall.log" 2>&1; then
        echo -e "${YELLOW}[!] Removed (basic): $package${RESET}"
        ((REMOVAL_STATS["removed"]++))
        return 0
    else
        echo -e "${RED}[!] Failed to remove: $package${RESET}"
        ((REMOVAL_STATS["failed"]++))
        return 1
    fi
}

remove_packages() {
    local packages=("$@")
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        echo -e "${YELLOW}[!] No packages to remove${RESET}"
        return 0
    fi
    
    echo -e "${CYAN}${BOLD}[*] Removing ${#packages[@]} BlackArch Packages${RESET}"
    echo
    
    if [[ "$DRY_RUN" != "true" ]]; then
        show_purge_loader "Preparing removal process" 2 &
        wait $LOADER_PID 2>/dev/null || true
    fi
    
    local batch_size=10
    local total_batches=$(( (${#packages[@]} + batch_size - 1) / batch_size ))
    
    for ((i=0; i<${#packages[@]}; i+=batch_size)); do
        local batch=("${packages[@]:i:batch_size}")
        local batch_num=$(( i / batch_size + 1 ))
        
        echo -e "${CYAN}[*] Batch $batch_num/$total_batches${RESET}"
        
        for pkg in "${batch[@]}"; do
            remove_package "$pkg"
        done
        
        local progress=$(( (i + batch_size) * 100 / ${#packages[@]} ))
        if [[ $progress -gt 100 ]]; then
            progress=100
        fi
        echo -e "${GREEN}[+] Progress: ${progress}% (Removed: ${REMOVAL_STATS[removed]}, Failed: ${REMOVAL_STATS[failed]})${RESET}"
        echo
    done
}

remove_blackarch_repository() {
    echo -e "${CYAN}${BOLD}[*] Removing BlackArch Repository Configuration${RESET}"
    echo
    
    show_purge_loader "Cleaning repository configuration" 3 &
    local loader_pid=$!
    
    # Remove BlackArch from pacman.conf
    if [[ -f /etc/pacman.conf ]]; then
        sed -i '/\[blackarch\]/,+1d' /etc/pacman.conf
        log_message "INFO" "Removed BlackArch from pacman.conf"
    fi
    
    # Remove BlackArch mirrorlist
    if [[ -f /etc/pacman.d/blackarch-mirrorlist ]]; then
        rm -f /etc/pacman.d/blackarch-mirrorlist
        log_message "INFO" "Removed BlackArch mirrorlist"
    fi
    
    # Remove BlackArch keyring
    if pacman -Qi blackarch-keyring &>/dev/null; then
        pacman -Rns --noconfirm blackarch-keyring >> "$LOG_DIR/kygox_uninstall.log" 2>&1 || true
        log_message "INFO" "Removed BlackArch keyring"
    fi
    
    # Remove BlackArch keys from pacman keyring
    pacman-key --delete 4345771566D76038C7FEB43863EC0ADBEA87E4E3 2>/dev/null || true
    
    wait $loader_pid 2>/dev/null || true
    
    echo -e "${GREEN}[+] BlackArch repository configuration removed${RESET}"
    echo
}

clean_kygox_files() {
    if [[ "$KEEP_CONFIG" == "true" ]]; then
        echo -e "${YELLOW}[!] Keeping kygox configuration files${RESET}"
        return 0
    fi
    
    echo -e "${CYAN}${BOLD}[*] Cleaning kygox Files${RESET}"
    echo
    
    local files_to_remove=(
        "$CONFIG_DIR"
        "$LOG_DIR"
    )
    
    # Don't remove backup directory we just created
    files_to_remove=("${files_to_remove[@]/$BACKUP_DIR/}")
    
    for file in "${files_to_remove[@]}"; do
        if [[ -n "$file" && -e "$file" ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY RUN] Would remove: $file${RESET}"
            else
                rm -rf "$file"
                echo -e "${GREEN}[+] Removed: $file${RESET}"
                log_message "INFO" "Removed: $file"
            fi
        fi
    done
    
    echo
}

sync_databases() {
    echo -e "${CYAN}[*] Synchronizing package databases...${RESET}"
    
    show_scan_loader "Updating package databases" 2 &
    local loader_pid=$!
    
    pacman -Sy --noconfirm >> "$LOG_DIR/kygox_uninstall.log" 2>&1
    
    wait $loader_pid 2>/dev/null || true
    
    echo -e "${GREEN}[+] Package databases synchronized${RESET}"
    echo
}

show_summary() {
    echo
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${CYAN}${BOLD}â•‘                   UNINSTALLATION SUMMARY                   â•‘${RESET}"
    echo -e "${CYAN}${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  Packages Scanned:      ${WHITE}${REMOVAL_STATS[scanned]}${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  Packages Found:        ${YELLOW}${REMOVAL_STATS[found]}${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  Successfully Removed:  ${GREEN}${REMOVAL_STATS[removed]}${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  Failed to Remove:      ${RED}${REMOVAL_STATS[failed]}${RESET}"
    echo -e "${CYAN}${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  Backup Location:                                          ${CYAN}${BOLD}â•‘${RESET}"
    echo -e "${CYAN}${BOLD}â•‘${RESET}  ${DIM}$BACKUP_DIR${RESET}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo
    
    if [[ ${REMOVAL_STATS[removed]} -gt 0 ]]; then
        echo -e "${GREEN}${BOLD}[âœ“] BlackArch packages successfully removed from your system${RESET}"
    fi
    
    if [[ ${REMOVAL_STATS[failed]} -gt 0 ]]; then
        echo -e "${YELLOW}[!] Some packages could not be removed. Check logs for details:${RESET}"
        echo -e "    ${DIM}$LOG_DIR/kygox_uninstall.log${RESET}"
    fi
    
    echo
}

show_help() {
    cat << 'HELP_TEXT'
kygox-uninstall v1.0.0 Purge - BlackArch Removal Tool

USAGE:
    sudo ./kygox-uninstall [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be removed without removing
    -f, --force            Force removal without confirmation
    -k, --keep-config      Keep kygox configuration files
    --packages-only        Remove only packages, keep repository config
    --repo-only            Remove only repository config, keep packages

EXAMPLES:
    sudo ./kygox-uninstall              # Interactive removal
    sudo ./kygox-uninstall -n           # Preview what would be removed
    sudo ./kygox-uninstall -f           # Force removal without prompts
    sudo ./kygox-uninstall -k           # Keep configuration files

NOTES:
    - A backup is automatically created before removal
    - Backups are stored in: ~/.config/kygox/backups/
    - Logs are saved to: ~/.kygox/kygox_uninstall.log

SUPPORT:
    Repository: https://github.com/0xb0rn3/kygox
    Author: 0xb0rn3
    Email: q4n0@proton.me
HELP_TEXT
}

parse_arguments() {
    local packages_only=false
    local repo_only=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                log_message "INFO" "Verbose mode enabled"
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                log_message "INFO" "Dry-run mode enabled"
                shift
                ;;
            -f|--force)
                FORCE_REMOVE=true
                log_message "INFO" "Force mode enabled"
                shift
                ;;
            -k|--keep-config)
                KEEP_CONFIG=true
                log_message "INFO" "Keep config mode enabled"
                shift
                ;;
            --packages-only)
                packages_only=true
                log_message "INFO" "Packages-only mode enabled"
                shift
                ;;
            --repo-only)
                repo_only=true
                log_message "INFO" "Repo-only mode enabled"
                shift
                ;;
            *)
                echo -e "${RED}[ERROR] Unknown option: $1${RESET}" >&2
                echo "Run with --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # Handle mutually exclusive options
    if [[ "$packages_only" == "true" && "$repo_only" == "true" ]]; then
        echo -e "${RED}[ERROR] Cannot use --packages-only and --repo-only together${RESET}" >&2
        exit 1
    fi
    
    echo "$packages_only $repo_only"
}

confirm_removal() {
    if [[ "$FORCE_REMOVE" == "true" ]]; then
        return 0
    fi
    
    echo
    echo -e "${RED}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${RED}${BOLD}â•‘                        âš ï¸  WARNING âš ï¸                        â•‘${RESET}"
    echo -e "${RED}${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}  This will remove ALL BlackArch packages and              ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}  repository configuration from your system.               ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}                                                            ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}  Found: ${YELLOW}${REMOVAL_STATS[found]} packages${RESET} will be removed                ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}                                                            ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•‘${RESET}  A backup will be created before proceeding.              ${RED}${BOLD}â•‘${RESET}"
    echo -e "${RED}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo
    
    read -p "Type 'REMOVE ALL' to confirm removal: " -r confirmation
    
    if [[ "$confirmation" != "REMOVE ALL" ]]; then
        echo -e "${YELLOW}[!] Uninstallation cancelled${RESET}"
        exit 0
    fi
}

main() {
    # Initialize log
    log_message "INFO" "=== kygox-uninstall started ==="
    
    # Parse arguments
    local packages_only=false
    local repo_only=false
    
    if [[ $# -gt 0 ]]; then
        local options_result
        options_result=$(parse_arguments "$@")
        packages_only=$(echo "$options_result" | cut -d' ' -f1)
        repo_only=$(echo "$options_result" | cut -d' ' -f2)
    fi
    
    # Display banner
    print_banner
    
    # Check root privileges
    check_root
    
    # Show mode
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}${BOLD}[!] DRY RUN MODE - No changes will be made${RESET}"
        echo
    fi
    
    # Scan system for BlackArch packages
    echo -e "${CYAN}[*] Starting system scan...${RESET}"
    echo
    
    local packages_to_remove=()
    if ! mapfile -t packages_to_remove < <(scan_system); then
        # scan_system returns 1 if no packages found
        if [[ ${REMOVAL_STATS[found]} -eq 0 ]]; then
            echo -e "${GREEN}${BOLD}[âœ“] Nothing to remove - system is clean${RESET}"
            log_message "INFO" "No BlackArch packages found"
            exit 0
        fi
    fi
    
    log_message "INFO" "Found ${REMOVAL_STATS[found]} BlackArch packages"
    
    # Exit if no packages found
    if [[ ${REMOVAL_STATS[found]} -eq 0 ]]; then
        echo -e "${GREEN}${BOLD}[âœ“] Nothing to remove - system is clean${RESET}"
        exit 0
    fi
    
    # Confirm removal
    confirm_removal
    
    # Create backup
    if [[ "$DRY_RUN" != "true" ]]; then
        create_backup
        echo
    fi
    
    # Remove packages
    if [[ "$repo_only" != "true" ]]; then
        remove_packages "${packages_to_remove[@]}"
    fi
    
    # Remove repository configuration
    if [[ "$packages_only" != "true" ]]; then
        remove_blackarch_repository
    fi
    
    # Sync databases
    if [[ "$DRY_RUN" != "true" && "$repo_only" != "true" ]]; then
        sync_databases
    fi
    
    # Clean kygox files
    clean_kygox_files
    
    # Show summary
    show_summary
    
    echo -e "${GREEN}${BOLD}[âœ“] Uninstallation complete!${RESET}"
    
    if [[ "$DRY_RUN" != "true" ]]; then
        echo -e "${CYAN}[i] You may want to run 'sudo pacman -Sc' to clean package cache${RESET}"
    fi
    
    log_message "INFO" "=== kygox-uninstall completed ==="
}

# Signal handlers
trap 'stop_loader; exit 130' INT TERM
trap 'stop_loader' EXIT

# Execute main function
main "$@"
