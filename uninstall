#!/usr/bin/env python3
"""
kygox-uninstall
Uses EXACT same intersection mechanism as installer
"""

import subprocess
import sys
import os
import json
import tempfile
from pathlib import Path
from typing import Set, List, Dict

# Configuration
LOG_FILE = Path.home() / ".kygox" / "uninstall.log"
BACKUP_FILE = Path.home() / ".kygox" / "backup.json"

# Colors
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
BOLD = '\033[1m'
RESET = '\033[0m'


def log(msg: str):
    """Simple logging"""
    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(f"{msg}\n")
    print(msg)


def run_cmd(cmd: List[str], capture=True) -> tuple:
    """Run command and return (success, output)"""
    try:
        if capture:
            result = subprocess.run(cmd, capture_output=True, text=True)
            return (result.returncode == 0, result.stdout)
        else:
            result = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return (result.returncode == 0, "")
    except Exception as e:
        log(f"ERROR: {cmd[0]} failed: {e}")
        return (False, "")


def check_root():
    """Verify root privileges"""
    if os.geteuid() != 0:
        print(f"{RED}{BOLD}ERROR: Root privileges required{RESET}")
        print(f"{CYAN}Run: sudo python3 {sys.argv[0]}{RESET}")
        sys.exit(1)


def setup_blackarch_repo():
    """Setup BlackArch repository if not present"""
    print(f"\n{CYAN}Setting up BlackArch repository...{RESET}")
    
    # Check if already configured
    try:
        with open('/etc/pacman.conf', 'r') as f:
            if '[blackarch]' in f.read():
                print(f"{GREEN}âœ“ BlackArch already configured{RESET}")
                run_cmd(['pacman', '-Sy', '--noconfirm'], capture=False)
                return True
    except:
        pass
    
    # Run strap.sh
    print(f"{CYAN}Installing BlackArch repository...{RESET}")
    
    # Download strap.sh
    success, _ = run_cmd(['curl', '-O', 'https://blackarch.org/strap.sh'])
    if not success:
        print(f"{RED}âœ— Failed to download strap.sh{RESET}")
        return False
    
    # Make executable
    run_cmd(['chmod', '+x', 'strap.sh'])
    
    # Run installer
    success, _ = run_cmd(['./strap.sh'], capture=False)
    if not success:
        print(f"{RED}âœ— Failed to setup BlackArch{RESET}")
        return False
    
    # Clean up
    Path('strap.sh').unlink(missing_ok=True)
    
    # Sync databases
    run_cmd(['pacman', '-Sy', '--noconfirm'], capture=False)
    
    print(f"{GREEN}âœ“ BlackArch repository configured{RESET}")
    return True


def verify_blackarch_repo() -> bool:
    """Verify BlackArch repository is accessible"""
    print(f"\n{CYAN}[1/6] Verifying BlackArch repository...{RESET}")
    
    # Test repository access
    success, _ = run_cmd(['pacman', '-Sl', 'blackarch'])
    if success:
        print(f"{GREEN}âœ“ Repository accessible{RESET}")
        return True
    
    # Not accessible, try to set it up
    print(f"{YELLOW}âš  BlackArch repository not accessible{RESET}")
    print(f"{CYAN}Setting up repository for accurate comparison...{RESET}")
    
    return setup_blackarch_repo()


def get_blackarch_packages() -> Set[str]:
    """
    Get ALL packages from BlackArch repository
    """
    print(f"\n{CYAN}[2/6] Querying BlackArch repository...{RESET}")
    
    success, output = run_cmd(['pacman', '-Sl', 'blackarch'])
    if not success:
        return set()
    
    packages = set()
    for line in output.strip().split('\n'):
        if line:
            parts = line.split()
            if len(parts) >= 2:
                packages.add(parts[1])  # Package name
    
    print(f"{GREEN}âœ“ Found {len(packages)} packages in repository{RESET}")
    log(f"BlackArch repository contains {len(packages)} packages")
    return packages


def get_installed_packages() -> Set[str]:
    """
    Get ALL installed packages on system
    """
    print(f"\n{CYAN}[3/6] Scanning installed packages...{RESET}")
    
    success, output = run_cmd(['pacman', '-Qq'])
    if not success:
        return set()
    
    packages = set(output.strip().split('\n'))
    packages.discard('')  # Remove empty strings
    
    print(f"{GREEN}âœ“ Found {len(packages)} installed packages{RESET}")
    return packages


def correlate_packages(blackarch_pkgs: Set[str], installed_pkgs: Set[str]) -> Set[str]:
    """
    Find intersection: BlackArch âˆ© Installed
    """
    print(f"\n{CYAN}[4/6] Calculating intersection...{RESET}")
    print(f"{CYAN}Formula: BlackArch_Repo âˆ© Installed_System{RESET}")
    
    matched = blackarch_pkgs & installed_pkgs
    
    print(f"\n{BOLD}RESULTS:{RESET}")
    print(f"  BlackArch repo:     {len(blackarch_pkgs):>5} packages")
    print(f"  Installed system:   {len(installed_pkgs):>5} packages")
    print(f"  {RED}Matched (to remove): {len(matched):>5} packages{RESET}")
    
    if matched:
        match_rate = (len(matched) / len(blackarch_pkgs)) * 100
        print(f"  Match rate:         {match_rate:>5.1f}%")
    
    log(f"Intersection: {len(matched)} packages matched")
    return matched


def create_backup(packages: Set[str]):
    """Create backup of package list"""
    backup_data = {
        'packages': sorted(list(packages)),
        'count': len(packages)
    }
    
    BACKUP_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(BACKUP_FILE, 'w') as f:
        json.dump(backup_data, f, indent=2)
    
    log(f"Backup created: {BACKUP_FILE}")


def confirm_removal(packages: Set[str]) -> bool:
    """Get user confirmation"""
    print(f"\n{RED}{BOLD}WARNING: This will remove {len(packages)} packages{RESET}")
    
    # Show sample
    sample = sorted(list(packages))[:20]
    print(f"\n{YELLOW}Sample packages (showing 20/{len(packages)}):{RESET}")
    for pkg in sample:
        print(f"  â€¢ {pkg}")
    if len(packages) > 20:
        print(f"  ... and {len(packages) - 20} more")
    
    print(f"\n{CYAN}Type 'REMOVE ALL' to confirm:{RESET} ", end='')
    response = input().strip()
    
    return response == "REMOVE ALL"


def remove_packages(packages: Set[str], dry_run: bool = False) -> Dict[str, int]:
    """
    Remove packages using Bulk Transaction mode.
    Writes targets to a temporary file and pipes to pacman to allow 
    dependency resolution to occur in a single pass.
    """
    print(f"\n{CYAN}[5/6] Removing packages (Bulk Mode)...{RESET}")
    
    if dry_run:
        print(f"{YELLOW}DRY RUN MODE - No actual removal{RESET}")
        return {'removed': len(packages), 'failed': 0}
    
    stats = {'removed': 0, 'failed': 0}
    packages_list = sorted(list(packages))
    
    # Create a temporary file containing the list of packages
    # We use a temp file + stdin to avoid "Argument list too long" errors
    try:
        with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmp:
            tmp_path = tmp.name
            for pkg in packages_list:
                tmp.write(f"{pkg}\n")
        
        print(f"  Executing bulk removal transaction...")
        
        # Command: pacman -Rsu --noconfirm - < tmp_file
        # -R: Remove
        # -s: Recursive (remove dependencies not required by other packages)
        # -u: Unneeded (remove targets that are not required by any other packages)
        # This combination ensures a clean sweep without breaking dependencies
        
        with open(tmp_path, 'r') as f:
            # We pipe the file content to stdin
            process = subprocess.Popen(
                ['pacman', '-Rsu', '--noconfirm', '-'],
                stdin=f,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = process.communicate()
            
        if process.returncode == 0:
            print(f"{GREEN}âœ“ Bulk transaction successful{RESET}")
            stats['removed'] = len(packages)
            log("Bulk removal successful")
        else:
            print(f"{RED}âœ— Bulk transaction failed. Output below:{RESET}")
            print(stderr)
            log(f"Bulk removal failed: {stderr}")
            stats['failed'] = len(packages)
            
            # Fallback: Aggressive Force Remove (Only if standard bulk fails)
            print(f"\n{YELLOW}Attempting aggressive fallback (Force Remove)...{RESET}")
            with open(tmp_path, 'r') as f:
                process = subprocess.Popen(
                    ['pacman', '-Rdd', '--noconfirm', '-'],
                    stdin=f,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                stdout, stderr = process.communicate()
                
            if process.returncode == 0:
                 print(f"{GREEN}âœ“ Force removal successful{RESET}")
                 stats['removed'] = len(packages)
                 stats['failed'] = 0
            else:
                 print(f"{RED}âœ— Force removal failed{RESET}")
        
        # Cleanup
        os.unlink(tmp_path)
            
    except Exception as e:
        print(f"{RED}Error during bulk removal: {e}{RESET}")
        stats['failed'] = len(packages)

    return stats


def clean_repo_config():
    """Remove BlackArch repository configuration"""
    print(f"\n{CYAN}[6/6] Cleaning repository configuration...{RESET}")
    
    # Remove from pacman.conf
    try:
        with open('/etc/pacman.conf', 'r') as f:
            lines = f.readlines()
        
        with open('/etc/pacman.conf', 'w') as f:
            skip = False
            for line in lines:
                if '[blackarch]' in line:
                    skip = True
                    continue
                if skip and line.strip().startswith('['):
                    skip = False
                if not skip:
                    f.write(line)
        
        print(f"{GREEN}âœ“ Removed from pacman.conf{RESET}")
    except Exception as e:
        print(f"{RED}âœ— Failed to modify pacman.conf: {e}{RESET}")
    
    # Remove mirrorlist
    mirrorlist = Path('/etc/pacman.d/blackarch-mirrorlist')
    if mirrorlist.exists():
        mirrorlist.unlink()
        print(f"{GREEN}âœ“ Removed mirrorlist{RESET}")
    
    # Remove keyring
    run_cmd(['pacman', '-Rns', '--noconfirm', 'blackarch-keyring'], capture=False)
    print(f"{GREEN}âœ“ Removed keyring{RESET}")


def main():
    """Main execution flow"""
    print(f"{BOLD}kygox-uninstall{RESET}")
    print("=" * 60)
    
    # Check privileges
    check_root()
    
    # Parse arguments
    dry_run = '--dry-run' in sys.argv or '-n' in sys.argv
    keep_repo = '--keep-repo' in sys.argv
    force = '--force' in sys.argv or '-f' in sys.argv
    
    if dry_run:
        print(f"\n{YELLOW}DRY RUN MODE ENABLED{RESET}")
    
    # STEP 1: Verify repository (setup if needed)
    if not verify_blackarch_repo():
        print(f"\n{RED}CANNOT PROCEED{RESET}")
        print(f"{RED}Failed to setup BlackArch repository{RESET}")
        sys.exit(1)
    
    # STEP 2: Get BlackArch packages (from repository)
    blackarch_pkgs = get_blackarch_packages()
    if not blackarch_pkgs:
        print(f"{RED}Failed to query BlackArch repository{RESET}")
        sys.exit(1)
    
    # STEP 3: Get installed packages (from system)
    installed_pkgs = get_installed_packages()
    if not installed_pkgs:
        print(f"{RED}Failed to query installed packages{RESET}")
        sys.exit(1)
    
    # STEP 4: Intersect
    matched = correlate_packages(blackarch_pkgs, installed_pkgs)
    
    if not matched:
        print(f"\n{GREEN}{BOLD}âœ“ NO PACKAGES TO REMOVE{RESET}")
        print(f"{GREEN}System is clean!{RESET}")
        
        if not keep_repo and not dry_run:
            print(f"\n{CYAN}Remove repository configuration? [y/N]:{RESET} ", end='')
            if input().strip().lower() == 'y':
                clean_repo_config()
        
        sys.exit(0)
    
    # Create backup
    create_backup(matched)
    print(f"\n{GREEN}âœ“ Backup created: {BACKUP_FILE}{RESET}")
    
    # STEP 5: Confirm and remove
    if not force and not dry_run:
        if not confirm_removal(matched):
            print(f"\n{YELLOW}Cancelled by user{RESET}")
            sys.exit(0)
    
    stats = remove_packages(matched, dry_run=dry_run)
    
    # Show results
    print(f"\n{BOLD}REMOVAL SUMMARY:{RESET}")
    print(f"  {GREEN}Removed: {stats['removed']}{RESET}")
    print(f"  {RED}Failed:  {stats['failed']}{RESET}")
    
    if stats['failed'] > 0:
        print(f"\n{YELLOW}Check log for failures: {LOG_FILE}{RESET}")
    
    # Clean repository if requested
    if not keep_repo and not dry_run:
        clean_repo_config()
        print(f"\n{CYAN}Syncing databases...{RESET}")
        run_cmd(['pacman', '-Sy', '--noconfirm'], capture=False)
    
    print(f"\n{GREEN}{BOLD}âœ“ UNINSTALLATION COMPLETE{RESET}")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{YELLOW}Interrupted by user{RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{RED}FATAL ERROR: {e}{RESET}")
        log(f"FATAL: {e}")
        sys.exit(1)
